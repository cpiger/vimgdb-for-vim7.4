From 1ab2967e6d9a67c67b48ead35fb77fdaabc4bec3 Mon Sep 17 00:00:00 2001
From: guyuehuanyu <434342415@qq.com>
Date: Sat, 3 Jan 2015 17:12:02 +0800
Subject: [PATCH 1/2] patch vimgdb-for-vim74

Signed-off-by: guyuehuanyu <434342415@qq.com>
---
 src/Makefile         |   80 +-
 src/auto/configure   |   32 +
 src/buffer.c         |   43 +-
 src/clewn/gdb.h      |  685 +++++++++
 src/clewn/gdb_lvl2.c | 1085 +++++++++++++
 src/clewn/gdb_lvl3.c | 4116 ++++++++++++++++++++++++++++++++++++++++++++++++++
 src/clewn/misc.c     |  645 ++++++++
 src/clewn/misc.h     |   92 ++
 src/clewn/obstack.c  |  442 ++++++
 src/clewn/obstack.h  |  509 +++++++
 src/config.h.in      |    4 +
 src/config.mk.in     |    3 +
 src/configure.in     |   21 +
 src/eval.c           |   29 +
 src/ex_cmds.c        |   15 +-
 src/ex_getln.c       |   48 +
 src/feature.h        |   18 +
 src/gdb.c            | 2458 ++++++++++++++++++++++++++++++
 src/globals.h        |    4 +
 src/gui.c            |   77 +-
 src/gui_gtk_x11.c    |   57 +
 src/gui_x11.c        |   57 +
 src/main.c           |    9 +
 src/normal.c         |   44 +
 src/option.c         |   14 +
 src/option.h         |    5 +
 src/os_unix.c        |  173 +++
 src/proto.h          |    4 +
 src/proto/gdb.pro    |   22 +
 src/screen.c         |    5 +
 src/structs.h        |    9 +-
 src/version.c        |    5 +
 src/window.c         |    4 +
 33 files changed, 10780 insertions(+), 34 deletions(-)
 create mode 100644 src/clewn/gdb.h
 create mode 100644 src/clewn/gdb_lvl2.c
 create mode 100644 src/clewn/gdb_lvl3.c
 create mode 100644 src/clewn/misc.c
 create mode 100644 src/clewn/misc.h
 create mode 100644 src/clewn/obstack.c
 create mode 100644 src/clewn/obstack.h
 create mode 100644 src/gdb.c
 create mode 100644 src/proto/gdb.pro

diff --git a/src/Makefile b/src/Makefile
index c830378..e05e286 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -311,14 +311,14 @@ CClink = $(CC)
 # Change this to your desire and do 'make config' afterwards
 
 # examples (can only use one!):
-#CONF_ARGS = --exec-prefix=/usr
+# CONF_ARGS = --exec-prefix=/usr/bin
 #CONF_ARGS = --with-vim-name=vim7 --with-ex-name=ex7 --with-view-name=view7
 #CONF_ARGS = --with-global-runtime=/etc/vim
-#CONF_ARGS = --with-local-dir=/usr/share
+# CONF_ARGS = --with-local-dir=/usr/share
 #CONF_ARGS = --without-local-dir
 
 # Use this one if you distribute a modified version of Vim.
-#CONF_ARGS = --with-modified-by="John Doe"
+CONF_ARGS = --with-modified-by="Larrupingpig"
 
 # GUI - For creating Vim with GUI (gvim) (B)
 # Uncomment this line when you don't want to get the GUI version, although you
@@ -330,6 +330,7 @@ CClink = $(CC)
 # The automatic check will use another one that can be found.
 # Gnome is disabled by default, it may cause trouble.
 #CONF_OPT_GUI = --disable-gtk2-check
+CONF_OPT_GUI = --enable-gtk2-check
 #CONF_OPT_GUI = --enable-gnome2-check
 #CONF_OPT_GUI = --disable-motif-check
 #CONF_OPT_GUI = --disable-athena-check
@@ -349,9 +350,9 @@ CClink = $(CC)
 # --enable-gui=gtk or leave out --enable-gnome-check.
 #
 # If the selected GUI isn't found, the GUI is disabled automatically
-#CONF_OPT_GUI = --enable-gui=gtk2
+CONF_OPT_GUI = --enable-gui=gtk2
 #CONF_OPT_GUI = --enable-gui=gtk2 --disable-gtktest
-#CONF_OPT_GUI = --enable-gui=gnome2
+# CONF_OPT_GUI = --enable-gui=gnome2
 #CONF_OPT_GUI = --enable-gui=gnome2 --disable-gtktest
 #CONF_OPT_GUI = --enable-gui=motif
 #CONF_OPT_GUI = --enable-gui=motif --with-motif-lib="-static -lXm -shared"
@@ -383,7 +384,7 @@ CClink = $(CC)
 # First one is for static linking, second one for dynamic loading.
 # Use --with-luajit if you want to use LuaJIT instead of Lua.
 # Set PATH environment variable to find lua or luajit executable.
-#CONF_OPT_LUA = --enable-luainterp
+CONF_OPT_LUA = --enable-luainterp
 #CONF_OPT_LUA = --enable-luainterp=dynamic
 #CONF_OPT_LUA = --enable-luainterp --with-luajit
 #CONF_OPT_LUA = --enable-luainterp=dynamic --with-luajit
@@ -409,7 +410,7 @@ CClink = $(CC)
 # When you get an error for a missing "perl.exp" file, try creating an empty
 # one: "touch perl.exp".
 # This requires at least "small" features, "tiny" doesn't work.
-#CONF_OPT_PERL = --enable-perlinterp
+CONF_OPT_PERL = --enable-perlinterp
 #CONF_OPT_PERL = --enable-perlinterp=dynamic
 
 # PYTHON
@@ -424,7 +425,7 @@ CClink = $(CC)
 # dlopen(), dlsym(), dlclose(), i.e. pythonX.Y.so must be available
 # However, this may still cause problems, such as "import termios" failing.
 # Build two separate versions of Vim in that case.
-#CONF_OPT_PYTHON = --enable-pythoninterp
+CONF_OPT_PYTHON = --enable-pythoninterp
 #CONF_OPT_PYTHON = --enable-pythoninterp=dynamic
 #CONF_OPT_PYTHON3 = --enable-python3interp
 #CONF_OPT_PYTHON3 = --enable-python3interp=dynamic
@@ -433,7 +434,7 @@ CClink = $(CC)
 # Uncomment this when you want to include the Ruby interface.
 # First one for static linking, second one for loading when used.
 # Note: you need the development package (e.g., ruby1.9.1-dev on Ubuntu).
-#CONF_OPT_RUBY = --enable-rubyinterp
+CONF_OPT_RUBY = --enable-rubyinterp
 #CONF_OPT_RUBY = --enable-rubyinterp=dynamic
 #CONF_OPT_RUBY = --enable-rubyinterp --with-ruby-command=ruby1.9.1
 
@@ -444,15 +445,19 @@ CClink = $(CC)
 
 # CSCOPE
 # Uncomment this when you want to include the Cscope interface.
-#CONF_OPT_CSCOPE = --enable-cscope
+CONF_OPT_CSCOPE = --enable-cscope
 
 # WORKSHOP - Sun Visual Workshop interface.  Only works with Motif!
 #CONF_OPT_WORKSHOP = --enable-workshop
 
+# GDB - Include support for gdb
+CONF_OPT_GDB = --enable-gdb
+
 # NETBEANS - NetBeans interface. Only works with Motif, GTK, and gnome.
 # Motif version must have XPM libraries (see |workshop-xpm|).
 # Uncomment this when you do not want the netbeans interface.
 #CONF_OPT_NETBEANS = --disable-netbeans
+CONF_OPT_NETBEANS = --enable-netbeans
 
 # SNIFF - Include support for SNiFF+.
 #CONF_OPT_SNIFF = --enable-sniff
@@ -462,7 +467,7 @@ CClink = $(CC)
 # It's automatically enabled with normal features, GTK or IME support.
 # Note: Compile on a machine where setlocale() actually works, otherwise the
 # configure tests may fail.
-#CONF_OPT_MULTIBYTE = --enable-multibyte
+CONF_OPT_MULTIBYTE = --enable-multibyte
 
 # NLS - National Language Support
 # Uncomment this when you do not want to support translated messages, even
@@ -474,13 +479,13 @@ CClink = $(CC)
 # When omitted it's automatically enabled for the X-windows GUI.
 # HANGUL - Input Hangul (Korean) language using internal routines.
 # Uncomment one of these when you want to input a multibyte language.
-#CONF_OPT_INPUT = --enable-xim
+CONF_OPT_INPUT = --enable-xim
 #CONF_OPT_INPUT = --disable-xim
 #CONF_OPT_INPUT = --enable-hangulinput
 
 # FONTSET - X fontset support for output of languages with many characters.
 # Uncomment this when you want to output a multibyte language.
-#CONF_OPT_OUTPUT = --enable-fontset
+CONF_OPT_OUTPUT = --enable-fontset
 
 # ACL - Uncomment this when you do not want to include ACL support, even
 # though your system does support it.  E.g., when it's buggy.
@@ -503,10 +508,11 @@ CClink = $(CC)
 #CONF_OPT_FEAT = --with-features=small
 #CONF_OPT_FEAT = --with-features=normal
 #CONF_OPT_FEAT = --with-features=big
-#CONF_OPT_FEAT = --with-features=huge
+CONF_OPT_FEAT = --with-features=huge
 
 # COMPILED BY - For including a specific e-mail address for ":version".
 #CONF_OPT_COMPBY = "--with-compiledby=John Doe <JohnDoe@yahoo.com>"
+CONF_OPT_COMPBY = "--with-compiledby=Larrupingpig"
 
 # X WINDOWS DISABLE - For creating a plain Vim without any X11 related fancies
 # (otherwise Vim configure will try to include xterm titlebar access)
@@ -514,6 +520,7 @@ CClink = $(CC)
 # When both GUI and X11 have been disabled this may save about 15% of the
 # code and make Vim startup quicker.
 #CONF_OPT_X = --without-x
+CONF_OPT_X = --with-x
 
 # X WINDOWS DIRECTORY - specify X directories
 # If configure can't find you X stuff, or if you have multiple X11 derivatives
@@ -563,16 +570,17 @@ CClink = $(CC)
 #CFLAGS = -O -FOlimit,2000
 
 # Often used for GCC: mixed optimizing, lot of optimizing, debugging
-#CFLAGS = -g -O2 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes
+# CFLAGS = -g -O2 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes
 #CFLAGS = -g -O2 -fno-strength-reduce -Wall -Wmissing-prototypes
 #CFLAGS = -g -Wall -Wmissing-prototypes
-#CFLAGS = -O6 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes
+# CFLAGS = -O6 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes
+CFLAGS = -O6
 #CFLAGS = -g -DDEBUG -Wall -Wshadow -Wmissing-prototypes
 #CFLAGS = -g -O2 '-DSTARTUPTIME="vimstartup"' -fno-strength-reduce -Wall -Wmissing-prototypes
 
 # Use this with GCC to check for mistakes, unused arguments, etc.
-#CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1
-#CFLAGS = -g -O2 -Wall -Wextra -Wmissing-prototypes -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1 -DU_DEBUG
+# CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1
+# CFLAGS = -g -O2 -Wall -Wextra -Wmissing-prototypes -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1 -DU_DEBUG
 #PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
 #MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code -Wno-unused-parameter
 
@@ -847,7 +855,7 @@ LINT_OPTIONS = -beprxzF
 ###	 On AIX 4.2.1 (and other versions probably), libtermcap is reported
 ###	 not to display properly.
 ### after changing this, you need to do "make reconfig".
-#CONF_TERM_LIB = --with-tlib=curses
+CONF_TERM_LIB = --with-tlib=curses
 
 ### (E)  If you want to use termlib library instead of the automatically found
 ###	 one.  After changing this, you need to do "make reconfig".
@@ -934,11 +942,11 @@ TOOLS = xxd/xxd$(EXEEXT)
 # executable and a common directory for the other files.
 #
 # Uncomment the next line to install Vim in "/usr/bin"
-#BINDIR   = /usr/bin
+BINDIR   = /opt/bin
 # Uncomment the next line to install Vim manuals in "/usr/share/man/man1"
-#MANDIR   = /usr/share/man
+MANDIR   = /opt/share/man
 # Uncomment the next line to install Vim help files in "/usr/share/vim"
-#DATADIR  = /usr/share
+DATADIR  = /opt/share
 
 ### DESTDIR	root of the installation tree.  This is prepended to the other
 #		directories.  This directory must exist.
@@ -1483,6 +1491,7 @@ SRC =	$(BASIC_SRC) \
 	$(PYTHON_SRC) $(PYTHON3_SRC) \
 	$(TCL_SRC) \
 	$(RUBY_SRC) \
+	$(GDB_SRC) \
 	$(SNIFF_SRC) \
 	$(WORKSHOP_SRC) \
 	$(WSDEBUG_SRC)
@@ -1491,6 +1500,7 @@ TAGS_SRC = *.c *.cpp if_perl.xs
 
 EXTRA_SRC = hangulin.c if_lua.c if_mzsch.c auto/if_perl.c if_perlsfio.c \
 	    if_python.c if_python3.c if_tcl.c if_ruby.c if_sniff.c \
+	    gdb.c clewn/gdb_lvl2.c clewn/gdb_lvl3.c clewn/misc.c clewn/obstack.c \
 	    gui_beval.c workshop.c wsdebug.c integration.c netbeans.c
 
 # Unittest files
@@ -1507,6 +1517,7 @@ ALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(UNITTEST_SRC) $(EXTRA_SRC)
 # checks more, but may not work well for checking a GUI that wasn't configured.
 # The perl sources also don't work well with lint.
 LINT_SRC = $(BASIC_SRC) $(GUI_SRC) $(HANGULIN_SRC) $(PYTHON_SRC) $(PYTHON3_SRC) $(TCL_SRC) \
+	$(GDB_SRC) \
 	$(SNIFF_SRC) $(WORKSHOP_SRC) $(WSDEBUG_SRC) $(NETBEANS_SRC)
 #LINT_SRC = $(SRC)
 #LINT_SRC = $(ALL_SRC)
@@ -1571,6 +1582,7 @@ OBJ_COMMON = \
 	$(RUBY_OBJ) \
 	$(OS_EXTRA_OBJ) \
 	$(WORKSHOP_OBJ) \
+	$(GDB_OBJ) \
 	$(NETBEANS_OBJ) \
 	$(WSDEBUG_OBJ)
 
@@ -1636,6 +1648,7 @@ PRO_AUTO = \
 	window.pro \
 	gui_beval.pro \
 	workshop.pro \
+	gdb.pro \
 	netbeans.pro \
 	$(ALL_GUI_PRO) \
 	$(TCL_PRO)
@@ -1675,6 +1688,7 @@ config auto/config.mk: auto/configure config.mk.in config.h.in
 		$(CONF_OPT_TCL) $(CONF_OPT_RUBY) $(CONF_OPT_NLS) \
 		$(CONF_OPT_CSCOPE) $(CONF_OPT_MULTIBYTE) $(CONF_OPT_INPUT) \
 		$(CONF_OPT_OUTPUT) $(CONF_OPT_GPM) $(CONF_OPT_WORKSHOP) \
+		$(CONF_OPT_GDB) \
 		$(CONF_OPT_SNIFF) $(CONF_OPT_FEAT) $(CONF_TERM_LIB) \
 		$(CONF_OPT_COMPBY) $(CONF_OPT_ACL)  $(CONF_OPT_NETBEANS) \
 		$(CONF_ARGS) $(CONF_OPT_MZSCHEME) $(CONF_OPT_PLTHOME) \
@@ -2735,6 +2749,21 @@ objects/window.o: window.c
 objects/workshop.o: workshop.c
 	$(CCC) -o $@ workshop.c
 
+objects/gdb.o: gdb.c
+	$(CCC) -o $@ gdb.c
+
+objects/gdb_lvl2.o: clewn/gdb_lvl2.c
+	$(CCC) -o $@ clewn/gdb_lvl2.c
+
+objects/gdb_lvl3.o: clewn/gdb_lvl3.c
+	$(CCC) -o $@ clewn/gdb_lvl3.c
+
+objects/misc.o: clewn/misc.c
+	$(CCC) -o $@ clewn/misc.c
+
+objects/obstack.o: clewn/obstack.c
+	$(CCC) -o $@ clewn/obstack.c
+
 objects/wsdebug.o: wsdebug.c
 	$(CCC) -o $@ wsdebug.c
 
@@ -3151,6 +3180,13 @@ objects/workshop.o: workshop.c auto/config.h integration.h vim.h feature.h \
  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h \
  structs.h regexp.h gui.h gui_beval.h proto/gui_beval.pro ex_cmds.h \
  proto.h globals.h farsi.h arabic.h version.h workshop.h
+objects/gdb.o: gdb.c clewn/gdb.h clewn/misc.h auto/config.h vim.h feature.h
+objects/gdb_lvl2.o: clewn/misc.h clewn/gdb_lvl2.c clewn/gdb_lvl3.c \
+	gdb.c clewn/gdb.h auto/config.h vim.h feature.h
+objects/gdb_lvl3.o: clewn/misc.h clewn/gdb_lvl3.c gdb.c clewn/gdb.h\
+	auto/config.h vim.h feature.h
+objects/misc.o: clewn/misc.c clewn/misc.h
+objects/obstack.o: clewn/obstack.c clewn/obstack.h
 objects/wsdebug.o: wsdebug.c
 objects/integration.o: integration.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \
diff --git a/src/auto/configure b/src/auto/configure
index a9755a0..f0fda1b 100755
--- a/src/auto/configure
+++ b/src/auto/configure
@@ -604,6 +604,8 @@ HANGULIN_OBJ
 HANGULIN_SRC
 GUI_X_LIBS
 GUITYPE
+GDB_SRC
+GDB_OBJ
 GUI_LIB_LOC
 GUI_INC_LOC
 NARROW_PROTO
@@ -775,6 +777,7 @@ with_ruby_command
 enable_cscope
 enable_workshop
 enable_netbeans
+enable_gdb
 enable_sniff
 enable_multibyte
 enable_hangulinput
@@ -1437,6 +1440,7 @@ Optional Features:
   --enable-rubyinterp=OPTS     Include Ruby interpreter.  default=no OPTS=no/yes/dynamic
   --enable-cscope         Include cscope interface.
   --enable-workshop       Include Sun Visual Workshop support.
+  --enable-gdb		  Include GDB support.
   --disable-netbeans      Disable NetBeans integration support.
   --enable-sniff          Include Sniff interface.
   --enable-multibyte      Include multibyte editing support.
@@ -6820,6 +6824,18 @@ if test "$enable_cscope" = "yes"; then
 
 fi
 
+echo "$as_me:$LINENO: checking --enable-gdb argument" >&5
+echo $ECHO_N "checking --enable-gdb argument... $ECHO_C" >&6
+# Check whether --enable-gdb or --disable-gdb was given.
+if test "${enable_gdb+set}" = set; then
+  enableval="$enable_gdb"
+
+else
+  enable_gdb="no"
+fi;
+echo "$as_me:$LINENO: result: $enable_gdb" >&5
+echo "${ECHO_T}$enable_gdb" >&6
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-workshop argument" >&5
 $as_echo_n "checking --enable-workshop argument... " >&6; }
 # Check whether --enable-workshop was given.
@@ -9190,6 +9206,22 @@ fi
 
 
 
+if test "$enable_gdb" = "yes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define FEAT_GDB 1
+_ACEOF
+
+  if test "x$GUITYPE" = "xNONE"; then
+    GDB_SRC="gdb.c clewn/gdb_lvl2.c clewn/gdb_lvl3.c clewn/misc.c clewn/obstack.c pty.c"
+    GDB_OBJ="objects/gdb.o objects/gdb_lvl2.o objects/gdb_lvl3.o objects/misc.o objects/obstack.o objects/pty.o"
+  else
+    GDB_SRC="gdb.c clewn/gdb_lvl2.c clewn/gdb_lvl3.c clewn/misc.c clewn/obstack.c"
+    GDB_OBJ="objects/gdb.o objects/gdb_lvl2.o objects/gdb_lvl3.o objects/misc.o objects/obstack.o"
+  fi
+
+
+fi
+
 
 if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
   as_fn_error "cannot use workshop without Motif" "$LINENO" 5
diff --git a/src/buffer.c b/src/buffer.c
index 238af14..63a427c 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -672,6 +672,9 @@ free_buffer(buf)
 #ifdef FEAT_AUTOCMD
     aubuflocal_remove(buf);
 #endif
+#ifdef FEAT_GDB
+    gdb_buffer_free(gdb, buf);
+#endif
     vim_free(buf);
 }
 
@@ -5386,7 +5389,7 @@ insert_sign(buf, prev, next, id, lnum, typenr)
 	newsign->lnum = lnum;
 	newsign->typenr = typenr;
 	newsign->next = next;
-#ifdef FEAT_NETBEANS_INTG
+#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GDB)
 	newsign->prev = prev;
 	if (next != NULL)
 	    next->prev = newsign;
@@ -5432,12 +5435,12 @@ buf_addsign(buf, id, lnum, typenr)
 	    return;
 	}
 	else if (
-#ifndef FEAT_NETBEANS_INTG  /* keep signs sorted by lnum */
+#if !defined(FEAT_NETBEANS_INTG) && !defined(FEAT_GDB)  /* keep signs sorted by lnum */
 		   id < 0 &&
 #endif
 			     lnum < sign->lnum)
 	{
-#ifdef FEAT_NETBEANS_INTG /* insert new sign at head of list for this lnum */
+#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GDB) /* insert new sign at head of list for this lnum */
 	    /* XXX - GRP: Is this because of sign slide problem? Or is it
 	     * really needed? Or is it because we allow multiple signs per
 	     * line? If so, should I add that feature to FEAT_SIGNS?
@@ -5454,7 +5457,7 @@ buf_addsign(buf, id, lnum, typenr)
 	}
 	prev = sign;
     }
-#ifdef FEAT_NETBEANS_INTG /* insert new sign at head of list for this lnum */
+#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GDB) /* insert new sign at head of list for this lnum */
     /* XXX - GRP: See previous comment */
     while (prev != NULL && prev->lnum == lnum)
 	prev = prev->prev;
@@ -5530,7 +5533,7 @@ buf_delsign(buf, id)
 	if (sign->id == id)
 	{
 	    *lastp = next;
-#ifdef FEAT_NETBEANS_INTG
+#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GDB)
 	    if (next != NULL)
 		next->prev = sign->prev;
 #endif
@@ -5710,6 +5713,35 @@ sign_mark_adjust(line1, line2, amount, amount_after)
     long	amount_after;
 {
     signlist_T	*sign;		/* a sign in a b_signlist */
+# ifdef FEAT_GDB
+    int lnum;
+
+    for (sign = curbuf->b_signlist; sign != NULL; sign = sign->next)
+    {
+	lnum = sign->lnum;
+
+	if (sign->lnum >= line1 && sign->lnum <= line2)
+	{
+	    if (amount == MAXLNUM)
+		lnum = line1;
+	    else
+		lnum += amount;
+	}
+	else if (sign->lnum > line2)
+	    lnum += amount_after;
+
+	/* Keep sign->lnum unchanged, but mark as changed the sign line and
+	 * the new line position if we had moved the line
+	 * (otherwise their highlighting may be scrolled along) */
+	if (gdb_isrunning(gdb) && lnum != sign->lnum)
+	{
+	    changed_lines(sign->lnum, 0, sign->lnum + 1, 0);
+	    changed_lines(lnum, 0, lnum + 1, 0);
+	}
+	else
+	    sign->lnum = lnum;
+    }
+# else
 
     for (sign = curbuf->b_signlist; sign != NULL; sign = sign->next)
     {
@@ -5723,6 +5755,7 @@ sign_mark_adjust(line1, line2, amount, amount_after)
 	else if (sign->lnum > line2)
 	    sign->lnum += amount_after;
     }
+# endif
 }
 #endif /* FEAT_SIGNS */
 
diff --git a/src/clewn/gdb.h b/src/clewn/gdb.h
new file mode 100644
index 0000000..06fd03a
--- /dev/null
+++ b/src/clewn/gdb.h
@@ -0,0 +1,685 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * Copyright (C) 2004 Xavier de Gaye.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (see the file COPYING); if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: gdb.h 148 2007-07-21 16:35:40Z xavier $
+ */
+
+#ifndef GDB_H
+# define GDB_H
+
+#define obstack_chunk_alloc  malloc
+#define obstack_chunk_free   free
+#define obstack_strsave(o,s) (char_u *)obstack_copy0((o), (s), STRLEN((s)))
+#define obstack_strcat(o,s)			    \
+( (s) ? obstack_grow((o), (s), STRLEN((s))) : 0)
+#define obstack_strcat0(o,s)			    \
+( (s)						    \
+  ? obstack_grow0((o), (s), STRLEN((s)))	    \
+  : obstack_grow0((o), "", 0))
+
+#define GDB_LVL2_SUPPORT
+#define GDB_LVL3_SUPPORT
+/*#define GDB_MI_SUPPORT */
+
+/* |+gdb| modes */
+#define GDB_MODE_LVL2		1   /* CLI with annotations level 2 */
+#define GDB_MODE_LVL3		2   /* CLI with annotations level 3 and GDB/MI */
+#define GDB_MODE_MI		3   /* GDB/MI */
+
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+/*
+ * GDB does not send ANO_BP_INVALID annotation when hitting a breakpoint
+ * that has been 'enable once'.
+ * Undefine BP_INVALID_ANO_MISSING after GDB fixes this
+ */
+# define BP_INVALID_ANO_MISSING
+#endif
+
+#define KEY_INTERUPT	Ctrl_Z	/* interrupt */
+#define MAX_BUFFSIZE	1024
+
+/* The breakpoint info record structure */
+typedef struct bpinfo_struct bpinfo_T;
+
+struct bpinfo_struct
+{
+    int id;		/* breakpoint number */
+    int typenr;		/* sign type number, for Clewn: sequence sign type number in this buffer */
+#ifdef BP_INVALID_ANO_MISSING
+    int disposition;	/* TRUE when keep, FALSE when disabled */
+#endif
+    int enabled;	/* TRUE when enabled */
+    int cont;		/* TRUE when 'commands' includes continue */
+#ifdef FEAT_GDB
+    buf_T *buf;		/* breakpoint buffer */
+#else
+    int buf;		/* Clewn buffer number */
+    int typenr_en;	/* enabled breakpoint sequence number */
+    int typenr_dis;	/* disabled breakpoint sequence number */
+#endif
+    linenr_T lnum;	/* breakpoint line number */
+    bpinfo_T *next;
+};
+
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+/* Annotation types */
+# define ANO_NONE		0
+# define ANO_ANY		1	/* some unrecognized annotation */
+
+/* level 2 and level 3 annotations */
+# define ANO_PREPROMPT		101
+# define ANO_PROMPT		102
+# define ANO_POSTPROMPT		103
+# define ANO_PRECMDS		104
+# define ANO_CMDS		105
+# define ANO_PREOVERLOAD	106
+# define ANO_OVERLOAD		107
+# define ANO_PREQUERY		108
+# define ANO_QUERY		109
+# define ANO_PREPMT_FORMORE	110
+# define ANO_PMT_FORMORE	111
+# define ANO_POSTPMT_FORMORE	112
+# define ANO_QUIT		113
+# define ANO_ERROR_BEG		114
+# define ANO_FRAME_INVALID	115
+# define ANO_BP_INVALID		116
+# define ANO_STARTING		117
+# define ANO_STOPPED		118
+# define ANO_EXITED		119
+# define ANO_SIGNALLED		120
+# define ANO_BREAKPOINT		121
+# define ANO_SOURCE		122
+
+# define KEY_KILL	Ctrl_U	/* readline 'unix-line-discard' */
+# define LPP_LINES	500	/* large output interruption interval */
+
+/* Command completion states */
+# define CS_START	0
+# define CS_PENDING	1
+# define CS_CHOICE	2
+# define CS_DONE	3
+# define CS_QUERY	4
+
+/* The gdb CLI cmd */
+typedef struct
+{
+    int state;		/* cmd completion state */
+    int cnt;		/* lines output by gdb since last cmd */
+    char_u *gdb;	/* partial cmd sent to gdb */
+    char_u *readline;	/* gdb readline content */
+    char_u *echoed;	/* echoed cmd */
+} cli_cmd_T;
+
+/* breakpoint states */
+# define BPS_INVALID	0x0100	/* got "breakpoints-invalid" annotation */
+# define BPS_BP_HIT	0x0200	/* got "breakpoint" annotation */
+# define BPS_FR_INVALID 0x0400	/* got "frames-invalid" annotation */
+# define BPS_BP_SET	0x0800	/* a break type GDB cmd is being processed */
+# define BPS_RECORD	0x1000	/* parsing a record in the breakpoint table */
+# define BPS_START	0x2000	/* start of a record */
+#endif /* defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT) */
+
+#ifdef GDB_LVL2_SUPPORT
+/* level 2 annotations */
+# define ANO_FRAME_BEGIN	201
+# define ANO_FRAME_END		202
+# define ANO_BP_HEADER		203
+# define ANO_BP_TABLE		204
+# define ANO_BP_RECORD		205
+# define ANO_BP_FIELD0		206	/* Number */
+# define ANO_BP_FIELD1		207	/* Type */
+# define ANO_BP_FIELD2		208	/* Disposition */
+# define ANO_BP_FIELD3		209	/* Enable */
+# define ANO_BP_FIELD4		210	/* Address */
+# define ANO_BP_FIELD5		211	/* What */
+# define ANO_BP_FIELD6		212	/* Frame */
+# define ANO_BP_FIELD7		213	/* Condition */
+# define ANO_BP_FIELD8		214	/* Ignore-count */
+# define ANO_BP_FIELD9		215	/* Commands */
+# define ANO_BP_END		216
+# define ANO_DISP_BEG		217
+# define ANO_DISP_NUMEND	218
+# define ANO_DISP_FMT		219
+# define ANO_DISP_EXP		220
+# define ANO_DISP_EXPEND	221
+# define ANO_DISP_VALUE		222	/* not output by GDB */
+# define ANO_DISP_END		223
+# define ANO_FIELD_BEG		224
+# define ANO_FIELD_NAMEND	225
+# define ANO_FIELD_VALUE	226
+# define ANO_FIELD_END		227
+# define ANO_ARRAY_BEG		228
+# define ANO_ARRAY_ELT		229
+# define ANO_ARRAY_ELTREP	230
+# define ANO_ARRAY_ELTEND	231
+# define ANO_ARRAY_END		232
+
+/* breakpoints */
+# define IS_RECORD(s)		((s) & BPS_RECORD)
+# define RECORD_INDEX(s)	((s) & 0xff)
+# define SET_RECORD_IDX(s, i)	(((s) & ~0xff) | (i))
+
+/* breakpoint annotation fields indexes */
+# define BI_NUM		0
+# define BI_TYPE	1
+# define BI_DISPO	2
+# define BI_ENABLE	3
+# define BI_ADDRESS	4
+# define BI_WHAT	5
+# define BI_FRAME	6
+# define BI_COND	7
+# define BI_COUNT	8
+# define BI_CMMDS	9	/* commands */
+# define BI_FIELDS	10	/* number of bp info annotation fields */
+
+/* The display object structure */
+typedef struct gdbdisp_struct gdbdisp_T;
+
+struct gdbdisp_struct
+{
+    int num;		/* display number */
+    int state;		/* highlighted or/and changed */
+    gdbdisp_T * next;
+};
+
+/* display states */
+# define DSP_INIT	0
+# define DSP_STOPPED	1
+
+/* The display list structure */
+typedef struct
+{
+    int state;
+    gdbdisp_T * list;
+} displist_T;
+
+/* The display entry structure used to store a GDB display output */
+typedef struct
+{
+    char_u * num;	/* display item number */
+    char_u * expression;/* display item format and expression */
+    char_u * value;	/* display item value */
+} doutput_T;
+
+/* The lvl2 mode structure: lvl2 specific data */
+typedef struct
+{
+    /* breakpoints */
+    char_u *info[BI_FIELDS]; /* breakpoint info record contents */
+
+    /* variables (display) window */
+    displist_T varlist;	/* list of display items */
+    doutput_T dentry;	/* current GDB display output entry */
+    int doing_value;	/* when TRUE: currently handling a display value */
+    char_u *dispinfostr;/* current line output after "info display" */
+    char_u *dispinfo;	/* all item numbers result of a "info display" */
+} lvl2_T;
+#endif /* GDB_LVL2_SUPPORT */
+
+#ifdef GDB_LVL3_SUPPORT
+/* The variable object structure */
+typedef struct varobj_struct varobj_T;
+
+/* varobj states */
+#define VS_INIT	    0x01    /* object creation */
+#define VS_ERROR    0x02    /* a command on this object produced an error */
+
+struct varobj_struct
+{
+    int state;
+    char_u *name;	/* variable name ("NNN" in "varNNN") */
+    int children;	/* TRUE when has children */
+    char_u *format;	/* print format is "/[tdxo]"*/
+    char_u *expression;	/* variable expression */
+    varobj_T * next;
+};
+
+/* GDB/MI var commands */
+# define VCMD_INIT	0
+# define VCMD_CREATE	1
+# define VCMD_DELETE	2
+# define VCMD_CHILDREN	3
+# define VCMD_UPDATE	4
+# define VCMD_PRINT	5
+# define VCMD_EVALUATE	6
+# define VCMD_FORMAT	7
+
+/* The lvl3 mode structure: lvl3 specific data */
+typedef struct
+{
+    char_u *result;	/* result of a GDB/MI command */
+
+    int get_source_list;
+    char_u *source_cur;	/* result of -file-list-exec-source-file */
+    char_u *source_list;/* result of -file-list-exec-source-files */
+
+    /* variables window */
+    varobj_T *varlist;	/* list of variable objects */
+    varobj_T *varitem;  /* current object in varlist */
+    int varcmd;		/* GDB/MI var cmd being processed */
+    int varnext_cmd;	/* GDB/MI var next cmd to process */
+} lvl3_T;
+#endif /* GDB_LVL3_SUPPORT */
+
+/* Command types */
+#define CMD_ANY		0
+#ifdef FEAT_GDB
+# define CMD_DIR	1
+#endif
+#define CMD_DETACH	2
+#define CMD_SHELL	3
+#define CMD_STEPI	4	/* instruction stepping cmds */
+#define CMD_EXECF	5	/* invalidating asm buffers cmds */
+#define CMD_BREAK	6
+#define CMD_DISPLAY	7
+#define CMD_CREATEVAR	8
+#define CMD_UP		9
+#define CMD_DOWN	10
+#define CMD_FRAME	11
+#define CMD_DISABLE	12
+#define CMD_DELETE	13
+#define CMD_UP_SILENT	14
+#define CMD_DOWN_SILENT	15
+#define CMD_SLECT_FRAME 16
+#define CMD_SYMF	17
+#define CMD_RESTART	18
+#define CMD_QUIT	19
+
+#define ASM_MAX_BUFF	64	    /* asm buffers pool size */
+#define ASM_BUF_NAME	"gdb-asm-"  /* asm buffer name prefix */
+#define ASM_OLD	(char_u)(~0U)	    /* asm buffer max age */
+
+/* The assembly buffer pool */
+typedef struct
+{
+#ifdef FEAT_GDB
+    int max;			/* buffers in use */
+    int idx;			/* current buffer */
+    buf_T * buf[ASM_MAX_BUFF];	/* asm buffers */
+    char_u age[ASM_MAX_BUFF];	/* buffer's age */
+    int last;			/* used for generating unique asm names */
+#else
+    int buf;			/* number of the asm buffer being disassembled */
+    FILE *fd;			/* stream descriptor of asm file being written to */
+    char_u *name;		/* file name of the function being disassembled */
+    long line_offset;		/* offset of start of last line in file */
+#endif
+    linenr_T lnum;		/* highlited line number */
+    int hilite;			/* TRUE when $pc in asm is highlited */
+} asm_T;
+
+/* The gdb structure */
+typedef struct gdb_struct gdb_T;
+
+/* Out of band states */
+#define OS_CMD    0x01		/* a cmd is being processed */
+#define OS_INTR   0x02		/* interrupt sent to gdb */
+#define OS_QUIT   0x04		/* 'quit' annotation received */
+
+/* Out of Band */
+#define OOB_CMD		0
+#define OOB_COLLECT	1
+#define OOB_COMPLETE	2
+#define IS_OOBACTIVE(t) (((t)->oob.idx) >= 0)
+
+/* The out of band process */
+typedef struct
+{
+    int state;			/* oob state */
+    int idx;			/* current function index */
+    int cnt;			/* asm output lines count */
+} oob_T;
+
+/*
+ * oobfunc_T function:
+ *
+ * When an oobfunc_T[] array is processed by gdb_oob_send() and
+ * gdb_oob_receive(), each oob function in the array is called with
+ * successive state values of:
+ *
+ * OOB_CMD:	called at each 'prompt'; should return the GDB cmd
+ *		to send to GDB or NULL when no command must be sent;
+ *		in this case the next oob function in the oobfunc_T[]
+ *		array is processed next with OOB_CMD
+ *
+ * OOB_COLLECT:	oob may process chunk, a (possibly partial) line from GDB
+ *		result of GDB command; may be invoked more than once, or not at all
+ *
+ * OOB_COMPLETE:indicates end of GDB output; oob may do any final processing;
+ *		if oob returns a non NULL value, the same oob function is
+ *		called once again with OOB_CMD and the same cycle starts again;
+ *		if oob returns a NULL value, the next oob function in the
+ *		oobfunc_T[] array is processed with OOB_CMD
+ *
+ * Return:	NULL, except when state is OOB_CMD or OOB_COMPLETE
+ */
+
+typedef struct {
+    char * (*oob)(gdb_T *, int state, char_u *chunk, struct obstack *);
+} oobfunc_T;
+
+/* gdb states */
+#define GDB_STATE(i,s) (((i) != NULL) ? ((((gdb_T *)(i))->state) & (s)):FALSE)
+#define GS_INIT	    0		/* initial state */
+#define GS_CLOSING  0x001	/* gdb process closing */
+#define GS_UP	    0x002	/* gdb up and running */
+#define GS_STARTED  0x004	/* gdb just started */
+#define GS_ALLOWED  0x008	/* select on pty is allowed */
+#define GS_EVENT    0x010	/* got SIGCHLD or gdb output some data */
+#define GS_SIGCHLD  0x020	/* got SIGCHLD from gdb */
+#define GS_STOPPED  0x040	/* debuggee is stopped */
+#define GS_ANO	    0x080	/* parsing an annotation table or list */
+#define GS_QUITTING 0x100	/* quitting clewn */
+
+/* parser states */
+#define PS_ANY		0
+#define PS_PREPROMPT	1	/* before the prompt, after any output from GDB */
+#define PS_PROMPT	2	/* after prompt, but before user input */
+
+/* project file sourced states */
+#define PROJ_INIT	0
+#define PROJ_SOURCEIT	1
+#define PROJ_DONE	2
+
+/* The gdb structure */
+struct gdb_struct
+{
+    /* process */
+    int instance;	/* gdb instance number */
+    int fd;		/* pty file descriptor */
+    pid_t pid;		/* process id */
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+    int height;		/* pseudo tty height, non zero when ioctl set */
+    int intr_sent;	/* hack: an interrupt has been sent by the user */
+#endif
+    int state;		/* gdb state */
+    char_u *status;	/* gdb status */
+    int recurse;	/* disable GS_ALLOWED when calling safe_vgetc */
+
+    /* cmds */
+    int cmd_type;	/* cmd type */
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+    cli_cmd_T cli_cmd;	/* current CLI cmd (common to lvl2 and lvl3) */
+#endif
+    char_u *firstcmd;	/* first cmd in new GDB session */
+    int parser;		/* parser states */
+    int syntax;		/* when TRUE, enable syntax highlighting */
+    char_u *line;	/* last incomplete line */
+    char_u *winput_cmd; /* cmd inserted in input-line window */
+    char_u *directories;/* gdb search path for source files */
+#ifndef FEAT_GDB
+    char_u *prompt;	/* the current GDB prompt */
+    char * version;	/* clewn version */
+    char_u * pwd;	/* current working directory */
+    char_u * args;	/* debugge command line arguments */
+#endif
+    char_u *sfile;	/* symbol file name */
+
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+    /* annotations */
+    int note;		/* annotation type */
+    int annoted;	/* TRUE when parsing an annotation */
+    int newline;	/* pending NL, possibly an annotation first char */
+    int valid_note;	/* last non prompt-for-more annotation type */
+    int prev_note;	/* previous annotation type */
+    char_u *annotation;	/* last incomplete annotation */
+#endif
+
+    /* disassembly */
+    asm_T pool;		/* asm buffers pool */
+    char_u *pc;		/* program counter where debuggee is stopped */
+    char_u *frame_pc;	/* current frame program counter */
+    char_u *oob_result;	/* result of oob gdb_get_frame */
+    char_u *asm_add;	/* address whose function must be disassembled */
+    char_u *asm_func;	/* asm function name */
+
+    /* breakpoints */
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+    int bp_state;	/* breakpoint annotation state (and index) */
+    bpinfo_T *tmplist;	/* tmp new bp list when reading "info beakpoints" */
+#endif
+    bpinfo_T *record;	/* current record  */
+    int bufIsChanged;	/* TRUE when curbuf is changed after edit failed */
+    int cont;		/* TRUE when pgm is continuing at this bp */
+    bpinfo_T *bpinfo;	/* breakpoints info table */
+    int frame_curlvl;	/* current frame level */
+    linenr_T frame_lnum;/* current frame line number */
+    char_u * frame_fname;/* current frame file name */
+
+#ifdef FEAT_GDB
+    buf_T *buf;		/* gdb buffer */
+    buf_T *fr_buf;	/* frame sign buffer */
+    buf_T *var_buf;	/* variables window buffer */
+#else /* Clewn implementation */
+    linenr_T lastline;	/* lastline being disassembled */
+    int fr_buf;		/* frame sign buffer number */
+    linenr_T lnum;	/* frame sign line number */
+    int var_buf;	/* variables buffer number */
+    char_u *var_name;	/* variables file name */
+    char_u *balloon_txt;/* text over which is pointed the mouse */
+    char * project_file;/* project file name */
+    int project_state;	/* project file sourced state */
+#endif
+    oob_T oob;		/* out of band data */
+
+    /* |+gdb| modes */
+    int mode;		/* current |+gdb| mode */
+#ifdef GDB_LVL2_SUPPORT
+    lvl2_T lvl2;	/* annotations level 2 */
+#endif
+#ifdef GDB_LVL3_SUPPORT
+    lvl3_T lvl3;	/* annotations level 3 and GDB/MI */
+#endif
+
+    /* pointers to mode specific functions */
+    oobfunc_T *oobfunc;		    /* the current oob functions array */
+    oobfunc_T *std_oobfunc;	    /* the standard oob functions array */
+    int (*parse_output)(gdb_T *);   /* parser function */
+    void (*gdb_docmd)(gdb_T *, char_u *);/* GDB command input function */
+    void (*var_delete)(gdb_T *);    /* delete all variables function */
+    void (*clear_gdb_T)(gdb_T *);   /* clear mode specific stuff */
+};
+
+/* Regexp patterns */
+#define PAT_DIR		1
+#define PAT_CHG_ANNO	2
+#define PAT_ADD		3
+#define PAT_PID		4
+
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+# define PAT_SOURCE	101
+# define PAT_QUERY	102
+# define PAT_YES	103
+# define PAT_SFILE	104
+# define PAT_BP_CONT	105
+# define PAT_ASM_FUNC	106
+# define PAT_ASM_FUNC_P	107
+# define PAT_FRAME	108
+# define PAT_HEIGHT	109
+#endif
+
+#ifdef GDB_LVL2_SUPPORT
+# define PAT_BP_ASM	201
+# define PAT_BP_SOURCE	202
+# define PAT_DISPLAY	203
+# define PAT_DISPINFO	204
+# define PAT_CREATEVAR	205
+#endif
+
+# ifdef GDB_LVL3_SUPPORT
+# define PAT_CRVAR_FMT	301
+# define PAT_INFO_FRAME	302
+#endif
+
+/* User interface */
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+void gdb_docmd_cli __ARGS((gdb_T *, char_u *));
+void gdb_send_cmd __ARGS((gdb_T *, char_u *));
+#endif
+
+/* Vim low level hook */
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+int gdb_parse_output_cli __ARGS((gdb_T *));
+#endif
+
+/* Gdb process mgmt */
+void gdb_close __ARGS((gdb_T *));
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+int gdb_setup_cli __ARGS((gdb_T *));
+#endif
+
+/* Gdb mode initialization */
+#ifdef GDB_LVL2_SUPPORT
+void gdb_lvl2_init __ARGS((gdb_T *));
+#endif
+#ifdef GDB_LVL3_SUPPORT
+void gdb_lvl3_init __ARGS((gdb_T *));
+#endif
+
+/* Sign highliting */
+#define FRAME_SIGN 1
+#ifdef FEAT_GDB
+# define PHANTOM_SIGN 2
+# define BP_SIGN_ID(n) ((n)+2)	/* reserved sign ids: 1 frame, 2 phantom */
+void gdb_fr_lite __ARGS((gdb_T *, buf_T *, linenr_T, struct obstack *));
+int gdb_define_sign __ARGS((int, int));
+void gdb_undefine_sign __ARGS((int));
+buf_T * gdb_unlite __ARGS((int));
+#else
+# define BP_SIGN_ID(n) ((n)+1)	/* reserved sign id: 1 frame */
+void gdb_fr_lite __ARGS((gdb_T *, int, linenr_T, struct obstack *));
+int gdb_define_bpsign __ARGS((bpinfo_T *, struct obstack *));
+void gdb_unlite __ARGS((int));
+#endif
+int gdb_as_frset __ARGS((gdb_T *, struct obstack *));
+int gdb_fr_set __ARGS((gdb_T *, char_u *, linenr_T *, struct obstack *));
+void gdb_fr_unlite __ARGS((gdb_T *));
+
+/* Window and buffer mgmt */
+#ifdef FEAT_GDB
+win_T *gdb_btowin __ARGS((buf_T *));
+void gdb_as_setname __ARGS((char_u *));
+void gdb_clear_asmbuf __ARGS((gdb_T *, buf_T *));
+win_T * gdb_edit_file __ARGS((gdb_T *, buf_T *, char_u *, linenr_T, struct obstack *));
+void gdb_set_cursor __ARGS((win_T *, linenr_T));
+void gdb_popup_console __ARGS((gdb_T *));
+void gdb_redraw __ARGS((buf_T *));
+#else
+int gdb_edit_file __ARGS((int, char_u *, linenr_T, int, struct obstack *));
+#endif
+void gdb_msg_busy __ARGS((char_u *));
+void gdb_showBalloon __ARGS((char_u *, struct obstack *));
+void gdb_status __ARGS((gdb_T *, char_u *, struct obstack *));
+void gdb_write_buf __ARGS((gdb_T *, char_u *, int));
+
+/* Out Of Band */
+void gdb_oob_send __ARGS((gdb_T *, struct obstack *));
+void gdb_oob_receive __ARGS((gdb_T *, char_u *, struct obstack *));
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+char * gdb_print_value __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_get_pc __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_get_frame __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_info_frame __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_stack_frame __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_get_sfile __ARGS((gdb_T *, int, char_u *, struct obstack *));
+#ifndef FEAT_GDB
+char * gdb_source_project __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_get_pwd __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_get_args __ARGS((gdb_T *, int, char_u *, struct obstack *));
+#endif
+char * gdb_source_cur __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_source_list __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_get_sourcedir __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_get_asmfunc __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_get_asmfunc_hack __ARGS((gdb_T *, int, char_u *, struct obstack *));
+char * gdb_get_asm __ARGS((gdb_T *, int, char_u *, struct obstack *));
+void gdb_process_record __ARGS((gdb_T *, char_u *, char_u *, char_u *, char_u *, struct obstack *));
+#endif
+
+/* Variables window management */
+#ifdef GDB_LVL2_SUPPORT
+void gdb_process_display __ARGS((gdb_T *, char_u *, struct obstack *));
+#endif
+
+/* Utilities */
+#ifndef MIN
+#define MIN(a,b) (((a)<(b))?(a):(b))
+#endif
+#ifndef ABS
+#define ABS(x) (((x)<0)?(-(x)):(x))
+#endif
+#define STRCHR(s,c) (char_u *)strchr((char *)(s),(int)(c))
+#define STRSTR(h,n) (char_u *)strstr((char *)(h),(char *)(n))
+#define FREE(p) {xfree((p)); (p) = NULL;}
+#define IS_ANNOTATION(l) (STRSTR((l),"\032\032") == (l))
+#define BUFLASTL(b) (!(((b)->b_ml.ml_flags) & ML_EMPTY)?((b)->b_ml.ml_line_count):0)
+int gdb_read __ARGS((gdb_T *, char_u *, int, int));
+void gdb_free_bplist __ARGS((bpinfo_T **));
+void gdb_cmd_type __ARGS((gdb_T *, char_u *));
+void gdb_cat __ARGS((char_u **, char_u *));
+char_u * gdb_regexec __ARGS((char_u *, int, int, struct obstack *));
+char_u * gdb_itoa __ARGS((int));
+
+/* Gdb memory leaks mtrace */
+#if defined(GDB_MTRACE) && defined(HAVE_MTRACE)
+# include <malloc.h>
+# include <mcheck.h>
+/* storage for mtrace hooks */
+extern __ptr_t (*s_malloc) (size_t, const void *);
+extern void (*s_free) (void *, const void *);
+extern __ptr_t (*s_realloc) (void *, size_t, const void *);
+
+# define mv_hooks() do {	\
+    s_malloc = __malloc_hook;	\
+    s_free = __free_hook;	\
+    s_realloc = __realloc_hook;	\
+    __malloc_hook = NULL;	\
+    __free_hook = NULL;		\
+    __realloc_hook = NULL;	\
+    } while (0)
+
+# define get_hooks() do {	\
+    __malloc_hook = s_malloc;	\
+    __free_hook = s_free;	\
+    __realloc_hook = s_realloc;	\
+    } while (0)
+
+/* we do call sometimes vim_free directly and allocation is not mtraced:
+ * when the called Vim function does not free all its allocated memory
+ * after it returns */
+# define xmalloc(s) ({char_u *mret; get_hooks(); mret=xmalloc((s)); mv_hooks(); mret;})
+# define xcalloc(s) ({char_u *mret; get_hooks(); mret=xcalloc((s)); mv_hooks(); mret;})
+# define xrealloc(m,s) ({char_u *mret; get_hooks(); mret=xrealloc((m),(s)); mv_hooks(); mret;})
+
+# define xfree(x) do {		\
+    get_hooks();		\
+    xfree((x));			\
+    mv_hooks();			\
+    } while (0)
+
+# define clewn_strsave(s) ({char_u *mret; get_hooks(); mret=clewn_strsave((s)); mv_hooks(); mret;})
+# define clewn_strnsave(s,l) ({char_u *mret; get_hooks(); mret=clewn_strnsave((s),(l)); mv_hooks(); mret;})
+
+# define vim_strsave_escaped(s,e) ({char_u *mret; get_hooks(); mret=vim_strsave_escaped((s),(e)); mv_hooks(); mret;})
+# define vim_regcomp(s,m) ({regprog_T *mret; get_hooks(); mret=vim_regcomp((s),(m)); mv_hooks(); mret;})
+# define FullName_save(n,f) ({char_u *mret; get_hooks(); mret=FullName_save((n),(f)); mv_hooks(); mret;})
+# define get_option_value(n,u,s,o) ({int r; get_hooks(); r=get_option_value((n),(u),(s),(o)); mv_hooks(); r;})
+#endif	/* GDB_MTRACE */
+#endif	/* GDB_H */
+
diff --git a/src/clewn/gdb_lvl2.c b/src/clewn/gdb_lvl2.c
new file mode 100644
index 0000000..ba13371
--- /dev/null
+++ b/src/clewn/gdb_lvl2.c
@@ -0,0 +1,1085 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * Copyright (C) 2004 Xavier de Gaye.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (see the file COPYING); if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: gdb_lvl2.c 222 2008-10-13 14:38:07Z xavier $
+ */
+
+# ifdef HAVE_CLEWN
+#  include <config.h>
+#  include "obstack.h"
+#  include "clewn.h"
+# else
+#  include "vim.h"
+#  include "clewn/obstack.h"
+# endif
+
+#if defined(FEAT_GDB) || defined(HAVE_CLEWN)
+
+# include "gdb.h"
+# include "misc.h"
+
+# ifdef GDB_LVL2_SUPPORT
+
+/* display item states */
+#  define DISP_CHANGED 0x01	/* item expression value has changed */
+#  define DISP_HILITED 0x02	/* item expression value is hilited */
+
+/* Gdb process mgmt */
+static void clear_gdb_T __ARGS((gdb_T *));
+
+/* Out Of Band */
+static char *get_lastbp __ARGS((gdb_T *, int, char_u *, struct obstack *));
+static char *get_bp __ARGS((gdb_T *, int, char_u *, struct obstack *));
+static void process_record __ARGS((gdb_T *, struct obstack *));
+static void set_bpfield __ARGS((gdb_T *, char_u *));
+static char *get_display __ARGS((gdb_T *, int, char_u *, struct obstack *));
+static char *undisplay __ARGS((gdb_T *, int, char_u *, struct obstack *));
+
+/* Variables window management */
+static void var_delete __ARGS((gdb_T *));
+
+/* The function ordering in this array is important as some of
+ * these functions must be invoked in the right order */
+static oobfunc_T oobfunc[] = {
+    {gdb_get_pc},
+    {gdb_get_frame},
+    {gdb_get_sfile},
+    {gdb_get_sourcedir},
+    {get_lastbp},	    /* after gdb_get_frame */
+    {gdb_get_asmfunc},	    /* after get_lastbp */
+    {gdb_get_asmfunc_hack}, /* after gdb_get_asmfunc */
+    {gdb_get_asm},	    /* after gdb_get_asmfunc */
+    {get_bp},		    /* after gdb_get_asm and get_lastbp */
+    {get_display},
+    {undisplay},
+    {NULL}
+};
+
+/* Initialize the gdb_T structure lvl2 component that lvl2 is responsible for */
+    static void
+clear_gdb_T(this)
+    gdb_T *this;
+{
+    gdbdisp_T *item, *next;
+    int i;
+
+    if (this != NULL)
+    {
+	for (item = this->lvl2.varlist.list; item != NULL; item = next)
+	{
+	    next = item->next;
+	    xfree(item);
+	}
+	this->lvl2.varlist.list = NULL;
+
+	for (i = 0; i < BI_FIELDS; i++)
+	    FREE(this->lvl2.info[i]);
+
+	this->lvl2.doing_value = FALSE;
+	FREE(this->lvl2.dentry.num);
+	FREE(this->lvl2.dentry.expression);
+	FREE(this->lvl2.dentry.value);
+	FREE(this->lvl2.dispinfostr);
+	FREE(this->lvl2.dispinfo);
+    }
+}
+
+/* Initialize lvl2 function pointers */
+    void
+gdb_lvl2_init(this)
+    gdb_T *this;
+{
+    this->mode = GDB_MODE_LVL2;
+    this->oobfunc = oobfunc;
+    this->std_oobfunc = oobfunc;
+    this->parse_output = gdb_parse_output_cli;
+    this->gdb_docmd = gdb_docmd_cli;
+    this->var_delete = var_delete;
+    this->clear_gdb_T = clear_gdb_T;
+}
+
+/*
+ * When a breakpoint is being set and asm option is on, get the
+ * instruction address of the last breakpoint, the one being set.
+ * This address is used in get_asm() to disassemble the function
+ * containing this address.
+ */
+    static char *
+get_lastbp(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    int found = FALSE;
+    bpinfo_T *p;
+    int bp_num;
+    int i;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    switch (state)
+    {
+	case OOB_CMD:
+	    /* GDB sends sometimes ANO_BP_INVALID when stepping, even
+	     * though no breakpoints have been changed.
+	     * Avoid checking for last bp in this case, because this
+	     * may cause hiliting a bp in a new buffer when what is
+	     * expected is a new frame */
+	    if (this->bp_state & BPS_FR_INVALID)
+		return NULL;
+
+	    /* A breakpoint is being set in assembly */
+	    if (p_asm != 0 && (this->bp_state & BPS_INVALID)
+		    && (this->bp_state & BPS_BP_SET))
+	    {
+		this->bp_state &= ~BPS_BP_SET;
+
+		/* fetch GDB bp table info */
+		return "server info breakpoint\n";
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    /* initialize fields at start of bp record */
+	    if (this->bp_state & BPS_START)
+	    {
+		this->bp_state &= ~BPS_START;
+
+		for (i = 0; i < BI_FIELDS; i++)
+		    FREE(this->lvl2.info[i]);
+	    }
+
+	    /* get info[] field from annotation content */
+	    set_bpfield(this, line);
+	    break;
+
+	case OOB_COMPLETE:
+	    /* the last bp in the table */
+	    if (this->lvl2.info[BI_NUM] != NULL
+		    && (bp_num = atoi((char *)this->lvl2.info[BI_NUM])) > 0)
+	    {
+		/* look it up in bpinfo list */
+		for (p = this->bpinfo; p != NULL; p = p->next)
+		{
+		    if (bp_num == p->id)
+		    {
+			found = TRUE;
+			break;
+		    }
+		}
+
+		/* not found: set asm_add so that get_asm will
+		 * do the disassembling */
+		if (! found)
+		{
+		    xfree(this->asm_add);
+		    this->asm_add =
+			gdb_regexec(this->lvl2.info[BI_ADDRESS], PAT_ADD, 1, NULL);
+		}
+	    }
+
+	    for (i = 0; i < BI_FIELDS; i++)
+		FREE(this->lvl2.info[i]);
+	    break;
+    }
+    return NULL;
+}
+
+/*
+ * Get the breakpoints info record table.
+ */
+    static char *
+get_bp(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    bpinfo_T *p;
+    int i;
+
+    switch (state)
+    {
+	case OOB_CMD:
+	    /* When an ANO_BP_INVALID annotation has been received,
+	     * or when we are stepping (more accurately: got a new frame):
+	     * fetch bp table */
+	    if (this->bp_state & BPS_INVALID || this->bp_state & BPS_FR_INVALID)
+	    {
+		this->bufIsChanged = FALSE;
+
+		/* handle case where an error occured last time */
+		FREE(this->record);
+		gdb_free_bplist(&(this->tmplist));
+
+		return "server info breakpoint\n";
+	    }
+
+	    this->bp_state &= ~BPS_INVALID;
+	    this->bp_state &= ~BPS_FR_INVALID;
+	    this->bp_state &= ~BPS_BP_HIT;
+	    break;
+
+	case OOB_COLLECT:
+	    if (this->bp_state & BPS_START)
+	    {
+		this->bp_state &= ~BPS_START;
+
+		/* process last record */
+		process_record(this, obs);
+		for (i = 0; i < BI_FIELDS; i++)
+		    FREE(this->lvl2.info[i]);
+
+		/* allocate a new record or reuse an existing one
+		 * and initialize its fields */
+		if (this->record == NULL)
+		    this->record = (bpinfo_T *)xcalloc(sizeof(bpinfo_T));
+
+		this->record->id	    = -1;
+		this->record->enabled	    = TRUE;
+#  ifdef BP_INVALID_ANO_MISSING
+		this->record->disposition   = TRUE;
+#  endif
+		this->record->cont	    = FALSE;
+#  ifdef FEAT_GDB
+		this->record->buf	    = NULL;
+#  else
+		this->record->buf	    = -1;
+		this->record->typenr_en	    = -1;
+		this->record->typenr_dis    = -1;
+#  endif
+		this->record->lnum	    = 0;
+		this->record->next	    = NULL;
+	    }
+
+	    /* get info[] field from annotation content */
+	    set_bpfield(this, line);
+	    break;
+
+	case OOB_COMPLETE:
+	    /* process last record */
+	    process_record(this, obs);
+	    FREE(this->record);
+	    for (i = 0; i < BI_FIELDS; i++)
+		FREE(this->lvl2.info[i]);
+
+	    /* All records left in the old table are breakpoints that have
+	     * been deleted: delete the corresponding highliting sign */
+	    for (p = this->bpinfo; p != NULL; p = p->next)
+		gdb_unlite(BP_SIGN_ID(p->id));
+
+	    this->bp_state &= ~BPS_INVALID;
+	    this->bp_state &= ~BPS_FR_INVALID;
+	    this->bp_state &= ~BPS_BP_HIT;
+
+	    /* replace with new table */
+	    gdb_free_bplist(&(this->bpinfo));
+	    this->bpinfo = this->tmplist;
+	    this->tmplist = NULL;
+	    break;
+    }
+    return NULL;
+}
+
+/* Process the current info record */
+    static void
+process_record(this, obs)
+    gdb_T *this;
+    struct obstack *obs;
+{
+    bpinfo_T *record  = this->record;
+    char_u *bp_add    = NULL;
+    char_u *bp_at     = NULL;
+    char_u *bp_line   = NULL;
+    char_u *bp_source = NULL;
+    char_u *ptr;
+
+    if (record == NULL)
+	return;
+
+    /* breakpoint number */
+    if (this->lvl2.info[BI_NUM] != NULL)
+	record->id = atoi((char *)this->lvl2.info[BI_NUM]);
+
+    /* enabled state */
+    if (this->lvl2.info[BI_ENABLE] != NULL && *(this->lvl2.info[BI_ENABLE]) == 'n')
+	record->enabled = FALSE;
+
+#  ifdef BP_INVALID_ANO_MISSING
+    /* disposition */
+    if (this->lvl2.info[BI_DISPO] != NULL
+	    && STRSTR(this->lvl2.info[BI_DISPO], "keep") == NULL)
+	record->disposition = FALSE;
+#  endif
+
+    /* parse 'commands' for 'continue' as last statement */
+    if (this->lvl2.info[BI_CMMDS] != NULL)
+    {
+	/* get last line */
+	if ((ptr = (char_u *)strrchr(
+	    (char *)this->lvl2.info[BI_CMMDS], (int)'\n')) == NULL)
+	    ptr = this->lvl2.info[BI_CMMDS];
+	else
+	    ptr++;
+
+	if (gdb_regexec(ptr, PAT_BP_CONT, 1, obs) != NULL
+		|| gdb_regexec(ptr, PAT_BP_CONT, 2, obs) != NULL)
+	{
+	    record->cont = TRUE;    /* continue */
+	}
+    }
+
+    /* sanity check and discard watchpoints and others */
+    if (record->id <= 0 || this->lvl2.info[BI_TYPE] == NULL
+	    || STRSTR(this->lvl2.info[BI_TYPE], "breakpoint") == NULL
+	    || this->lvl2.info[BI_ADDRESS] == NULL
+	    || this->lvl2.info[BI_WHAT] == NULL)
+	return;
+
+    bp_add = gdb_regexec(this->lvl2.info[BI_ADDRESS], PAT_ADD, 1, obs);
+    bp_line = gdb_regexec(this->lvl2.info[BI_WHAT], PAT_BP_SOURCE, 2, obs);
+    bp_source = gdb_regexec(this->lvl2.info[BI_WHAT], PAT_BP_SOURCE, 1, obs);
+    if ((bp_at = gdb_regexec(this->lvl2.info[BI_WHAT], PAT_BP_ASM, 1, obs)) == NULL)
+	bp_at = gdb_regexec(this->lvl2.info[BI_WHAT], PAT_BP_ASM, 2, obs);
+
+    gdb_process_record(this, bp_add, bp_at, bp_line, bp_source, obs);
+}
+
+/* Set the annotated indexed field with its possibly partial content */
+    static void
+set_bpfield(this, content)
+    gdb_T *this;
+    char_u *content;
+{
+    char_u *res = NULL;
+    char_u **pfield;
+
+    /*
+     * Set info[] with each breakpoint info field annotation
+     */
+    if (IS_RECORD(this->bp_state))
+    {
+	pfield = &(this->lvl2.info[RECORD_INDEX(this->bp_state)]);
+
+	if (*pfield == NULL)	    /* a new field */
+	    *pfield = (char_u *)clewn_strsave((char *)content);
+	else if (this->annoted)	    /* concatenate */
+	{
+	    gdb_cat(&res, *pfield);
+	    gdb_cat(&res, content);
+	    xfree(*pfield);
+	    *pfield = res;
+	}
+	else			    /* a new line in this field */
+	{
+	    gdb_cat(&res, *pfield);
+	    gdb_cat(&res, (char_u *)"\n");
+	    gdb_cat(&res, content);
+	    xfree(*pfield);
+	    *pfield = res;
+	}
+    }
+}
+
+/*
+ * Remove highlighting for all values that are unchanged and get
+ * from GDB the current "automatic display list"
+ */
+    static char *
+get_display(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u *res   = NULL;
+    gdbdisp_T *item;
+    char_u *oldline;
+    char_u *ptr;
+#  ifdef FEAT_GDB
+    buf_T *oldbuf = curbuf;
+    char_u *ptrn;
+    win_T *win;
+    pos_T pos;
+#  endif
+
+    switch(state)
+    {
+	case OOB_CMD:
+#  ifndef FEAT_GDB
+	    /* tell Vim to not update screen */
+	    cnb_startAtomic(this->var_buf);
+#  endif
+
+	    if (
+#  ifdef FEAT_GDB
+		    this->var_buf != NULL && this->lvl2.varlist.state == DSP_STOPPED)
+#  else
+		    this->var_buf > 0 && this->lvl2.varlist.state == DSP_STOPPED)
+#  endif
+	    {
+		/* remove highlighting for all values that are unchanged */
+		for (item = this->lvl2.varlist.list; item != NULL; item = item->next)
+		{
+#  ifdef FEAT_GDB
+		    if (! (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+			    && ! (item->state & DISP_CHANGED)
+			    && (item->state & DISP_HILITED))
+		    {
+			pos.lnum = 1;
+			pos.col = 0;
+
+			/* search for display item in variables window */
+			obstack_strcat(obs, "^\\s*");
+			obstack_strcat(obs, gdb_itoa(item->num));
+			obstack_strcat0(obs, ":");
+			ptrn = (char_u *)obstack_finish(obs);
+
+			if (searchit(NULL, this->var_buf, &pos,
+				    FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+			{
+			    oldline = ml_get_buf(this->var_buf, pos.lnum, FALSE);
+			    oldline = obstack_strsave(obs, oldline);
+
+			    /* this assumes that  "={*}" is not valid in
+			     * any expression or value for all GDB supported
+			     * languages */
+			    if ((ptr = STRSTR(oldline, " ={*} ")) != NULL)
+			    {
+				*(ptr + 3) = '=';
+
+				/* replace line */
+				curbuf = this->var_buf;
+				ml_replace(pos.lnum, oldline, TRUE);
+				changed_lines(pos.lnum, 0, pos.lnum + 1, 0);
+				curbuf = oldbuf;
+
+				if ((win = gdb_btowin(this->var_buf)) != NULL)
+				    redraw_win_later(win, NOT_VALID);
+			    }
+			}
+
+			item->state &= ~DISP_HILITED;
+		    }
+#  else
+		    if (! (item->state & DISP_CHANGED)
+			    && (item->state & DISP_HILITED))
+		    {
+			int lnum;
+
+			/* search for display item in variables window */
+			if ((oldline = cnb_search_obj(gdb_itoa(item->num), &lnum)) != NULL)
+			{
+			    line = obstack_strsave(obs, oldline);
+
+			    /* this assumes that  "={*}" is not valid in
+			     * any expression or value for all GDB supported
+			     * languages */
+			    if ((ptr = STRSTR(line, " ={*} ")) != NULL)
+			    {
+				*(ptr + 3) = '=';
+
+				/* replace line */
+				cnb_replace(this->var_buf, line, lnum, obs);
+			    }
+			}
+			item->state &= ~DISP_HILITED;
+		    }
+#  endif
+
+		    item->state &= ~DISP_CHANGED;
+		}
+
+		FREE(this->lvl2.dispinfostr);
+		xfree(this->lvl2.dispinfo);
+		this->lvl2.dispinfo = (char_u *)clewn_strsave(" ");
+		return "server info display\n";
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    if (this->annoted)	    /* concatenate */
+	    {
+		gdb_cat(&res, this->lvl2.dispinfostr);
+		gdb_cat(&res, line);
+		xfree(this->lvl2.dispinfostr);
+		this->lvl2.dispinfostr = res;
+	    }
+	    else		    /* a new line */
+	    {
+		/* add item number to list */
+		if ((res = gdb_regexec(this->lvl2.dispinfostr, PAT_DISPINFO, 1, obs)) != NULL)
+		{
+		    gdb_cat(&(this->lvl2.dispinfo), res);
+		    gdb_cat(&(this->lvl2.dispinfo), (char_u *)" ");
+		}
+
+		xfree(this->lvl2.dispinfostr);
+		this->lvl2.dispinfostr = (char_u *)clewn_strsave((char *)line);
+	    }
+	    break;
+
+	case OOB_COMPLETE:
+	    /* add last item number to list */
+	    if ((res = gdb_regexec(this->lvl2.dispinfostr, PAT_DISPINFO, 1, obs)) != NULL)
+	    {
+		gdb_cat(&(this->lvl2.dispinfo), res);
+		gdb_cat(&(this->lvl2.dispinfo), (char_u *)" ");
+	    }
+	    FREE(this->lvl2.dispinfostr);
+	    break;
+    }
+    return NULL;
+}
+
+/*
+ * Synchronise the gdb variables window list and our varlist with
+ * GDB "automatic display list".
+ * It should be sufficient that all items in varlist are included
+ * both in the gdb variables window list and in GDB
+ * "automatic display list".
+ */
+    static char *
+undisplay(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+#  ifdef FEAT_GDB
+{
+    char_u *sequence = NULL;	/* sequence of items to undisplay */
+    win_T *oldwin    = curwin;
+    buf_T *oldbuf    = curbuf;
+    char_u *num;
+    char_u *ptrn;
+    gdbdisp_T **pt;
+    gdbdisp_T *next;
+    char_u *numstr;
+    pos_T pos;
+    win_T *win;
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    if (this->lvl2.varlist.state == DSP_STOPPED)
+	    {
+		for (pt = &(this->lvl2.varlist.list); *pt != NULL; )
+		{
+		    numstr = gdb_itoa((*pt)->num);
+
+		    /* not in * GDB "automatic display list" */
+		    obstack_strcat(obs, " ");
+		    obstack_strcat(obs, numstr);
+		    obstack_strcat0(obs, " ");
+		    num = (char_u *)obstack_finish(obs);
+
+		    if (this->lvl2.dispinfo != NULL
+			    && this->var_buf != NULL
+			    && STRSTR(this->lvl2.dispinfo, num) == NULL)
+		    {
+			pos.lnum = 1;
+			pos.col = 0;
+
+			/* remove line from window if exists */
+			obstack_strcat(obs, "^\\s*");
+			obstack_strcat(obs, numstr);
+			obstack_strcat0(obs, ":");
+			ptrn = (char_u *)obstack_finish(obs);
+
+			if (! (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+				&& searchit(NULL, this->var_buf, &pos,
+				    FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+			{
+			    curbuf = this->var_buf;
+			    ml_delete(pos.lnum, FALSE);
+			    deleted_lines(pos.lnum, 1);
+
+			    if ((win = gdb_btowin(this->var_buf)) != NULL)
+			    {
+				curwin = win;
+				check_cursor();
+				update_topline();
+				curwin = oldwin;
+
+				win->w_redr_status = TRUE;
+
+				redraw_win_later(win, NOT_VALID);
+			    }
+			    curbuf = oldbuf;
+			}
+
+			/* remove from varlist */
+			next = (*pt)->next;
+			xfree(*pt);
+			*pt = next;
+
+			continue;
+		    }
+
+		    /* not in gdb variables window */
+		    obstack_strcat(obs, "^\\s*");
+		    obstack_strcat(obs, numstr);
+		    obstack_strcat0(obs, ":");
+		    ptrn = (char_u *)obstack_finish(obs);
+
+		    if (this->var_buf == NULL
+			    || (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+			    || (searchit(NULL, this->var_buf, &pos,
+				    FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) == FAIL))
+		    {
+			/* add to sequence */
+			obstack_strcat(obs, numstr);
+			obstack_strcat0(obs, " ");
+			sequence = (char_u *)obstack_finish(obs);
+
+			/* remove from varlist */
+			next = (*pt)->next;
+			xfree(*pt);
+			*pt = next;
+
+			continue;
+		    }
+
+		    pt = &((*pt)->next);
+		}
+
+		this->lvl2.varlist.state = DSP_INIT;
+		FREE(this->lvl2.dispinfo);
+
+		if (sequence != NULL)
+		{
+		    obstack_strcat(obs, "server undisplay ");
+		    obstack_strcat(obs, sequence);
+		    obstack_strcat0(obs, "\n");
+		    return (char *)obstack_finish(obs);
+		}
+	    }
+	    break;
+
+	case OOB_COMPLETE:
+	    line = NULL;    /* keep compiler happy */
+	    break;
+    }
+    return NULL;
+}
+#  else
+{
+    char_u *sequence = NULL;	/* sequence of items to undisplay */
+    char_u *num;
+    gdbdisp_T **pt;
+    gdbdisp_T *next;
+    char_u *numstr;
+    int lnum;
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    if (this->lvl2.varlist.state == DSP_STOPPED)
+	    {
+		for (pt = &(this->lvl2.varlist.list); *pt != NULL; )
+		{
+		    numstr = gdb_itoa((*pt)->num);
+
+		    /* not in * GDB "automatic display list" */
+		    obstack_strcat(obs, " ");
+		    obstack_strcat(obs, numstr);
+		    obstack_strcat0(obs, " ");
+		    num = (char_u *)obstack_finish(obs);
+
+		    if (this->lvl2.dispinfo != NULL
+			    && this->var_buf > 0
+			    && STRSTR(this->lvl2.dispinfo, num) == NULL)
+		    {
+			/* replace line in window if exists with an empty line */
+			if (cnb_search_obj(numstr, &lnum) != NULL)
+			    cnb_replace(this->var_buf, "", lnum, obs);
+
+			/* remove from varlist */
+			next = (*pt)->next;
+			xfree(*pt);
+			*pt = next;
+
+			continue;
+		    }
+
+		    /* not in gdb variables window */
+		    if (this->var_buf <= 0 || cnb_search_obj(numstr, &lnum) == NULL)
+		    {
+			/* add to sequence */
+			obstack_strcat(obs, numstr);
+			obstack_strcat0(obs, " ");
+			sequence = (char_u *)obstack_finish(obs);
+
+			/* remove from varlist */
+			next = (*pt)->next;
+			xfree(*pt);
+			*pt = next;
+
+			continue;
+		    }
+
+		    pt = &((*pt)->next);
+		}
+
+		this->lvl2.varlist.state = DSP_INIT;
+		FREE(this->lvl2.dispinfo);
+
+		if (sequence != NULL)
+		{
+		    obstack_strcat(obs, "server undisplay ");
+		    obstack_strcat(obs, sequence);
+		    obstack_strcat0(obs, "\n");
+		    return (char_u *)obstack_finish(obs);
+		}
+	    }
+	    /* tell Vim to update screen */
+	    cnb_endAtomic(this->var_buf);
+	    break;
+
+	case OOB_COMPLETE:
+	    /* tell Vim to update screen */
+	    cnb_endAtomic(this->var_buf);
+	    line = NULL;    /* keep compiler happy */
+	    break;
+    }
+    return NULL;
+}
+#  endif
+
+/*
+ * Handle the content of a display annotation.
+ * Fill up each field.
+ * When entry complete, process it:
+ *	. if it's the result of a GDB "display" command with an argument:
+ *	  add to variables window and varlist
+ *	. if it is the output produced by GDB when the program stops or
+ *	  an equivalent GDB "display" command without argument: hilite
+ *	  changed values in variables window
+ */
+    void
+gdb_process_display(this, line, obs)
+    gdb_T *this;
+    char_u *line;	/* display annotation content */
+    struct obstack *obs;
+{
+    char_u *res = NULL;
+    int note    = this->note;
+    char_u *displine;		    /* the new display item line */
+    gdbdisp_T *item;
+    char_u *last, *end, *start;
+    char_u *ptr;
+    int num;
+#  ifdef FEAT_GDB
+    win_T *oldwin    = curwin;
+    buf_T *oldbuf    = curbuf;
+    char_u *ptrn;
+    linenr_T lnum;
+    win_T *win;
+    pos_T pos;
+#  endif
+
+#  ifdef FEAT_GDB
+    if (this->var_buf == NULL)
+#  else
+    if (this->var_buf <= 0)
+#  endif
+	return;
+
+    /* GDB bug: outputs ANO_DISP_EXP instead of ANO_DISP_VALUE
+     * use doing_value as a hack to know when we are parsing the value */
+    if (this->lvl2.doing_value && note == ANO_DISP_EXP)
+	note = ANO_DISP_VALUE;
+
+    /* nested structure or array */
+    if (this->lvl2.doing_value
+	    && ((note >= ANO_FIELD_BEG && note <= ANO_FIELD_END)
+		|| (note >= ANO_ARRAY_BEG && note <= ANO_ARRAY_END)))
+	note = ANO_DISP_VALUE;
+
+    switch (note)
+    {
+	case ANO_DISP_BEG:
+#  ifndef FEAT_GDB
+	    /* tell Vim to not update screen */
+	    cnb_startAtomic(this->var_buf);
+#  endif
+
+	    this->lvl2.doing_value = FALSE;
+
+	    /* display number */
+	    if (this->lvl2.dentry.num == NULL)
+		this->lvl2.dentry.num = (char_u *)clewn_strsave((char *)line);
+	    else
+	    {
+		gdb_cat(&res, this->lvl2.dentry.num);
+		gdb_cat(&res, line);
+		xfree(this->lvl2.dentry.num);
+		this->lvl2.dentry.num = res;
+	    }
+	    break;
+
+	case ANO_DISP_FMT:
+	case ANO_DISP_EXP:
+	    /* display format and expression */
+	    if (this->lvl2.dentry.expression == NULL)
+		this->lvl2.dentry.expression = (char_u *)clewn_strsave((char *)line);
+	    else
+	    {
+		gdb_cat(&res, this->lvl2.dentry.expression);
+		gdb_cat(&res, line);
+		xfree(this->lvl2.dentry.expression);
+		this->lvl2.dentry.expression = res;
+	    }
+	    break;
+
+	case ANO_DISP_EXPEND:
+	    this->lvl2.doing_value = TRUE;
+	    break;
+
+	case ANO_DISP_VALUE:
+	    /* display value */
+	    if (this->lvl2.dentry.value == NULL)
+		this->lvl2.dentry.value = (char_u *)clewn_strsave((char *)line);
+	    else
+	    {
+		gdb_cat(&res, this->lvl2.dentry.value);
+		gdb_cat(&res, line);
+		xfree(this->lvl2.dentry.value);
+		this->lvl2.dentry.value = res;
+	    }
+	    break;
+
+	/* Process the entry now it's complete */
+	case ANO_DISP_END:
+	    this->lvl2.doing_value = FALSE;
+
+	    /* sanity checks */
+	    if (this->lvl2.dentry.num == NULL
+		    || (num = atoi((char *)this->lvl2.dentry.num)) <= 0
+		    || this->lvl2.dentry.expression == NULL
+		    || this->lvl2.dentry.value == NULL)
+	    {
+		FREE(this->lvl2.dentry.num);
+		FREE(this->lvl2.dentry.expression);
+		FREE(this->lvl2.dentry.value);
+		return;
+	    }
+
+	    /* Build the display line including ={*}, the hiliting sign */
+	    obstack_strcat(obs, this->lvl2.dentry.num);
+	    obstack_strcat(obs, ":");
+	    obstack_strcat(obs, this->lvl2.dentry.expression);
+	    obstack_strcat(obs, " ={*} ");
+	    obstack_strcat0(obs, this->lvl2.dentry.value);
+	    displine = (char_u *)obstack_finish(obs);
+
+	    /*
+	     * The result of a GDB "display" command with argument
+	     */
+	    if (this->cmd_type == CMD_DISPLAY)
+	    {
+		item = (gdbdisp_T *)xcalloc(sizeof(gdbdisp_T));
+
+		/* add item to varlist */
+		item->num = num;
+		item->state = DISP_HILITED;
+		item->next = this->lvl2.varlist.list;
+		this->lvl2.varlist.list = item;
+
+#  ifdef FEAT_GDB
+		lnum = BUFLASTL(this->var_buf);
+
+		/* edit variables buffer in available window */
+		if (gdb_edit_file(this, this->var_buf, NULL, lnum, obs) != NULL)
+		{
+		    /* add to variables buffer */
+		    if (ml_append(lnum, displine, 0, 0) == OK)
+		    {
+			/* first line ever: remove empty line after the
+			 * one just inserted */
+			if (lnum == 0)
+			    ml_delete(this->var_buf->b_ml.ml_line_count, FALSE);
+
+			changed_lines(this->var_buf->b_ml.ml_line_count - 1,
+				0, this->var_buf->b_ml.ml_line_count, 1);
+		    }
+
+		    /* update top line */
+		    curwin->w_cursor.lnum = this->var_buf->b_ml.ml_line_count;
+		    update_topline();
+
+		    /* status line changed */
+		    curwin->w_redr_status = TRUE;
+
+		    /* move back to previous window if still there */
+		    if ((win = gdb_btowin(oldbuf)) != NULL)
+			win_goto(win);
+		}
+#  else
+		/* add to variables buffer */
+		cnb_append(this->var_buf, displine, obs);
+#  endif
+	    }
+
+	    /*
+	     * Highlight existing changed values in variables window
+	     */
+	    else
+	    {
+#  ifdef FEAT_GDB
+		pos.lnum = 1;
+		pos.col = 0;
+
+		/* search for display item in variables window */
+		obstack_strcat(obs, "^\\s*");
+		obstack_strcat(obs, this->lvl2.dentry.num);
+		obstack_strcat0(obs, ":");
+		ptrn = (char_u *)obstack_finish(obs);
+
+		if ( ! (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+			&& searchit(NULL, this->var_buf, &pos,
+			    FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+		{
+		    lnum = pos.lnum;
+
+		    obstack_strcat(obs, "} ");
+		    obstack_strcat0(obs, this->lvl2.dentry.value);
+		    res = (char_u *)obstack_finish(obs);
+
+		    last = NULL;
+		    start = ml_get_buf(this->var_buf, lnum, FALSE);
+		    end = start + STRLEN(start);
+
+		    /* get last occurence of "} " + value in this line */
+		    for (ptr = start; ptr != NULL; )
+			if ((ptr=STRSTR(ptr, res)) != NULL)
+			{
+			    last = ptr;
+			    ptr++;
+			}
+
+		    /* a changed value (res not found at line end) */
+		    if (last == NULL || end != last + STRLEN(res))
+		    {
+			/* replace line */
+			curbuf = this->var_buf;
+			ml_replace(lnum, displine, TRUE);
+			changed_lines(lnum, 0, lnum + 1, 0);
+
+			if ((win = gdb_btowin(this->var_buf)) != NULL)
+			{
+			    win->w_cursor.lnum = lnum;
+
+			    curwin = win;
+			    check_cursor();
+			    update_topline();
+			    curwin = oldwin;
+
+			    win->w_redr_status = TRUE;
+
+			    redraw_win_later(win, NOT_VALID);
+			}
+			curbuf = oldbuf;
+
+			/* update item state */
+			for (item = this->lvl2.varlist.list; item != NULL;
+				item = item->next)
+			    if (item->num == num)
+			    {
+				item->state |= DISP_HILITED | DISP_CHANGED;
+				break;
+			    }
+		    }
+		}
+#  else
+		int line_nb;
+
+		/* search for display item in variables window */
+		if ((start = cnb_search_obj(this->lvl2.dentry.num, &line_nb)) != NULL)
+		{
+		    obstack_strcat(obs, "} ");
+		    obstack_strcat0(obs, this->lvl2.dentry.value);
+		    res = (char_u *)obstack_finish(obs);
+
+		    last = NULL;
+		    end = start + STRLEN(start);
+
+		    /* get last occurence of "} " + value in this line */
+		    for (ptr = start; ptr != NULL; )
+			if ((ptr=STRSTR(ptr, res)) != NULL)
+			{
+			    last = ptr;
+			    ptr++;
+			}
+
+		    /* a changed value (res not found at line end) */
+		    if (last == NULL || end != last + STRLEN(res))
+		    {
+			/* replace line */
+			cnb_replace(this->var_buf, displine, line_nb, obs);
+
+			/* update item state */
+			for (item = this->lvl2.varlist.list; item != NULL;
+				item = item->next)
+			    if (item->num == num)
+			    {
+				item->state |= DISP_HILITED | DISP_CHANGED;
+				break;
+			    }
+		    }
+		}
+#  endif
+	    }
+
+	    FREE(this->lvl2.dentry.num);
+	    FREE(this->lvl2.dentry.expression);
+	    FREE(this->lvl2.dentry.value);
+
+#  ifndef FEAT_GDB
+	    /* tell Vim to update screen */
+	    cnb_endAtomic(this->var_buf);
+#  endif
+	    break;
+
+	default:
+	    break;
+    }
+}
+
+/* Undisplay all variables */
+    static void
+var_delete(this)
+    gdb_T *this;
+{
+    struct obstack obs;	/* use an obstack for temporary allocated memory */
+    char_u *res;
+
+    /* undisplay all */
+    this->lvl2.varlist.state = DSP_STOPPED;
+
+    (void)obstack_init(&obs);
+
+    if ((res = (char_u *)undisplay(this, OOB_CMD, (char_u *)"", &obs)) != NULL)
+	gdb_send_cmd(this, res);
+
+    obstack_free(&obs, NULL);
+}
+# endif /* GDB_LVL2_SUPPORT */
+#endif /* defined(FEAT_GDB) || defined(HAVE_CLEWN) */
diff --git a/src/clewn/gdb_lvl3.c b/src/clewn/gdb_lvl3.c
new file mode 100644
index 0000000..1a7845b
--- /dev/null
+++ b/src/clewn/gdb_lvl3.c
@@ -0,0 +1,4116 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * Copyright (C) 2004 Xavier de Gaye.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (see the file COPYING); if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: gdb_lvl3.c 222 2008-10-13 14:38:07Z xavier $
+ */
+
+# ifdef HAVE_CLEWN
+#  include <config.h>
+#  include "obstack.h"
+#  include "clewn.h"
+static int got_int;	/* not used with Clewn */
+# else
+#  include "vim.h"
+#  include "clewn/obstack.h"
+# endif
+
+#if defined(FEAT_GDB) || defined(HAVE_CLEWN)
+
+# include "gdb.h"
+# include "misc.h"
+
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+
+static char gdb_buf[MAX_BUFFSIZE];  /* general purpose buffer */
+
+typedef struct
+{
+    int id;	    /* annoted identifier */
+    char_u *str;    /* GDB annotation */
+} annotation_T;
+
+static annotation_T annotations[] = {
+    {ANO_PREPROMPT,		(char_u *)"pre-prompt"},
+    {ANO_PROMPT,		(char_u *)"prompt"},
+    {ANO_POSTPROMPT,		(char_u *)"post-prompt"},
+    {ANO_PRECMDS,		(char_u *)"pre-commands"},
+    {ANO_CMDS,			(char_u *)"commands"},
+    {ANO_PREOVERLOAD,		(char_u *)"pre-overload-choice"},
+    {ANO_OVERLOAD,		(char_u *)"overload-choice"},
+    {ANO_PREQUERY,		(char_u *)"pre-query"},
+    {ANO_QUERY,			(char_u *)"query"},
+    {ANO_PREPMT_FORMORE,	(char_u *)"pre-prompt-for-continue"},
+    {ANO_PMT_FORMORE,		(char_u *)"prompt-for-continue"},
+    {ANO_POSTPMT_FORMORE,	(char_u *)"post-prompt-for-continue"},
+    {ANO_QUIT,			(char_u *)"quit"},
+    {ANO_ERROR_BEG,		(char_u *)"error-begin"},
+    {ANO_FRAME_INVALID,		(char_u *)"frames-invalid"},
+    {ANO_BP_INVALID,		(char_u *)"breakpoints-invalid"},
+    {ANO_STARTING,		(char_u *)"starting"},
+    {ANO_STOPPED,		(char_u *)"stopped"},
+    {ANO_EXITED,		(char_u *)"exited"},
+    {ANO_SIGNALLED,		(char_u *)"signalled"},
+    {ANO_BREAKPOINT,		(char_u *)"breakpoint"},
+#  ifdef GDB_LVL2_SUPPORT
+    {ANO_SOURCE,		(char_u *)"source"},
+    {ANO_FRAME_BEGIN,		(char_u *)"frame-begin"},
+    {ANO_FRAME_END,		(char_u *)"frame-end"},
+    {ANO_BP_HEADER,		(char_u *)"breakpoints-headers"},
+    {ANO_BP_TABLE,		(char_u *)"breakpoints-table"},
+    {ANO_BP_RECORD,		(char_u *)"record"},
+    {ANO_BP_FIELD0,		(char_u *)"field 0"},
+    {ANO_BP_FIELD1,		(char_u *)"field 1"},
+    {ANO_BP_FIELD2,		(char_u *)"field 2"},
+    {ANO_BP_FIELD3,		(char_u *)"field 3"},
+    {ANO_BP_FIELD4,		(char_u *)"field 4"},
+    {ANO_BP_FIELD5,		(char_u *)"field 5"},
+    {ANO_BP_FIELD6,		(char_u *)"field 6"},
+    {ANO_BP_FIELD7,		(char_u *)"field 7"},
+    {ANO_BP_FIELD8,		(char_u *)"field 8"},
+    {ANO_BP_FIELD9,		(char_u *)"field 9"},
+    {ANO_BP_END,		(char_u *)"breakpoints-table-end"},
+    {ANO_DISP_BEG,		(char_u *)"display-begin"},
+    {ANO_DISP_NUMEND,		(char_u *)"display-number-end"},
+    {ANO_DISP_FMT,		(char_u *)"display-format"},
+    {ANO_DISP_EXP,		(char_u *)"display-expression"},
+    {ANO_DISP_EXPEND,		(char_u *)"display-expression-end"},
+    {ANO_DISP_VALUE,		(char_u *)"display-value"},
+    {ANO_DISP_END,		(char_u *)"display-end"},
+    {ANO_FIELD_BEG,		(char_u *)"field-begin"},
+    {ANO_FIELD_NAMEND,		(char_u *)"field-name-end"},
+    {ANO_FIELD_VALUE,		(char_u *)"field-value"},
+    {ANO_FIELD_END,		(char_u *)"field-end"},
+    {ANO_ARRAY_BEG,		(char_u *)"array-section-begin"},
+    {ANO_ARRAY_ELT,		(char_u *)"elt"},
+    {ANO_ARRAY_ELTREP,		(char_u *)"elt-rep"},
+    {ANO_ARRAY_ELTEND,		(char_u *)"elt-rep-end"},
+    {ANO_ARRAY_END,		(char_u *)"array-section-end"},
+#  endif
+    {0,				NULL}
+};
+
+/* User interface */
+static char_u *process_cmd __ARGS((gdb_T *, char_u *));
+
+/* Vim low level hook */
+/* Not allowed after ^O in INS REP mode or from the input-line window */
+static char_u *process_annotation __ARGS((gdb_T *, char_u *, struct obstack *));
+static char_u * process_completion __ARGS((cli_cmd_T *, char_u *, struct obstack *));
+static char_u * eol_choices __ARGS((cli_cmd_T *, struct obstack *));
+
+#  ifdef GDB_LVL3_SUPPORT
+/* Gdb process mgmt */
+static void clear_gdb_T __ARGS((gdb_T *));
+
+/* Out Of Band */
+static char *get_lastbp __ARGS((gdb_T *, int, char_u *, struct obstack *));
+static char *get_bp __ARGS((gdb_T *, int, char_u *, struct obstack *));
+static void process_record __ARGS((gdb_T *, char_u *, struct obstack *));
+static char *varobj_update __ARGS((gdb_T *, int, char_u *, struct obstack *));
+static char *varobj_complete __ARGS((gdb_T *, struct obstack *));
+static void varobj_hilite __ARGS((gdb_T *, varobj_T *, int, struct obstack *));
+static void varobj_replace __ARGS((gdb_T *, varobj_T *, char_u *, struct obstack *));
+static void remove_object __ARGS((gdb_T *, varobj_T *));
+#  endif
+
+/* Utilities */
+static char_u * parse_note __ARGS((gdb_T *, char_u *));
+#  ifndef FEAT_GDB
+static int get_note __ARGS((gdb_T *, char_u *));
+#  endif
+
+#  ifdef GDB_LVL3_SUPPORT
+/* The function ordering in this array is important as some of
+ * these functions must be invoked in the right order */
+static oobfunc_T oobfunc[] = {
+    {gdb_get_pc},
+    {gdb_get_frame},
+    {gdb_get_sourcedir},
+#ifndef FEAT_GDB
+    {gdb_source_project},
+    {gdb_get_pwd},
+    {gdb_get_args},
+#endif
+    {gdb_source_cur},
+    {gdb_source_list},
+    {gdb_get_sfile},
+    {gdb_info_frame},
+    {gdb_stack_frame},	    /* after gdb_info_frame */
+    {get_lastbp},	    /* after gdb_get_frame */
+    {gdb_get_asmfunc},	    /* after get_lastbp */
+    {gdb_get_asmfunc_hack}, /* after gdb_get_asmfunc */
+    {gdb_get_asm},	    /* after gdb_get_asmfunc */
+    {get_bp},		    /* after gdb_get_asm and get_lastbp */
+    {varobj_update},
+    {NULL}
+};
+#  endif
+
+/** Send a cmd to gdb */
+    void
+gdb_docmd_cli(this, cmd)
+    gdb_T *this;
+    char_u  *cmd;	/* gdb cmd */
+{
+#  ifdef GDB_LVL3_SUPPORT
+    char_u *expression = NULL;
+    varobj_T *varobj;
+#  endif
+    char_u *res;
+    char_u *ptr;
+    char_u *last;
+    int len;
+
+    /* make a copy so we can mess with it */
+    if (cmd == NULL)
+    {
+	this->cmd_type = CMD_ANY;
+	goto empty_cmd;
+    }
+    cmd = (char_u *)clewn_strsave((char *)cmd);
+
+    /* remove illegal characters */
+    for (ptr = last = cmd; *last != NUL; last++)
+	if (*last == NL
+		|| *last == TAB
+		|| *last == KEY_INTERUPT 
+		|| !iscntrl((int)(*last)))
+	    *ptr++ = *last;
+    *ptr = NUL;
+
+    /* remove backslash at last position */
+    if (ptr != cmd && *(ptr - 1) == '\\')
+	*(ptr - 1) = NUL;
+
+    if (this->cli_cmd.state == CS_QUERY || this->note == ANO_QUERY)
+    {
+	if (*cmd == NUL)
+	    goto empty_cmd;
+	goto send;
+    }
+
+    /* now we can forget last cmd */
+    this->cmd_type = CMD_ANY;
+
+    /* an interrupt */
+    if (STRCHR(cmd, KEY_INTERUPT) != NULL)
+	goto send;
+
+    /* a TAB */
+    if (STRCHR(cmd, TAB) != NULL)
+    {
+	gdb_cmd_type(this, cmd);	/* get cmd type */
+
+	/* handle completion for all non-gdb commands */
+	if (this->cmd_type == CMD_RESTART) {
+	    gdb_setwinput((gdb_handle_T *)this, (char_u *)"cl_restart ");
+	    xfree(cmd);
+	    this->oob.state &= ~OS_CMD;
+	    return;
+	}
+	else if (this->cmd_type == CMD_CREATEVAR)
+	{
+	    gdb_setwinput((gdb_handle_T *)this, (char_u *)"createvar ");
+	    xfree(cmd);
+	    this->oob.state &= ~OS_CMD;
+	    return;
+	}
+	goto send;
+    }
+
+    if ((res = gdb_regexec(cmd, PAT_CHG_ANNO, 0, NULL)) != NULL)
+    {
+	EMSG(_("Sorry, cannot change annotation level"));
+	xfree(res);
+	goto empty_cmd;
+    }
+
+#  ifndef FEAT_GDB  /* Clewn follows GDB behavior with empty commands */
+    if (*cmd == NUL)
+    {
+	gdb_send_cmd(this, (char_u *)"\n");
+	xfree(cmd);
+	return;
+    }
+#  endif
+
+    /* process the cmd */
+    if ((res = process_cmd(this, cmd)) != NULL)
+    {
+	xfree(cmd);
+	cmd = res;
+
+#  ifdef GDB_LVL3_SUPPORT
+	/* a |+gdb| createvar command is processed later in oob varobj_update() */
+	if (this->mode == GDB_MODE_LVL3 && this->cmd_type == CMD_CREATEVAR)
+	{
+#   ifdef FEAT_GDB
+	    if (this->var_buf == NULL)
+#   else
+	    if (this->var_buf <= 0)
+#   endif
+	    {
+		EMSG(_("Variables buffer does not exist anymore: unable to create variable"));
+		goto empty_cmd;
+	    }
+
+	    if (
+#   ifdef FEAT_GDB
+		    (expression = gdb_regexec(cmd, PAT_CRVAR_FMT, 2, NULL)) != NULL
+#   else
+		    (expression = gdb_regexec(cmd, PAT_CRVAR_FMT, 3, NULL)) != NULL
+#   endif
+		    && *expression != NUL)
+	    {
+		varobj = (varobj_T *)xcalloc(sizeof(varobj_T));
+
+		/* create a new varobj_T element and link it to the list */
+		varobj->state      = VS_INIT;
+		varobj->children   = FALSE;
+#   ifdef FEAT_GDB
+		varobj->format     = gdb_regexec(cmd, PAT_CRVAR_FMT, 1, NULL);
+#   else
+		varobj->format     = gdb_regexec(cmd, PAT_CRVAR_FMT, 2, NULL);
+#   endif
+		varobj->expression = expression;
+		varobj->next = this->lvl3.varlist;
+		this->lvl3.varlist = varobj;
+
+		goto empty_cmd;
+	    }
+
+	    xfree(expression);
+	    EMSG(_("Unvalid arguments to \"createvar\" command"));
+	    goto empty_cmd;
+	}
+#  endif
+    }
+    else
+	goto empty_cmd;
+
+    /* add a newline to cmd if needed */
+    len = STRLEN(cmd);
+    if (len == 0 || *(cmd + len - 1) != NL)
+    {
+	res = NULL;
+	gdb_cat(&res, cmd);
+	gdb_cat(&res, (char_u *)"\n");
+	xfree(cmd);
+	cmd = res;
+    }
+send:
+    gdb_send_cmd(this, cmd);
+    xfree(cmd);
+    return;
+empty_cmd:
+    gdb_send_cmd(this, (char_u *)" \n");
+    xfree(cmd);
+    return;
+}
+
+/*
+ * Process a gdb cmd according to its type.
+ * Return an allocated sanitized cmd or NULL if error.
+ */
+    static char_u *
+process_cmd(this, cmd)
+    gdb_T *this;
+    char_u  *cmd;	/* user's gdb cmd */
+{
+    char_u *delete  = NULL;
+    char_u *range   = NULL;
+    char_u *res;
+#  ifdef FEAT_GDB
+    int i;
+    buf_T *buf	    = NULL;
+    win_T *oldwin   = curwin;
+#  endif
+
+    /* make a copy so we can mess with it */
+    if (cmd == NULL || *cmd == NUL)
+	return NULL;
+    cmd = (char_u *)clewn_strsave((char *)cmd);
+
+    gdb_cmd_type(this, cmd);	/* get cmd type */
+
+#  ifdef GDB_LVL2_SUPPORT
+    /* Replace "createvar" command with GDB "display" command */
+    if (this->mode == GDB_MODE_LVL2 && this->cmd_type == CMD_CREATEVAR)
+    {
+#   ifdef FEAT_GDB
+	if ((res = gdb_regexec(cmd, PAT_CREATEVAR, 1, NULL)) != NULL)
+#   else
+	if ((res = gdb_regexec(cmd, PAT_CREATEVAR, 2, NULL)) != NULL)
+#   endif
+	{
+	    /* replace */
+	    this->cmd_type = CMD_DISPLAY;
+	    FREE(cmd);
+	    gdb_cat(&cmd, (char_u *)"display ");
+	    gdb_cat(&cmd, res);
+	    xfree(res);
+
+	    if (cmd == NULL)
+	    {
+		this->cmd_type = CMD_ANY;
+		return NULL;
+	    }
+	}
+    }
+#  endif
+
+#  ifndef FEAT_GDB
+    /* Prevent use of a low height size because of "prompt-for-continue" messages.
+     * The annotations lines printed by GDB are part of the lines count that
+     * is used by GDB for "prompt-for-continue" messages, however we do not
+     * display them. */
+    if ((res = gdb_regexec(cmd, PAT_HEIGHT, 2, NULL)) != NULL)
+    {
+	fprintf(stderr, "Cannot change the screen size\n");
+	xfree(cmd);
+	xfree(res);
+	return NULL;
+    }
+#  endif
+
+    /* Cannot attach to oneself */
+#  ifdef FEAT_GDB
+    if ((res = gdb_regexec(cmd, PAT_PID, 1, NULL)) != NULL)
+#  else
+    if ((res = gdb_regexec(cmd, PAT_PID, 2, NULL)) != NULL)
+#  endif
+    {
+	if (getpid() == atoi((char *)res))
+	{
+	    EMSG(_("I refuse to debug myself!"));
+	    xfree(cmd);
+	    xfree(res);
+	    return NULL;
+	}
+	xfree(res);
+    }
+
+    /* no processing for 'define' type cmds */
+    if (this->note == ANO_CMDS || this->note == ANO_OVERLOAD)
+	return cmd;
+
+    switch (this->cmd_type)
+    {
+#  ifdef GDB_LVL2_SUPPORT
+	case CMD_DISPLAY:
+	    /* A "display" command without argument is equivalent to the
+	     * debuggee being stopped */
+	    if ((res = gdb_regexec(cmd, PAT_DISPLAY, 0, NULL)) != NULL)
+	    {
+		xfree(res);
+		this->cmd_type = CMD_ANY;
+#   ifdef FEAT_GDB
+		if (this->var_buf != NULL)
+#   else
+		if (this->var_buf > 0)
+#   endif
+		    this->lvl2.varlist.state = DSP_STOPPED;
+	    }
+	    break;
+#  endif
+
+	case CMD_SHELL:
+	    EMSG(_("Sorry, cannot spawn a shell"));
+	    xfree(cmd);
+	    return NULL;
+
+	/* unlite frame on 'detach' */
+	case CMD_DETACH:
+	    gdb_fr_unlite(this);
+	    break;
+
+	/* clear dirty asm buffers */
+	case CMD_EXECF:
+#  ifdef FEAT_GDB
+	    for (i = 0; i < this->pool.max; i++)
+	    {
+		if ((curbuf = this->pool.buf[i]) == NULL)
+		    continue;
+
+		/* clear the buffer */
+		gdb_clear_asmbuf(this, curbuf);
+
+		/* asm buffer is displayed */
+		if ((curwin = gdb_btowin(curbuf)) != NULL)
+		{
+		    check_cursor();
+		    buf = curbuf;
+		}
+		curwin = oldwin;
+	    }
+	    curbuf = curwin->w_buffer;
+	    gdb_redraw(buf);	/* redraw only if one asm displayed */
+#  else
+	    /* unlink all asm buffers */
+	    cnb_unlink_asm();
+#  endif
+
+#  ifdef GDB_LVL3_SUPPORT
+	    /* get source files list */
+	    this->lvl3.get_source_list = TRUE;
+#  endif
+	    break;
+
+	case CMD_SYMF:
+#  ifdef GDB_LVL3_SUPPORT
+	    /* get source files list */
+	    this->lvl3.get_source_list = TRUE;
+#  endif
+	    break;
+
+	case CMD_UP:
+	case CMD_UP_SILENT:
+	case CMD_DOWN:
+	case CMD_DOWN_SILENT:
+	case CMD_FRAME:
+	case CMD_SLECT_FRAME:
+	    if (this->mode != GDB_MODE_LVL3)
+	    {
+		this->pool.hilite = TRUE;
+
+		/* this should not be necessary but sometimes we
+		 * don't get the ANO_FRAME_INVALID */
+		this->bp_state |= BPS_FR_INVALID;
+	    }
+	    break;
+
+	case CMD_DELETE:
+	case CMD_DISABLE:
+	    /* keep BPS_FR_INVALID state */
+	    this->bp_state &= BPS_FR_INVALID;
+	    this->bp_state |= BPS_INVALID;
+	    break;
+
+	/* the restart command is mapped to the gdb 'quit' command,
+	 * and that will cause gdb to be restarted (the 'quit'
+	 * command itself is trapped and
+	 * causes a clean termination of clewn and vim) */
+	case CMD_RESTART:
+	    xfree(cmd);
+	    cmd = (char_u *)clewn_strsave("quit");
+	    break;
+
+	/* terminate clewn and vim */
+	case CMD_QUIT:
+	    this->state |= GS_QUITTING;
+	    break;
+
+	default:
+	    break;
+    }
+    xfree(range);
+    xfree(delete);
+    return cmd;
+}
+
+/* Send a cmd to gdb */
+    void
+gdb_send_cmd(this, cmd)
+    gdb_T *this;
+    char_u  *cmd;	/* gdb cmd */
+{
+    int do_free = TRUE;		/* TRUE when readline must be freed */
+    int offset = 0;
+    char_u *res;
+    char_u *start;
+    int len;
+    int l;
+
+    if ( ! GDB_STATE(this, GS_UP))
+	return;
+
+    this->intr_sent = FALSE;
+
+    /* make a copy so we can mess with it */
+    if (cmd == NULL || (len = STRLEN(cmd)) == 0 )
+	return;
+    cmd = (char_u *)clewn_strsave((char *)cmd);
+
+    /* paranoia: trim after NL */
+    if ((res = STRCHR(cmd, (int)NL)) != NULL)
+	*(res + 1) = NUL;
+
+    /* answering to a query: any stuff not 'y[es]' is converted to 'no' */
+    if (this->cli_cmd.state == CS_QUERY || this->note == ANO_QUERY)
+    {
+	len = 1;
+	if ((res = gdb_regexec(cmd, PAT_YES, 0, NULL)) != NULL)
+	{
+	    *cmd = 'y';
+	    xfree(res);
+	}
+	else
+	    *cmd = 'n';
+
+#  ifdef FEAT_GDB
+	/* CMD_DIR is acted upon when parsing gdb output */
+	if (this->cmd_type != CMD_DIR)
+	    this->cmd_type = CMD_ANY;
+#  endif
+
+	if (this->cli_cmd.state == CS_QUERY)	/* no NL when a completion */
+	{
+	    this->cli_cmd.state = CS_CHOICE;
+	    do_free = FALSE;
+
+	    /* a standalone <Tab> */
+	    if (this->cli_cmd.readline == NULL
+		    && this->cli_cmd.gdb != NULL && *(this->cli_cmd.gdb) == NUL)
+		this->oob.state &= ~OS_CMD;
+	}
+	else
+	{
+	    this->cli_cmd.state = CS_START;
+	    *(cmd + 1) = NL;
+	    len = 2;	/* enough room since cmd length not zero */
+	}
+	goto write_answer;
+    }
+
+    /* an interrupt */
+    if (STRCHR(cmd, KEY_INTERUPT) != NULL)
+    {
+	this->intr_sent = TRUE;
+	this->cli_cmd.state = CS_START;
+	goto write_answer;
+    }
+
+    /* a cmd following a completion response by gdb */
+    if (this->cli_cmd.state == CS_DONE && this->cli_cmd.readline != NULL)
+    {
+	/* readline matches start of cmd: send 'user cmd - readline' */
+	if (STRSTR(cmd, this->cli_cmd.readline) == cmd)
+	{
+	    offset = STRLEN(this->cli_cmd.readline);
+	    len -= offset;
+	    do_free = FALSE;
+	}
+	/* no match */
+	else
+	{
+	    /* send KEY_KILL to erase gdb's readline */
+	    gdb_buf[0] = KEY_KILL;
+	    write(this->fd, gdb_buf, 1);
+
+	    /* discard gdb answer:
+	     * '\r' plus the termcap entry 'ce' (clear to end of line) */
+	    l = gdb_read(this, (char_u *)gdb_buf, MAX_BUFFSIZE, 1000);
+
+	    /* do what the discarded stuff above was meant to do:
+	     * replace last line by getting rid of readline */
+	    /* find the rightmost match */
+	    res = NULL;
+	    for (start = this->line; *start != NUL; start++)
+		if ((start = STRSTR(start, this->cli_cmd.readline)) != NULL)
+		    res = start;
+		else
+		    break;
+
+	    if (res != NULL)
+	    {
+		*res = NUL;
+		gdb_write_buf(this, this->line, FALSE);
+	    }
+	    FREE(this->cli_cmd.echoed);
+	}
+    }
+
+    this->cli_cmd.state = CS_START;
+
+    /* a completion request */
+    if (*(cmd + offset + len - 1) == TAB)
+    {
+	this->cli_cmd.state = CS_PENDING;
+
+	xfree(this->cli_cmd.gdb);
+	this->cli_cmd.gdb = (char_u *)clewn_strsave((char *)(cmd + offset));
+	*(this->cli_cmd.gdb + len - 1) = NUL;	/* remove <Tab> */
+    }
+write_answer:
+    if (do_free)
+	FREE(this->cli_cmd.readline);
+    write(this->fd, (char *)cmd + offset, len);
+    xfree(cmd);
+    return;
+}
+
+#  ifdef FEAT_GDB
+#   if defined(MACOS_X) || defined(MACOS_X_UNIX)
+/* Strip terminating carriage return from a line */
+    static void
+strip_cr(line)
+    char_u *line;
+{
+    int len = STRLEN(line);
+
+    if (len != 0 && line[len - 1] == '\r')
+	line[len - 1] = NUL;
+}
+#   endif
+#  endif
+
+#  ifndef FEAT_GDB
+    /* Handle "prompt-for-continue" annotations.
+     * This is not needed by VimGDB as the screen height is very large. */
+#   define MANAGE_PRMPT_FORMORE
+
+     /* The fix for writing through readline the concatenation of multiple
+      * lines output by gdb, is only correctly implemented for clewn */
+#   define FIX_CONCATENATION_WRITE
+#  endif
+/*
+ * Parse gdb output for annotation and completion. Update gdb console.
+ * Return TRUE when the user must be prompted by the input-line window.
+ */
+    int
+gdb_parse_output_cli(this)
+    gdb_T *this;
+{
+#  ifdef FIX_CONCATENATION_WRITE
+    static int pending_write = FALSE;   /* TRUE, this->line content has not been written yet */
+#  endif
+    struct obstack obs;	/* use an obstack for temporary allocated memory */
+    char_u *start;
+    char_u *end;
+    char_u *line;
+    char_u *res;
+    int rc;
+    int len;
+#  ifdef MANAGE_PRMPT_FORMORE
+    int do_newline;
+#  endif
+
+    /* read gdb data */
+    if (this == NULL || ! GDB_STATE(this, GS_UP)
+	    || gdb_read(this, (char_u *)gdb_buf, MAX_BUFFSIZE, 0) <= 0)
+	return FALSE;
+
+    (void)obstack_init(&obs);
+
+    /* Process line after line */
+    for (start = end = (char_u *)gdb_buf; end != NULL; start = end)
+    {
+	/* Get next line */
+	if ((end = STRCHR(start, NL)) != NULL)
+	    *end++ = NUL;
+	else if (*start == NUL) /* nothing left to read */
+	    break;
+
+	/* concatenate with incomplete annotation */
+	if (this->annotation != NULL)
+	{
+	    obstack_strcat(&obs, this->annotation);
+	    obstack_strcat0(&obs, start);
+	    line = (char_u *)obstack_finish(&obs);
+	}
+	else
+	    line = obstack_strsave(&obs, start);
+
+#  ifdef FEAT_GDB
+#   if defined(MACOS_X) || defined(MACOS_X_UNIX)
+	strip_cr(line);
+#   endif
+#  endif
+
+	/* With GDB 6.0, completion giving as a result a long list of items causes
+	 * a "--More--" prompt to be issued after what GDB (or readline) considers
+	 * the height of the terminal (unfortunately not using the GDB height
+	 * settings). In case we could not size the terminal to a very big height
+	 * with an ioctl call in exec_gdb(), we must answer to the prompt. */
+	if (this->height == 0				/* height not set */
+		&& this->cli_cmd.state == CS_CHOICE	/* a completion list */
+		&& end == NULL
+		&& STRCMP(line, "--More--") == 0)	/* standalone prompt */
+	{
+	    write(this->fd, " ", 1);	/* prompt for more */
+	    this->annoted = FALSE;
+	    break;
+	}
+
+#  ifdef FEAT_GDB   /* Clewn does not use hiliting */
+	/* some fuzzy gdb annotation corner: rewrite '(gdb) Quit' so that
+	 * it gets highlited (must be done before the newline stuff) */
+	if (parse_note(this, line) != NULL && this->note == ANO_QUIT)
+	    gdb_write_buf(this, this->line, FALSE);
+#  endif
+
+	/* two consecutive NL: start a new line except when this annotation
+	 * just follows another annotation
+	 * IS_ANNOTATION() does not handle a standalone '\032' */
+	if (this->newline && (*line != '\032' || !this->annoted))
+	{
+#  ifdef MANAGE_PRMPT_FORMORE
+	    do_newline = TRUE;
+
+	    /* do not start a new line when parsing annotations and
+	     *	. the next chunk is a "pre-prompt-for-continue" and
+	     *	  the previous chunk was an annotation
+	     *	. or this is a "pre-prompt-for-continue" annotation */
+	    if (this->mode == GDB_MODE_LVL2
+		    && ! IS_OOBACTIVE(this) && (this->state & GS_ANO))
+	    {
+		if (end != NULL && get_note(this, end) == ANO_PREPMT_FORMORE
+			&& this->prev_note != ANO_NONE)
+		    do_newline = FALSE;
+		if (line != NULL && get_note(this, line) == ANO_PREPMT_FORMORE)
+		    do_newline = FALSE;
+	    }
+
+	    if (do_newline)
+#  endif
+	    {
+		if (this->line == NULL && *line != '\032')
+		{
+		    if (IS_OOBACTIVE(this))
+			gdb_oob_receive(this, (char_u *)"", &obs);
+		    else
+			gdb_write_buf(this, (char_u *)"", TRUE);
+		}
+
+#  ifdef FIX_CONCATENATION_WRITE
+		if (pending_write)
+		    gdb_write_buf(this, this->line, TRUE);
+#  endif
+
+		FREE(this->line);	/* start a new line */
+		this->note = ANO_NONE;
+	    }
+	}
+	this->newline = FALSE;
+
+	/* Parse for annotations */
+	/* we cannot parse "\n\032\032annotation\n" directly
+	 * as any stuff may be split across two buff read;
+	 * must concatenate line when interleaved with annotations */
+	if (*line == NUL)
+	{
+	    /* ignore echoed NL after ANO_PMT_FORMORE msg */
+	    if (this->note != ANO_PMT_FORMORE)
+		this->newline = TRUE;
+
+#  ifdef MANAGE_PRMPT_FORMORE
+	    /* start a new line */
+	    if (this->mode == GDB_MODE_LVL2 && this->prev_note == ANO_POSTPMT_FORMORE)
+	    {
+		FREE(this->line);
+		this->note = ANO_NONE;
+	    }
+#  endif
+	}
+	/* a complete annotation */
+	else if (IS_ANNOTATION(line) && end != NULL)
+	{
+	    /* remember last annotation type */
+	    if (this->note != ANO_PREPMT_FORMORE
+		    && this->note != ANO_PMT_FORMORE
+		    && this->note != ANO_POSTPMT_FORMORE)
+		this->valid_note = this->note;
+
+	    res = parse_note(this, line); /* assert != NULL */
+
+	    if ((res = process_annotation(this, res, &obs)) != NULL)
+	    {
+		gdb_setwinput((gdb_handle_T *)this, res);
+		xfree(res);
+
+		/* fake an interrupt: will empty stuff and typeahead
+		 * buffers aborting insert mode, pending mappings
+		 * and operations */
+		got_int = TRUE;
+	    }
+
+	    FREE(this->annotation);
+	    this->annoted = TRUE;
+
+#  ifdef GDB_LVL2_SUPPORT
+	    /* ANO_DISP_END has no content and must be trapped here */
+	    if (
+#   ifdef FEAT_GDB
+		    this->mode == GDB_MODE_LVL2 && this->var_buf != NULL
+#   else
+		    this->mode == GDB_MODE_LVL2 && this->var_buf > 0
+#   endif
+		    && this->note == ANO_DISP_END)
+	    {
+		gdb_process_display(this, (char_u *)"", &obs);
+	    }
+#  endif
+
+#  ifdef MANAGE_PRMPT_FORMORE
+	    /* start a new line when end of annotation list or table */
+	    if (this->mode == GDB_MODE_LVL2
+		    && this->prev_note == ANO_POSTPMT_FORMORE
+		    && (this->note == ANO_BP_TABLE
+			|| this->note == ANO_BP_RECORD
+			|| this->note == ANO_BP_END
+			|| this->note == ANO_FRAME_END
+			|| this->note == ANO_DISP_END))
+	    {
+		FREE(this->line);	/* start a new line */
+		this->note = ANO_NONE;
+	    }
+#  endif
+
+	    /* store current annotation type */
+	    this->prev_note = this->note;
+
+	    /* restore annotation type */
+	    if (this->note == ANO_POSTPMT_FORMORE)
+		this->note = this->valid_note;
+	}
+	/* a partial annotation */
+	else if (*line == '\032'
+		&& (*(line + 1) == NUL || *(line + 1) == '\032')
+		&& end == NULL)
+	{
+	    xfree(this->annotation);
+	    this->annotation = (char_u *)clewn_strsave((char *)line);
+	    break;
+	}
+	else
+	{
+#  ifdef MANAGE_PRMPT_FORMORE
+	    /* The breakpoint table:
+	     * start a new line when line starts with <TAB>.*/
+	    if (this->mode == GDB_MODE_LVL2
+		    && this->prev_note == ANO_POSTPMT_FORMORE
+		    && line != NULL && *line == TAB)
+	    {
+		FREE(this->line);	/* start a new line */
+		this->note = ANO_NONE;
+	    }
+#  endif
+
+	    if (this->note == ANO_PREPMT_FORMORE)
+	    {
+#  ifdef MANAGE_PRMPT_FORMORE
+		if (! IS_OOBACTIVE(this))
+		{
+		    /* Starting with GDB 6.0, GDB sends an ANO_PREPMT_FORMORE
+		     * whenever ^C have been typed more that gdb_screen_height/2. */
+		    if (this->state & GS_ANO || this->intr_sent)
+		    {
+			write(this->fd, "\n", 1);	/* prompt for more */
+		    }
+		    else
+		    {
+			this->oob.state &= ~OS_CMD;	/* enable next command */
+			xfree(this->prompt);
+			if (line != NULL)
+			    this->prompt = (char_u *)clewn_strsave((char *)line);
+			else
+			    this->prompt = (char_u *)clewn_strsave(
+				"---type <return> to continue, or q <return> to quit---");
+		    }
+		    this->intr_sent = FALSE;
+		}
+#  endif
+		line = NULL;		/* remove ANO_PMT_FORMORE msg */
+	    }
+
+#  ifdef GDB_LVL2_SUPPORT
+	    /* handle a display annotation content
+	     * take care of nested structures and arrays in value content */
+#   ifdef FEAT_GDB
+	    if (this->mode == GDB_MODE_LVL2 && this->var_buf != NULL)
+#   else
+	    if (this->mode == GDB_MODE_LVL2 && this->var_buf > 0)
+#   endif
+	    {
+		if ((this->note >= ANO_DISP_BEG && this->note <= ANO_DISP_END)
+			|| (this->lvl2.doing_value && this->note >= ANO_FIELD_BEG
+			    && this->note <= ANO_FIELD_END)
+			|| (this->lvl2.doing_value && this->note >= ANO_ARRAY_BEG
+			    && this->note <= ANO_ARRAY_END))
+		{
+		    gdb_process_display(this, line, &obs);
+		    line = NULL;
+		}
+	    }
+#  endif
+
+	    if (IS_OOBACTIVE(this))
+	    {
+		gdb_oob_receive(this, line, &obs);
+	    }
+	    else
+	    {
+		if (this->note == ANO_PROMPT || this->note == ANO_CMDS)
+		    gdb_cat(&(this->cli_cmd.echoed), line);
+
+		/* update line cnt before doing cpltn */
+		if (this->line == NULL || !this->annoted)
+		    this->cli_cmd.cnt++;
+
+		/* Parse for completion */
+		if ((res = process_completion( &(this->cli_cmd), line, &obs)) != NULL)
+		{
+		    gdb_setwinput((gdb_handle_T *)this, res);
+		    xfree(res);
+		    got_int = TRUE;
+		}
+
+		if (line != NULL && (len = STRLEN(line)) != 0
+			&& *(line + len - 1) == BELL)
+		    *(line + len - 1) = NUL;
+
+		/* concatenate after an annotation and replace, otherwise add */
+		if (this->line != NULL && this->annoted)
+		{
+		    if (this->note == ANO_ERROR_BEG && STRCMP(line, "Quit") == 0)
+			this->syntax = TRUE;
+
+		    obstack_strcat(&obs, this->line);
+		    obstack_strcat0(&obs, line);
+		    line = (char_u *)obstack_finish(&obs);
+
+#  ifndef FEAT_GDB  /* do not write "(gdb) Quit"  with Clewn (already done) */
+		    if (this->note != ANO_ERROR_BEG)
+#  endif
+		    {
+#  ifdef FIX_CONCATENATION_WRITE
+			/* write a complete line */
+			if (end != NULL)
+			{
+			    if (pending_write)
+				gdb_write_buf(this, line, TRUE);
+			    else
+				gdb_write_buf(this, line, FALSE);
+			}
+#  else
+			gdb_write_buf(this, line, FALSE);
+#  endif
+		    }
+
+		}
+		else
+		{
+#  ifdef FEAT_GDB   /* no need to map T_CE when running Clewn */
+		    /* a completion list */
+		    if (this->height == 0		/* height not set */
+			    && this->cli_cmd.state == CS_CHOICE)
+		    {
+			char_u *ptr;
+
+			/* discard "^\rT_CE\r" which is sent by readline
+			 * after answering to a prompt in a completion list
+			 * (not needed on systems where TIOCSWINSZ ioctls are
+			 * available) */
+			if (STRSTR(line, T_CE) == line + 1
+				&& STRLEN(line) >= STRLEN(T_CE) + 2)
+			{
+			    ptr = line + STRLEN(T_CE) + 2;
+			    line = obstack_strsave(&obs, ptr);
+			}
+		    }
+		    gdb_write_buf(this, line, TRUE);
+#  else
+		    /* do not write the query prompt */
+		    if (this->cli_cmd.state == CS_QUERY)
+			gdb_write_buf(this, (char_u *)"", TRUE);
+		    else
+		    {
+#  ifdef FIX_CONCATENATION_WRITE
+			/* write a complete line */
+			if (end != NULL)
+			{
+			    gdb_write_buf(this, line, TRUE);
+			}
+#  else
+			gdb_write_buf(this, line, TRUE);
+#  endif
+		    }
+#  endif
+		}
+
+		xfree(this->line);
+		this->line = (line != NULL ? (char_u *)clewn_strsave((char *)line) : NULL);
+	    }
+
+#  ifdef FIX_CONCATENATION_WRITE
+	    pending_write = FALSE;
+	    if (end == NULL)	/* incomplete line */
+	    {
+		pending_write = TRUE;
+		this->annoted = TRUE;	/* force concatenation on next read */
+		break;
+	    }
+#  else
+	    if (end == NULL)	/* incomplete line */
+	    {
+		this->annoted = TRUE;	/* force concatenation on next read */
+		break;
+	    }
+#  endif
+	    this->annoted = FALSE;
+	    this->note = ANO_NONE;
+	}
+    }	/* for (...) */
+
+    obstack_free(&obs, NULL);
+
+    if (IS_OOBACTIVE(this))
+	return FALSE;
+
+#  ifdef FEAT_GDB
+    /* redraw gdb console window when displayed */
+    gdb_redraw(this->buf);
+#  endif
+
+    /* Wait till we get the prompt to send the first cmd */
+    if (this->firstcmd != NULL && this->note == ANO_PROMPT)
+    {
+	gdb_docmd((gdb_handle_T *)this, this->firstcmd);
+	FREE(this->firstcmd);
+    }
+
+    if ((rc = gdb_iswinput((gdb_handle_T *)this)) == TRUE)
+	this->oob.state &= ~OS_CMD;
+    return rc;
+}
+
+/*
+ * Process an annotation.
+ * Return cmd to prompt the user with or NULL if none.
+ */
+    static char_u *
+process_annotation(this, str, obs)
+    gdb_T *this;
+    char_u *str;	/* annotation's content */
+    struct obstack *obs;
+{
+    int s_a = (this->state & GS_ALLOWED);
+    char_u *file = NULL;
+    char_u *line = NULL;
+    linenr_T linenumber;
+    char_u *cpn;
+    int bp_number;
+    bpinfo_T *r;
+
+    this->syntax = FALSE;
+    this->parser = PS_ANY;
+
+    switch (this->note)
+    {
+	/* Output end: run directory function */
+	case ANO_PREPROMPT:
+	    this->syntax = TRUE;
+	    this->parser = PS_PREPROMPT;
+	    this->cmd_type = CMD_ANY;
+	    this->state &= ~GS_ANO;
+	    break;
+
+	/* Send out of band cmd */
+	case ANO_PROMPT:
+	    this->syntax = TRUE;
+	    this->parser = PS_PROMPT;
+	    this->cli_cmd.cnt = 1;
+	    FREE(this->cli_cmd.echoed);
+#  ifndef FEAT_GDB	/* store the prompt */
+	    if (! IS_OOBACTIVE(this) || (this->oob.state & OS_INTR))
+	    {
+		xfree(this->prompt);
+		if (this->line != NULL)
+		    this->prompt = (char_u *)clewn_strsave((char *)this->line);
+		else
+		    this->prompt = (char_u *)clewn_strsave("(gdb)   ");
+	    }
+#  endif
+	    if (this->cli_cmd.state == CS_START) {
+		gdb_oob_send(this, obs);
+
+		/* reset the standard oobfunc table after invocation
+		 * of a one function oobfunc array */
+		this->oobfunc = this->std_oobfunc;
+	    }
+	    break;
+
+	case ANO_CMDS:
+	    this->syntax = TRUE;
+	    this->cli_cmd.cnt = 1;
+	    this->oob.state &= ~OS_CMD;
+	    FREE(this->cli_cmd.echoed);
+#  ifndef FEAT_GDB	/* store the prompt */
+	    if (! IS_OOBACTIVE(this) || (this->oob.state & OS_INTR))
+	    {
+		xfree(this->prompt);
+		if (this->line != NULL)
+		    this->prompt = (char_u *)clewn_strsave((char *)this->line);
+		else
+		    this->prompt = (char_u *)clewn_strsave(">  ");
+	    }
+#  endif
+
+	    /* should be in process_completion, but bug in gdb
+	     * annotations where 'pre-commands' is missing in completions */
+	    if (this->cli_cmd.state == CS_CHOICE
+		    && (cpn = eol_choices(&(this->cli_cmd), obs)) != NULL)
+		return cpn;
+
+	    /* a lone <Tab> does not prompt the user except in define mode */
+	    if ((this->cli_cmd.state != CS_PENDING
+			&& this->cli_cmd.state != CS_CHOICE)
+		    || (this->cli_cmd.readline == NULL && this->cli_cmd.gdb != NULL
+			    && *(this->cli_cmd.gdb) == NUL))
+		return (char_u *)clewn_strsave("");
+	    break;
+
+	case ANO_OVERLOAD:
+	case ANO_QUERY:
+	    this->oob.state &= ~OS_CMD;
+#  ifndef FEAT_GDB	/* store the prompt */
+	    if (! IS_OOBACTIVE(this) || (this->oob.state & OS_INTR))
+	    {
+		xfree(this->prompt);
+		if (this->line != NULL)
+		    this->prompt = (char_u *)clewn_strsave((char *)this->line);
+		else
+		    this->prompt = (char_u *)clewn_strsave(">   ");
+	    }
+#  endif
+	    return (char_u *)clewn_strsave("");
+	
+	case ANO_PMT_FORMORE:
+#  ifndef FEAT_GDB	/* handle ANO_PMT_FORMORE when IS_OOBACTIVE */
+	    if (IS_OOBACTIVE(this))
+#  endif
+	    {
+		if (this->oob.state & OS_INTR)
+		{
+		    clewn_beep();
+		    gdb_send_cmd(this, (char_u *)"q\n");	/* abort */
+		}
+		else
+		    gdb_send_cmd(this, (char_u *)"\n");	/* get more lines */
+	    }
+	    break;
+
+	case ANO_QUIT:
+	    this->syntax = TRUE;
+	    this->oob.state |= OS_QUIT;
+	    break;
+
+	case ANO_ERROR_BEG:
+	    this->pool.hilite = FALSE;
+#  ifdef GDB_LVL2_SUPPORT
+	    /* a display expression parse error */
+	    this->lvl2.doing_value = FALSE;
+	    FREE(this->lvl2.dentry.num);
+	    FREE(this->lvl2.dentry.expression);
+	    FREE(this->lvl2.dentry.value);
+#  endif
+#  ifdef GDB_LVL3_SUPPORT
+	    if (this->lvl3.varitem != NULL)
+		this->lvl3.varitem->state |= VS_ERROR;
+#  endif
+	    break;
+
+	case ANO_STARTING:
+	    this->frame_curlvl = -1;
+	    this->frame_lnum = (linenr_T) -1;
+	    FREE(this->frame_fname);
+
+	    FREE(this->frame_pc);
+	    this->state &= ~GS_STOPPED;
+	    gdb_status(this, (char_u *)"running...", obs);
+
+	    if (this->mode == GDB_MODE_LVL3)
+	    {
+		this->pool.hilite = FALSE;
+		if (p_asm != 0 && this->cmd_type == CMD_STEPI)  /* asm frame highlite: when stepi nexti */
+		    this->pool.hilite = TRUE;
+	    }
+	    else
+	    {
+		this->pool.hilite = TRUE;
+	    }
+	case ANO_FRAME_INVALID:
+	    gdb_fr_unlite(this);
+	    this->bp_state |= BPS_FR_INVALID;
+	    break;
+
+	case ANO_BP_INVALID:
+	    /* keep BPS_FR_INVALID state */
+	    this->bp_state &= BPS_FR_INVALID;
+	    this->bp_state |= BPS_INVALID;
+
+	    /* note the fact that the user is setting a 
+	     * breakpoint */
+	    if (p_asm != 0 && this->cmd_type == CMD_BREAK)
+		this->bp_state |= BPS_BP_SET;
+	    break;
+
+	case ANO_STOPPED:
+	    this->state |= GS_STOPPED;
+	    gdb_status(this, (char_u *)"stopped", obs);
+#  ifdef GDB_LVL2_SUPPORT
+#   ifdef FEAT_GDB
+	    if (this->var_buf != NULL)
+#   else
+	    if (this->var_buf > 0)
+#   endif
+		this->lvl2.varlist.state = DSP_STOPPED;
+#  endif
+	    break;
+
+	case ANO_EXITED:
+	case ANO_SIGNALLED:
+	    FREE(this->frame_pc);
+
+	    this->state |= GS_STOPPED;
+	    gdb_status(this, (char_u *)"exited", obs);
+
+#  ifdef FEAT_GDB
+	    /* remove phantom highlite */
+	    gdb_unlite(PHANTOM_SIGN);
+#  endif
+	    break;
+
+	/* Breakpoint hit */
+	case ANO_BREAKPOINT:
+	    /* Look for this breakpoint in bpinfo list */
+	    if (str != NULL && (bp_number = atoi((char *)str)) > 0)
+	    {
+		for (r = this->bpinfo; r != NULL; r = r->next)
+		{
+		    if (r->id == bp_number)
+		    {
+			/* Set this->cont TRUE if this breakpoint's 'commands'
+			 * includes a 'continue' as last statement */
+			if (r->cont)
+			    this->cont = TRUE;
+
+#  ifdef BP_INVALID_ANO_MISSING
+			/* Trigger get_bp(): the breakpoint we hit is
+			 * 'enable once' */
+			if (r->enabled && ! r->disposition)
+			{
+			    /* keep BPS_FR_INVALID state */
+			    this->bp_state &= BPS_FR_INVALID;
+			    this->bp_state |= BPS_INVALID | BPS_BP_HIT;
+			}
+#  endif
+			break;
+		    }
+		}
+
+		/* Not found in the list. An asm buffer holding this bp
+		 * can possibly be disassembled next by oob get_asm().
+		 * Trigger oob get_bp() */
+		if (r == NULL && p_asm != 0)
+		{
+		    /* keep BPS_FR_INVALID state */
+		    this->bp_state &= BPS_FR_INVALID;
+		    this->bp_state |= BPS_INVALID | BPS_BP_HIT;
+		}
+	    }
+	    break;
+
+#  ifdef GDB_LVL2_SUPPORT
+	case ANO_SOURCE:
+	    /* gdb stats the file when doing ANO_SOURCE, so we can't rely on
+	     * that annotation for remote debugging with clewn when the source
+	     * files are on the host and not on the target
+	     * => use ANO_BREAKPOINT instead in level 3
+	     */
+
+	    if (! IS_OOBACTIVE(this) && this->mode == GDB_MODE_LVL2)
+	    {
+		/* Uncomment next line to print source text in gdb buffer */
+		/* gdb_write_buf(this, str, TRUE); */
+
+#   ifdef FEAT_GDB
+		gdb_popup_console(this);
+#   endif
+
+		this->pool.hilite = FALSE;
+
+		/* asm frame highlite: when stepi nexti */
+		if (p_asm != 0 && this->cmd_type == CMD_STEPI)
+		    this->pool.hilite = TRUE;
+		else
+		{
+		    /* prevent recursive calls to parse_output() since breakpoint
+		     * or frame highlighting may cause Vim to query the user when
+		     * changes have been made in the previous buffer */
+		    this->state &= ~GS_ALLOWED;
+
+		    if ((line = gdb_regexec(str, PAT_SOURCE, 2, obs)) != NULL)
+		    {
+			file = gdb_regexec(str, PAT_SOURCE, 1, obs);
+			linenumber = atoi((char *)line);
+			gdb_fr_set(this, file, &linenumber, obs);
+		    }
+
+		    this->state &= ~GS_ALLOWED;
+		    if (s_a)
+			this->state |= GS_ALLOWED;
+		}
+	    }
+	    break;
+
+	case ANO_FRAME_BEGIN:
+	case ANO_BP_HEADER:
+	case ANO_DISP_BEG:
+	    this->state |= GS_ANO;
+	    break;
+
+	case ANO_FRAME_END:
+	case ANO_DISP_END:
+	    break;
+
+	/* Get the source for this frame */
+	case ANO_BP_RECORD:
+	    this->bp_state |= BPS_RECORD;
+	    this->bp_state |= BPS_START;
+	    break;
+
+	case ANO_BP_FIELD0:
+	case ANO_BP_FIELD1:
+	case ANO_BP_FIELD2:
+	case ANO_BP_FIELD3:
+	case ANO_BP_FIELD4:
+	case ANO_BP_FIELD5:
+	case ANO_BP_FIELD6:
+	case ANO_BP_FIELD7:
+	case ANO_BP_FIELD8:
+	case ANO_BP_FIELD9:
+	    this->bp_state = SET_RECORD_IDX(this->bp_state,
+			(this->note - ANO_BP_FIELD0) + BI_NUM);
+	    break;
+
+	case ANO_BP_END:
+	    /* Initialize state but do not forget some of them.
+	     * ANO_BP_END can be the one we get when fetching the
+	     * table with oob function get_lastbp(): get_bp() still
+	     * needs those states */
+	    this->bp_state &= (BPS_INVALID | BPS_BP_HIT | BPS_FR_INVALID);
+	    break;
+#  endif
+    }
+    return NULL;
+}
+
+/*
+ * Parse gdb output for completion.
+ * Return cmd to prompt the user with or NULL if none.
+ */
+    static char_u *
+process_completion(cmd, line, obs)
+    cli_cmd_T *cmd;
+    char_u *line;	/* line to parse */
+    struct obstack *obs;
+{
+    char_u *res;
+    char_u *start;
+    int len;
+
+    if (line == NULL || *line == NUL)
+	return NULL;
+
+    switch (cmd->state)
+    {
+	case CS_PENDING:
+	    /* A completion query */
+	    if (cmd->cnt == 2 && gdb_regexec(line, PAT_QUERY, 0, obs) != NULL)
+	    {
+		cmd->state = CS_QUERY;
+		return (char_u *)clewn_strsave("");
+	    }
+
+	    /* A positive completion */
+	    if (cmd->cnt == 1 && cmd->echoed != NULL
+		    && (len = (cmd->gdb != NULL ? STRLEN(cmd->gdb) : 0)) > 0)
+	    {
+		/* find the rightmost match */
+		res = NULL;
+		for (start = cmd->echoed; *start != NUL; start++)
+		    if ((start = STRSTR(start, cmd->gdb)) != NULL)
+			res = start;
+		    else
+			break;
+
+		/* strictly greater and not followed by NL */
+		if (res != NULL && *(res + len) != NL
+		    && cmd->echoed + STRLEN(cmd->echoed) > res + len)
+		{
+		    if (*(res + len) == BELL)
+		    {
+			clewn_beep();
+			*(res + len) = NUL;
+		    }
+		    xfree(cmd->readline);
+		    cmd->readline = (char_u *)clewn_strsave((char *)cmd->echoed);
+		    cmd->state = CS_DONE;
+		    return (char_u *)clewn_strsave((char *)cmd->readline);
+		}
+	    }
+
+	    /* A BELL: first character */
+	    if (cmd->cnt == 1 && *line == BELL)
+	    {
+		*line = NUL;
+		clewn_beep();
+		cmd->state = CS_DONE;
+		return (cmd->readline != NULL ?
+			(char_u *)clewn_strsave((char *)cmd->readline) : NULL);
+	    }
+
+	    if (cmd->cnt > 1)
+		cmd->state = CS_CHOICE;
+	    break;
+
+	case CS_CHOICE:
+	    /* The end of a list of completion choices */
+	    if (cmd->cnt == 1 && (res = eol_choices(cmd, obs)) != NULL)
+		return res;
+	    break;
+    }
+    return NULL;
+}
+
+/*
+ * The end of a list of completion choices.
+ * Return cmd to prompt the user with.
+ */
+    static char_u *
+eol_choices(cmd, obs)
+    cli_cmd_T *cmd;
+    struct obstack *obs;
+{
+    char_u *new;
+
+    obstack_strcat(obs, cmd->readline);
+    obstack_strcat0(obs, cmd->gdb);
+    new = (char_u *)obstack_finish(obs);
+
+    /* a match with the new readline */
+    if (cmd->echoed != NULL && STRSTR(cmd->echoed, new) == cmd->echoed)
+    {
+	xfree(cmd->readline);
+	cmd->readline = (char_u *)clewn_strsave((char *)cmd->echoed);
+	cmd->state = CS_DONE;
+	return (char_u *)clewn_strsave((char *)cmd->echoed);
+    }
+    return NULL;
+}
+
+#  ifdef GDB_LVL3_SUPPORT
+/* Initialize the gdb_T structure lvl3 component that lvl3 is responsible for */
+    static void
+clear_gdb_T(this)
+    gdb_T *this;
+{
+    varobj_T *item, *next;
+
+    if (this != NULL)
+    {
+	FREE(this->lvl3.result);
+
+	this->lvl3.get_source_list = TRUE;
+	FREE(this->lvl3.source_cur);
+	FREE(this->lvl3.source_list);
+
+	for (item = this->lvl3.varlist; item != NULL; item = next)
+	{
+	    next = item->next;
+	    xfree(item->name);
+	    xfree(item->format);
+	    xfree(item->expression);
+	    xfree(item);
+	}
+	this->lvl3.varlist = NULL;
+	this->lvl3.varitem = NULL;
+    }
+}
+
+/* Initialize lvl3 function pointers */
+    void
+gdb_lvl3_init(this)
+    gdb_T *this;
+{
+    this->mode = GDB_MODE_LVL3;
+    this->oobfunc = oobfunc;
+    this->std_oobfunc = oobfunc;
+    this->parse_output = gdb_parse_output_cli;
+    this->gdb_docmd = gdb_docmd_cli;
+    this->var_delete = NULL;
+    this->clear_gdb_T = clear_gdb_T;
+}
+#  endif /* GDB_LVL3_SUPPORT */
+
+#  ifdef FEAT_GDB
+#   define SG_INTRO_2	"Vim |+gdb| level 2 mode\n\n"
+#   define SG_INTRO_3	"Vim |+gdb| level 3 mode\n\n"
+#  else
+#   define SG_INTRO_2	"...             \
+                        \n... Clewn running GDB in level 2 mode\n...\n"
+#   define SG_INTRO_3	"...             \
+                        \n... Clewn %s running GDB in level 3 mode\n...\n"
+#  endif
+#  define SG_INTERP	"server interpreter-exec mi -gdb-version\n"
+#  define SG_LVL_2	"server set annotate 2\n"
+#  define SG_LVL_3	"server set annotate 3\n"
+#  define SG_HEIGHT	"server set height "
+#  define SG_WIDTH	"server set width 0\n "
+#  define SG_EDITING	"server set editing on\n"
+#  define SG_VERSION	"server show version\n"
+
+/* SG_TIMEOUT must be quite big as we may have Clewn, Vim and GDB all
+ * starting at the same time. Unless things go pretty bad in the parsing, we
+ * always find the needle, so the user never wait SG_TIMEOUT. */
+#  define SG_TIMEOUT 120000 /* msecs for when the needle cannot be found */
+/*
+ * Initialize gdb CLI (command line interface)
+ * return OK when sucess, FAIL otherwise
+ */
+    int
+gdb_setup_cli(this)
+    gdb_T *this;
+{
+    char *err     = NULL;
+    int needle    = FALSE;	/* defines when we can start writing to gdb console */
+    int gdb_cnt   = 0;		/* count of received "(gdb)" prompts */
+    int lvl3_mode = FALSE;	/* level */
+    char_u *buff  = (char_u *)gdb_buf;/* can't add an int to the reference to an array */
+    char * tty_name = NULL;
+#   ifndef FEAT_GDB
+    char tmp[128];
+#   endif
+    char_u *last;
+    char_u *ptr;
+    char_u *lpp_lines;
+    char_u *line;
+    int len;
+
+    this->note = ANO_NONE;
+
+    /* Does this GDB process supports "interpreter-exec" command ?
+     * if yes we will use level 3 mode, otherwise level 2 mode */
+    write(this->fd, SG_INTERP, strlen(SG_INTERP));
+
+    /* discard gdb output till we find the needle SG_VERSION
+     * MAX_BUFFSIZE must be greater than max gdb line length */
+    for (last = (char_u *)gdb_buf; buff + MAX_BUFFSIZE - last > 1; )
+    {
+	if ((len = gdb_read(this, last,
+			buff + MAX_BUFFSIZE - last, SG_TIMEOUT)) < 0)
+	{
+	    err = "Unable to read from GDB pseudo tty";
+	    goto fail;
+	}
+	else if (len == 0)	/* needle not found */
+	    break;
+
+	last += len;
+	ptr = (char_u *)gdb_buf;
+
+	/* First step: determine which level, process line by line */
+	do
+	{
+	    if (gdb_cnt >= 2)
+		break;
+
+            if (*ptr == NL)
+                ptr++;
+
+	    if (STRSTR(ptr, "^done") == ptr)
+		lvl3_mode = TRUE;
+
+	    /* the first prompt is newline terminated (count it only once) */
+	    if (STRSTR(ptr, "(gdb) ") == ptr
+		    && (gdb_cnt == 1 || STRCHR(ptr, NL) != NULL))
+		gdb_cnt++;
+
+	    if (gdb_cnt == 2)
+	    {
+#  ifdef GDB_LVL3_SUPPORT
+		/* set annotation level 3 */
+		if (lvl3_mode)
+		    write(this->fd, SG_LVL_3, strlen(SG_LVL_3));
+		else
+#   ifdef GDB_LVL2_SUPPORT
+		    write(this->fd, SG_LVL_2, strlen(SG_LVL_2));
+#   else
+		{
+		    err = "This |+gdb| version does not support level 2 mode";
+		    goto fail;
+		}
+#   endif
+#  else /* LVL3 */
+		lvl3_mode = FALSE;
+#   ifdef GDB_LVL2_SUPPORT
+		/* set annotation level 2 */
+		if (! lvl3_mode)
+		    write(this->fd, SG_LVL_2, strlen(SG_LVL_2));
+#   endif
+#  endif /* LVL3 */
+
+#  ifdef FEAT_GDB   /* Clewn does not need this */
+		/* ANO_PMT_FORMORE happen every LPP_LINES and provide us a mean to abort
+		 * large output (in get_asm for example or any user cmd) */
+		write(this->fd, SG_HEIGHT, strlen(SG_HEIGHT));
+		lpp_lines = gdb_itoa(LPP_LINES);
+		write(this->fd, (char *)lpp_lines, strlen((char *)lpp_lines));
+		write(this->fd, "\n", 1);
+		write(this->fd, SG_WIDTH, strlen(SG_WIDTH));
+		write(this->fd, SG_EDITING, strlen(SG_EDITING));
+#  else
+		/* number of lines in a page is unlimited */
+		write(this->fd, SG_HEIGHT, strlen(SG_HEIGHT));
+		lpp_lines = gdb_itoa(0);
+		write(this->fd, lpp_lines, strlen(lpp_lines));
+		write(this->fd, "\n", 1);
+		write(this->fd, SG_WIDTH, strlen(SG_WIDTH));
+		write(this->fd, SG_EDITING, strlen(SG_EDITING));
+		write(this->fd, " \n", 2); /* avoid Undefined command: "server".  Try "help". */
+
+		/* `run' commands do input and output on clewn own terminal when possible */
+		if (isatty(1) && (tty_name=ttyname(1)) != NULL) {
+		    char_u * res = NULL;
+
+		    gdb_cat(&res, (char_u *)"server tty ");
+		    gdb_cat(&res, tty_name);
+		    gdb_cat(&res, (char_u *)"\n");
+		    write(this->fd, res, STRLEN(res));
+		    xfree(res);
+		}
+#  endif
+		write(this->fd, SG_VERSION, strlen(SG_VERSION));
+	    }
+	} while ((ptr = STRCHR(ptr, NL)) != NULL);
+
+	/* Second step: find the needle, process line by line */
+	do
+	{
+	    if (ptr == NULL)
+		break;
+
+            if (*ptr == NL)
+                ptr++;
+
+	    /* looking for the needle after a prompt */
+	    if (this->note == ANO_PROMPT && STRSTR(ptr, SG_VERSION) == ptr)
+	    {
+		ptr += strlen(SG_VERSION);
+		needle = TRUE;
+	    }
+
+	    /* discard post-prompt */
+	    if (needle && this->note == ANO_POSTPROMPT)
+	    {
+		/* store a partial last line for later parse_output */
+                if ((line = (char_u *)strrchr(gdb_buf, (int)NL)) != NULL
+                        && *(line + 1) != NUL)
+                {
+                    xfree(this->line);
+                    this->line = (char_u *)clewn_strsave((char *)(line + 1));
+                    this->annoted = TRUE;
+                }
+
+		if (lvl3_mode)
+#  ifdef GDB_LVL3_SUPPORT
+		{
+#   ifdef FEAT_GDB
+		    gdb_popup_console(this);
+#   endif
+
+		    this->syntax = TRUE;	/* force syntax highlite */
+#   ifdef FEAT_GDB
+		    gdb_write_buf(this, (char_u *)SG_INTRO_3, TRUE);
+#   else
+		    sprintf(tmp, SG_INTRO_3, this->version);
+		    gdb_write_buf(this, tmp, TRUE);
+#   endif
+		    this->syntax = FALSE;
+
+#   ifdef FEAT_GDB  /* write unconditionally with Clewn */
+		    /* write the remaining part and display it */
+		    if (*ptr != NUL)
+#   endif
+			gdb_write_buf(this, ptr, TRUE);
+
+#   ifdef FEAT_GDB
+		    /* redraw gdb console window when displayed */
+		    gdb_redraw(this->buf);
+#   endif
+
+		    gdb_lvl3_init(this);
+		}
+#  else
+		{
+		    err = "This |+gdb| version does not support level 3 mode";
+		    goto fail;
+		}
+#  endif
+		else
+#  ifdef GDB_LVL2_SUPPORT
+		{
+#   ifdef FEAT_GDB
+		    gdb_popup_console(this);
+#   endif
+
+		    this->syntax = TRUE;	/* force syntax highlite */
+		    gdb_write_buf(this, (char_u *)SG_INTRO_2, TRUE);
+		    this->syntax = FALSE;
+
+#   ifdef FEAT_GDB   /* write unconditionally with Clewn */
+		    /* write the remaining part and display it */
+		    if (*ptr != NUL)
+#   endif
+			gdb_write_buf(this, ptr, TRUE);
+
+#   ifdef FEAT_GDB
+		    /* redraw gdb console window when displayed */
+		    gdb_redraw(this->buf);
+#   endif
+
+		    gdb_lvl2_init(this);
+		}
+#  else
+		{
+		    err = "This |+gdb| version does not support level 2 mode";
+		    goto fail;
+		}
+#  endif
+		if (tty_name)
+		    fprintf(stderr, "`run' commands do input and output on the terminal %s\n", tty_name);
+
+		return OK;
+	    }
+	} while ((ptr = parse_note(this, ptr)) != NULL);
+
+	/* left shift buffer to last start of line */
+	if ((ptr = (char_u *)strrchr((char *)gdb_buf, (int)NL)) != NULL)
+	{
+	    len = STRLEN(ptr + 1);
+	    clewn_memmove(gdb_buf, ptr + 1, len);
+	    last = (char_u *)gdb_buf + len;
+	}
+    }
+
+#  ifdef GDB_LVL2_SUPPORT
+    /* could not find the needle: hope for the best and fall back 
+     * to annotation level 2 and send version again */
+    write(this->fd, SG_LVL_2, strlen(SG_LVL_2));
+    write(this->fd, SG_VERSION, strlen(SG_VERSION));
+#   ifdef FEAT_GDB
+    gdb_popup_console(this);
+#   endif
+
+    this->syntax = TRUE;	/* force syntax highlite */
+    gdb_write_buf(this, (char_u *)SG_INTRO_2, TRUE);
+    this->syntax = FALSE;
+
+    gdb_lvl2_init(this);
+    return OK;
+#  else
+    err = "This |+gdb| version does not support level 2 mode";
+    goto fail;
+#  endif
+fail:
+    gdb_close(this);
+
+    if (err != NULL)
+	EMSG(_(err));
+
+    return FAIL;
+}
+
+#  ifdef GDB_LVL3_SUPPORT
+/* Print a value in a netbeans balloon */
+#   define PRINT_VALUE	    "^done,value=\""
+    char *
+gdb_print_value(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+#   ifdef HAVE_CLEWN
+    char_u * res = NULL;
+    char_u * ptr;
+    char_u * quote;
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    if (this->balloon_txt != NULL) {
+		obstack_strcat(obs, "server interpreter-exec mi \"-data-evaluate-expression ");
+		obstack_strcat(obs, this->balloon_txt);
+		obstack_strcat0(obs, "\"\n");
+
+		FREE(this->lvl3.result);
+		return (char_u *)obstack_finish(obs);
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.result);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.result);
+	    this->lvl3.result = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    if (this->lvl3.result != NULL
+		    && (ptr = STRSTR(this->lvl3.result, PRINT_VALUE)) != NULL
+		    && (ptr += strlen(PRINT_VALUE))
+		    && (quote = (char_u *)strrchr(ptr, '"')) != NULL)
+	    {
+		*quote = NUL;
+		obstack_strcat(obs, "\" ");
+		obstack_strcat(obs, this->balloon_txt);
+		obstack_strcat(obs, " = ");
+		obstack_strcat(obs, ptr);
+		obstack_strcat0(obs, " \"");
+
+		res = (char_u *)obstack_finish(obs);
+		gdb_showBalloon(res, obs);
+	    }
+
+	    FREE(this->balloon_txt);
+	    FREE(this->lvl3.result);
+	    break;
+    }
+#   endif   /* HAVE_CLEWN*/
+    return NULL;
+}
+#  endif    /* GDB_LVL3_SUPPORT */
+
+/* Get instruction at $pc */
+    char *
+gdb_get_pc(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u *ptr;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    FREE(this->pc);
+
+	    if (this->state & GS_STOPPED)
+	    {
+		this->state &= ~GS_STOPPED;
+		return "server x/i $pc\n";
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    if ((this->pc = gdb_regexec(line, PAT_ADD, 1, NULL)) != NULL)
+	    {
+		/* Replace TAB with a space */
+		for (ptr = line; *ptr != NUL; ptr++)
+		    if (*ptr == TAB)
+			*ptr = ' ';
+
+		gdb_status(this, line, obs);
+	    }
+	    break;
+    }
+    return NULL;
+}
+
+/* Get frame info */
+    char *
+gdb_get_frame(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u *res = NULL;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    FREE(this->oob_result);
+	    return "server frame\n";
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->oob_result);
+	    gdb_cat(&res, line);
+	    xfree(this->oob_result);
+	    this->oob_result = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    xfree(this->frame_pc);
+	    if (this->oob_result != NULL
+		    && (this->frame_pc = gdb_regexec(this->oob_result, PAT_FRAME, 1, NULL)) != NULL) {
+		xfree(this->asm_add);
+		this->asm_add = (char_u *)clewn_strsave((char *)this->frame_pc);
+	    }
+	    else {
+		if (this->pc != NULL) {
+		    this->frame_pc = (char_u *)clewn_strsave((char *)this->pc);
+		    xfree(this->asm_add);
+		    this->asm_add = (char_u *)clewn_strsave((char *)this->frame_pc);
+		}
+	    }
+
+	    FREE(this->oob_result);
+	    break;
+    }
+    return NULL;
+}
+
+#  ifdef GDB_LVL3_SUPPORT
+/* Stack info frame */
+    char *
+gdb_info_frame(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u *res = NULL;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    FREE(this->lvl3.result);
+	    return "server info frame\n";
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.result);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.result);
+	    this->lvl3.result = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    this->frame_curlvl = -1;
+	    if (this->lvl3.result != NULL
+		    && (res = gdb_regexec(this->lvl3.result, PAT_INFO_FRAME, 1, NULL)) != NULL) {
+		this->frame_curlvl = atoi((char *)res);
+		xfree(res);
+	    }
+
+	    FREE(this->lvl3.result);
+	    break;
+    }
+    return NULL;
+}
+
+#   define SOURCE_FILENAME  "\",file=\""
+#   define SOURCE_LINENUM   "\",line=\""
+/* Change frame highlight according to new frame level */
+    char *
+gdb_stack_frame(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u * res = NULL;
+    int rc	 = -1;
+    char tmp[32];
+    char_u * fname;
+    char_u * pnum;
+    char_u * quote;
+    char_u * ptr;
+    linenr_T lnum;
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    /* get info about frame_curlvl:
+	     * ^done,stack=[frame={level="1",addr="0x080483bb",func="main",file="cltest_main.c",line="12"}] */
+	    if (this->frame_curlvl >= 0) {
+		FREE(this->lvl3.result);
+
+		sprintf(tmp, "%d %d", this->frame_curlvl, this->frame_curlvl);
+		obstack_strcat(obs, "server interpreter-exec mi \"-stack-list-frames ");
+		obstack_strcat(obs, tmp);
+		obstack_strcat0(obs, "\"\n");
+		return (char *)obstack_finish(obs);
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.result);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.result);
+	    this->lvl3.result = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    if (this->lvl3.result != NULL
+		    && (ptr = STRSTR(this->lvl3.result, SOURCE_FILENAME)) != NULL
+		    && (pnum = STRSTR(this->lvl3.result, SOURCE_LINENUM)) != NULL)
+	    {
+		pnum += strlen(SOURCE_FILENAME);
+		lnum = atoi((char *)pnum);
+
+		ptr += strlen(SOURCE_FILENAME);
+
+		if ((quote = STRCHR(ptr, '"')) != NULL) {
+		    fname = (char_u *)obstack_copy0(obs, ptr, (quote - ptr));
+
+		    rc = 0;
+
+		    /* set frame sign only if this is a new fname/lnum position */
+		    if (this->frame_fname == NULL
+			    || STRCMP(this->frame_fname, fname) != 0 || this->frame_lnum != lnum) {
+			FREE(this->frame_fname);
+			this->frame_fname = (char_u *)clewn_strsave((char *)fname);
+			this->frame_lnum = lnum;
+			rc = gdb_fr_set(this, fname, &lnum, obs);
+		    }
+		}
+	    }
+
+	    if (rc != 0 && p_asm != 0)
+		this->pool.hilite = TRUE;   /* do asm frame highliting */
+	    FREE(this->lvl3.result);
+	    break;
+    }
+    return NULL;
+}
+#  endif /* GDB_LVL3_SUPPORT */
+
+/* Get symbol file name */
+    char *
+gdb_get_sfile(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u *res = NULL;
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    return "server info target\n";
+
+	case OOB_COLLECT:
+	    if (this->oob.cnt == 1
+		    && (res = gdb_regexec(line, PAT_SFILE, 1, obs)) != NULL
+		    && (this->sfile == NULL || STRCMP(res, this->sfile) != 0))
+	    {
+		gdb_status(this, (char_u *)"new symbols", obs);
+		xfree(this->sfile);
+		this->sfile = (char_u *)clewn_strsave((char *)res);
+	    }
+	    break;
+
+	case OOB_COMPLETE:
+	    if (this->oob.cnt == 0)
+	    {
+		gdb_status(this, (char_u *)"empty target", obs);
+		FREE(this->sfile);
+	    }
+	    break;
+    }
+    return NULL;
+}
+
+/* Get GDB source directories */
+    char *
+gdb_get_sourcedir(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u *res = NULL;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    FREE(this->lvl3.result);
+	    return "server show directories\n";
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.result);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.result);
+	    this->lvl3.result = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    if (this->lvl3.result != NULL)
+	    {
+		xfree(this->directories);
+		this->directories = gdb_regexec(this->lvl3.result, PAT_DIR, 1, NULL);
+		FREE(this->lvl3.result);
+	    }
+	    break;
+    }
+    return NULL;
+}
+
+#ifdef GDB_LVL3_SUPPORT
+# ifndef FEAT_GDB
+/* Source the project file */
+    char *
+gdb_source_project(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    switch(state)
+    {
+	case OOB_CMD:
+	    if (this->project_file != NULL
+		    && cnb_state()
+		    && this->project_state == PROJ_SOURCEIT)
+	    {
+		this->project_state = PROJ_DONE;
+		fprintf(stderr, "source %s\n", this->project_file);
+
+		if (this->sfile != NULL)
+		    fprintf(stderr, "Warning: symbol table \"%s\" was loaded before sourcing the project file\n", this->sfile);
+
+		obstack_strcat(obs, "server source ");
+		obstack_strcat(obs, this->project_file);
+		obstack_strcat0(obs, "\n");
+		return (char_u *)obstack_finish(obs);
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    if (line != NULL)
+		fprintf(stderr, "%s\n", line);
+	    break;
+
+	case OOB_COMPLETE:
+	    /* force getting the source file list from gdb */
+	    this->lvl3.get_source_list = TRUE;
+
+	    /* this is required after 'restart' to display the gdb prompt */
+	    fprintf(stderr, this->prompt);
+	    break;
+    }
+
+    return NULL;
+}
+
+#   define CWD_VALUE	"^done,cwd=\""
+/* Get current working directory */
+    char *
+gdb_get_pwd(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u * res = NULL;
+    char_u * ptr;
+    char_u * quote;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    if (this->mode != GDB_MODE_LVL2) {
+		FREE(this->lvl3.result);
+		return "server interpreter-exec mi \"-environment-pwd\"\n";
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.result);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.result);
+	    this->lvl3.result = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    if (this->lvl3.result != NULL
+		    && (ptr = STRSTR(this->lvl3.result, CWD_VALUE)) != NULL
+		    && (ptr += strlen(CWD_VALUE))
+		    && (quote = (char_u *)strrchr(ptr, '"')) != NULL)
+	    {
+		*quote = NUL;
+		gdb_cat(&res, (char_u *)"cd ");
+		gdb_cat(&res, ptr);
+		gdb_cat(&res, (char_u *)"\n");
+		xfree(this->pwd);
+		this->pwd = res;
+	    }
+
+	    FREE(this->lvl3.result);
+	    break;
+    }
+    return NULL;
+}
+
+#   define ARGS_VALUE	"Argument list to give program being debugged when it is started is \""
+/* Get args */
+    char *
+gdb_get_args(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u * res = NULL;
+    char_u * ptr;
+    char_u * quote;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    FREE(this->lvl3.result);
+	    return "server show args\n";
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.result);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.result);
+	    this->lvl3.result = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    if (this->lvl3.result != NULL
+		    && (ptr = STRSTR(this->lvl3.result, ARGS_VALUE)) != NULL
+		    && (ptr += strlen(ARGS_VALUE))
+		    && (quote = (char_u *)strrchr(ptr, '"')) != NULL)
+	    {
+		*quote = NUL;
+		gdb_cat(&res, "set args ");
+		gdb_cat(&res, ptr);
+		gdb_cat(&res, "\n");
+		xfree(this->args);
+		this->args = res;
+	    }
+
+	    FREE(this->lvl3.result);
+	    break;
+    }
+    return NULL;
+}
+# endif
+
+/* Get GDB current source file */
+    char *
+gdb_source_cur(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u *res = NULL;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    FREE(this->lvl3.source_cur);
+	    return "server interpreter-exec mi \"-file-list-exec-source-file\"\n";
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.source_cur);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.source_cur);
+	    this->lvl3.source_cur = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    break;
+    }
+    return NULL;
+}
+
+/* Get GDB current source file */
+    char *
+gdb_source_list(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u *res = NULL;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    switch(state)
+    {
+	case OOB_CMD:
+	    if (this->lvl3.get_source_list || this->lvl3.source_list == NULL) {
+		FREE(this->lvl3.source_list);
+		this->lvl3.get_source_list = FALSE;
+		return "server interpreter-exec mi \"-file-list-exec-source-files\"\n";
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.source_list);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.source_list);
+	    this->lvl3.source_list = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    break;
+    }
+    return NULL;
+}
+#endif /* GDB_LVL3_SUPPORT */
+
+#  ifdef GDB_LVL3_SUPPORT
+#   define BKPT_RECORD	"bkpt={number=\""
+#   define BKPT_ADDR	"\",addr=\""
+/*
+ * When a breakpoint is being set and asm option is on, get the
+ * instruction address of the last breakpoint, the one being set.
+ * This address is used in get_asm() to disassemble the function
+ * containing this address.
+ */
+    static char *
+get_lastbp(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u *res    = NULL;
+    int found      = FALSE;
+    char_u *record = NULL;
+    char_u *ptr;
+    char_u *addr;
+    bpinfo_T *p;
+    int bp_num;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    switch (state)
+    {
+	case OOB_CMD:
+	    /* GDB sends sometimes ANO_BP_INVALID when stepping, even
+	     * though no breakpoints have been changed.
+	     * Avoid checking for last bp in this case, because this
+	     * may cause hiliting a bp in a new buffer when what is
+	     * expected is a new frame */
+	    if (this->bp_state & BPS_FR_INVALID)
+		return NULL;
+
+	    /* A breakpoint is being set in assembly */
+	    if (p_asm != 0 && (this->bp_state & BPS_INVALID)
+		    && (this->bp_state & BPS_BP_SET))
+	    {
+		this->bp_state &= ~BPS_BP_SET;
+		FREE(this->lvl3.result);
+
+		/* fetch GDB bp table info */
+		return "server interpreter-exec mi -break-list\n";
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.result);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.result);
+	    this->lvl3.result = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    if ((ptr = this->lvl3.result) != NULL)
+	    {
+		/* search for last record in breakpoint table */
+		do
+		{
+		    if ((ptr = STRSTR(ptr, BKPT_RECORD)) != NULL)
+		    {
+			record = ptr;
+			ptr++;
+		    }
+		}
+		while (ptr != NULL);
+
+		/* last record */
+		if (record != NULL
+			&& (bp_num = atoi((char *)(record + strlen(BKPT_RECORD)))) > 0)
+		{
+		    /* look it up in bpinfo list */
+		    for (p = this->bpinfo; p != NULL; p = p->next)
+		    {
+			if (bp_num == p->id)
+			{
+			    found = TRUE;
+			    break;
+			}
+		    }
+
+		    /* not found: set asm_add so that get_asm will
+		     * do the disassembling */
+		    if (! found && (addr = STRSTR(record, BKPT_ADDR)) != NULL)
+		    {
+			xfree(this->asm_add);
+			this->asm_add =
+			    gdb_regexec(addr + strlen(BKPT_ADDR), PAT_ADD, 1, NULL);
+		    }
+		}
+
+		FREE(this->lvl3.result);
+	    }
+	    break;
+    }
+    return NULL;
+}
+#  endif /* GDB_LVL3_SUPPORT */
+
+/* Get the function name corresponding to asm_add */
+    char *
+gdb_get_asmfunc(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    switch(state)
+    {
+	case OOB_CMD:
+	    if (this->asm_add != NULL)
+	    {
+		obstack_strcat(obs, "server info symbol 0x");
+		obstack_strcat(obs, this->asm_add);
+		obstack_strcat0(obs, "\n");
+		return (char *)obstack_finish(obs);
+	    }
+	    FREE(this->asm_func);
+	    break;
+
+	case OOB_COLLECT:
+	    xfree(this->asm_func);
+	    this->asm_func = gdb_regexec(line, PAT_ASM_FUNC, 1, NULL);
+	    break;
+    }
+    return NULL;
+}
+
+/*
+ * This function is a hack to fix errors occuring in GDB command
+ * "info symbol ADDR" that sometimes cannot find the symbol corresponding to
+ * a given ADDR, when GDB command "print/a ADDR" can.
+ * "print/a ADDR" is used as a last resort because it changes the value history.
+ * "output/a ADDR" does not change the value history, but the output of this
+ * command misses a newline.
+ */
+    char *
+gdb_get_asmfunc_hack(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    switch(state)
+    {
+	case OOB_CMD:
+	    if (this->asm_add != NULL && this->asm_func == NULL)
+	    {
+		obstack_strcat(obs, "server print/a 0x");
+		obstack_strcat(obs, this->asm_add);
+		obstack_strcat0(obs, "\n");
+		return (char *)obstack_finish(obs);
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    xfree(this->asm_func);
+	    this->asm_func = gdb_regexec(line, PAT_ASM_FUNC_P, 1, NULL);
+	    break;
+    }
+    return NULL;
+}
+
+#  define ASM_ABORTED "DISASSEMBLY ABORTED"
+
+/*
+ * Disassemble new function containing asm_add and highlight asm_add
+ * if this->pool.hilite is TRUE
+ */
+    char *
+gdb_get_asm(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+#  ifdef FEAT_GDB
+{
+    buf_T *buf = this->pool.buf[this->pool.idx];
+    buf_T *oldbuf = curbuf;
+    char_u *res = NULL;
+    int oldest  = 0;
+    int age	= 0;
+    linenr_T lnum;
+    win_T *win;
+    int i;
+
+    if (p_asm == 0)
+    {
+	FREE(this->asm_add);
+	return NULL;
+    }
+
+    lnum = (buf != NULL ? BUFLASTL(buf) : 0);
+
+    switch (state)
+    {
+	case OOB_CMD:
+	    if (this->asm_add != NULL && !gdb_as_frset(this, obs))
+	    {
+		/* pickup least recent buffer */
+		for (i = this->pool.max; i > 0; )
+		{
+		    i--;
+		    if (this->pool.age[i] >= age && this->pool.buf[i] != NULL)
+		    {
+			age = this->pool.age[i];
+			oldest = i;
+		    }
+		}
+
+		/* no buffers in pool */
+		if ((buf = this->pool.buf[oldest]) == NULL)
+		{
+		    this->pool.hilite = FALSE;
+		    FREE(this->asm_add);
+		    return NULL;
+		}
+		this->pool.idx = oldest;
+
+		/* clear the buffer */
+		gdb_clear_asmbuf(this, buf);
+
+		/* init msg_busy */
+		obstack_strcat(obs, "Disassembling 0x");
+		obstack_strcat0(obs, this->asm_add);
+		res = (char_u *)obstack_finish(obs);
+		gdb_msg_busy(res);
+
+		/* send cmd */
+		obstack_strcat(obs, "server disassemble 0x");
+		obstack_strcat(obs, this->asm_add);
+		obstack_strcat0(obs, "\n");
+		return (char *)obstack_finish(obs);
+	    }
+	    this->pool.hilite = FALSE;
+	    break;
+
+	case OOB_COLLECT:
+	    if (buf == NULL)
+		return NULL;
+	    curbuf = buf;
+
+	    /* concatenate with line after an annotation
+	     * and replace line, otherwise add */
+	    if (this->line != NULL && this->annoted)
+	    {
+		obstack_strcat(obs, this->line);
+		obstack_strcat0(obs, line);
+		line = (char_u *)obstack_finish(obs);
+		ml_delete(lnum--, FALSE);
+	    }
+
+	    /* first line: remove empty line after the inserted one */
+	    if (ml_append(lnum, line, 0, 0) == OK && lnum == 0)
+		ml_delete(buf->b_ml.ml_line_count, FALSE);
+	    curbuf = oldbuf;
+
+	    if ((this->oob.cnt % 1000) == 0)
+		gdb_msg_busy(NULL);
+
+	    xfree(this->line);
+	    this->line = (char_u *)clewn_strsave((char *)line);
+	    break;
+
+	case OOB_COMPLETE:
+	    if (buf == NULL)
+		return NULL;
+	    curbuf = buf;
+
+	    if (this->oob.state & OS_INTR)
+	    {
+		if (lnum >= 1 && STRCMP(ASM_ABORTED, ml_get(1)) != 0)
+		{
+		    /* Clear buffer when interrupted */
+		    while (lnum-- > 0)
+			ml_delete(buf->b_ml.ml_line_count, FALSE);
+
+		    ml_append(0, (char_u *)ASM_ABORTED, 0, 0);
+		    lnum = buf->b_ml.ml_line_count;
+		    changed_lines(1, 0, lnum, lnum);
+		    curbuf = oldbuf;
+
+		    this->pool.age[this->pool.idx] = ASM_OLD;
+		    gdb_edit_file(this, buf, NULL, 1, obs);
+		}
+
+		/* write the prompt */
+		gdb_write_buf(this, this->line, TRUE);
+		gdb_redraw(buf);
+	    }
+	    else
+	    {
+		changed_lines(1, 0, lnum, lnum);
+
+		/* set buffer name to function name */
+		if (this->asm_func != NULL)
+		{
+		    obstack_strcat(obs, this->asm_func);
+		    obstack_strcat0(obs, "-asm");
+		    res = (char_u *)obstack_finish(obs);
+		    gdb_as_setname(res);
+		}
+		curbuf = oldbuf;
+
+		/* highlite $asm_add and update window if displayed */
+		if (! gdb_as_frset(this, obs) && (win = gdb_btowin(buf)) != NULL)
+		{
+		    gdb_set_cursor(win, 1);
+		    redraw_win_later(win, NOT_VALID);
+		}
+	    }
+
+	    msg_clr_cmdline();
+	    FREE(this->asm_add);
+	    this->pool.hilite = FALSE;
+	    break;
+    }
+    return NULL;
+}
+#  else
+{
+    char_u *res  = NULL;
+    char_u *fname;
+
+    if (p_asm == 0)
+    {
+	FREE(this->asm_add);
+	return NULL;
+    }
+
+    switch (state)
+    {
+	case OOB_CMD:
+	    if (this->asm_add != NULL && ! gdb_as_frset(this, obs))
+	    {
+		FREE(this->pool.name);
+
+		/* get a unique file name for this disassembled function
+		 * and open the file for creation
+		 * the file name suffix is '.clasm' so that it can be set
+		 * to 'autoread' by the runtime file clewn.vim */
+		if (this->asm_func != NULL) {
+		    obstack_strcat(obs, this->asm_func);
+		    obstack_strcat0(obs, ".clasm");
+		    fname = (char_u *)obstack_finish(obs);
+		}
+		if (this->asm_func == NULL || (this->pool.fd = clewn_opentmpfile(fname,
+			&(this->pool.name), 1)) == NULL)
+		{
+		    this->pool.hilite = FALSE;
+		    return NULL;
+		}
+		this->pool.line_offset = 0L;
+
+		/* create the buffer */
+		if ((this->pool.buf = cnb_create_buf(this->pool.name)) == -1)
+		{
+		    this->pool.hilite = FALSE;
+
+		    fclose(this->pool.fd);
+		    this->pool.fd = NULL;
+		    if (this->pool.name != NULL)
+			(void)unlink(this->pool.name);
+		    FREE(this->pool.name);
+		    return NULL;
+		}
+
+		/* init msg_busy */
+		obstack_strcat(obs, "Disassembling 0x");
+		obstack_strcat0(obs, this->asm_add);
+		res = (char_u *)obstack_finish(obs);
+		gdb_msg_busy(res);
+
+		/* send cmd */
+		this->lastline = 0;
+		obstack_strcat(obs, "server disassemble 0x");
+		obstack_strcat(obs, this->asm_add);
+		obstack_strcat0(obs, "\n");
+		return (char_u *)obstack_finish(obs);
+	    }
+	    this->pool.hilite = FALSE;
+	    break;
+
+	case OOB_COLLECT:
+	    if (this->pool.fd == NULL)
+		goto fail;
+
+	    /* ignore when interrupted */
+	    if (this->oob.state & OS_INTR)
+		return NULL;
+
+	    /* concatenate with line after an annotation
+	     * and replace line, otherwise add */
+	    if (this->line != NULL && this->annoted)
+	    {
+		obstack_strcat(obs, this->line);
+		obstack_strcat0(obs, line);
+		line = (char_u *)obstack_finish(obs);
+
+		this->lastline--;
+		if (fseek(this->pool.fd, this->pool.line_offset, SEEK_SET) != 0)
+		    goto fail;
+	    }
+
+	    /* write a newline except at first line */
+	    if (this->lastline != 0)
+	    {
+		if ((this->pool.line_offset = ftell(this->pool.fd)) == -1
+			|| fputs("\n", this->pool.fd) < 0)
+		    goto fail;
+	    }
+	    this->lastline++;
+
+	    /* write the line */
+	    if (fputs(line, this->pool.fd) < 0)
+		goto fail;
+
+	    if ((this->oob.cnt % 400) == 0)
+		gdb_msg_busy(NULL);
+
+	    xfree(this->line);
+	    this->line = (char_u *)clewn_strsave((char *)line);
+	    break;
+
+	case OOB_COMPLETE:
+	    if (this->pool.fd == NULL)
+		goto fail;
+
+	    if (this->oob.state & OS_INTR)
+	    {
+		FREE(this->asm_add);
+		this->pool.hilite = FALSE;
+		goto fail;
+	    }
+	    else
+	    {
+		/* highlite $asm_add */
+		(void)gdb_as_frset(this, obs);
+
+		/* write last new line */
+		if (fputs("\n", this->pool.fd) < 0)
+		    goto fail;
+
+		/* clear the line */
+		gdb_msg_busy("FIN");
+
+		/* set the buffer as an asm buffer */
+		cnb_set_asm(this->pool.buf);
+	    }
+
+	    FREE(this->asm_add);
+
+	    this->pool.buf = -1;
+	    fclose(this->pool.fd);
+	    this->pool.fd = NULL;
+	    FREE(this->pool.name);
+	    this->pool.hilite = FALSE;
+	    break;
+    }
+    return NULL;
+fail:
+    /* clear the line */
+    gdb_msg_busy("FIN");
+
+    cnb_kill(this->pool.buf);
+    this->pool.buf = -1;
+
+    if (this->pool.fd != NULL)
+	fclose(this->pool.fd);
+    this->pool.fd = NULL;
+
+    if (this->pool.name != NULL)
+	(void)unlink(this->pool.name);
+    FREE(this->pool.name);
+    return NULL;
+}
+#  endif /* FEAT_GDB */
+
+#  ifdef GDB_LVL3_SUPPORT
+/*
+ * Get the breakpoints info record table.
+ */
+    static char *
+get_bp(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+    char_u *res    = NULL;
+    char_u *record = NULL;
+    char_u *ptr;
+    bpinfo_T *p;
+
+    switch (state)
+    {
+	case OOB_CMD:
+	    /* gdb 6.4 does not provide anymore the right annotations for breakpoints
+	     * when in level 3 (note that they are still there when setting annotate
+	     * level 2, I thought level 2 was deprecated, what a zoo !), so we look
+	     * for new or changed breakpoints systematically now */
+	    if (this->mode == GDB_MODE_LVL3)
+		this->bp_state = BPS_INVALID;
+
+	    /* When an ANO_BP_INVALID annotation has been received,
+	     * or when we are stepping (more accurately: got a new frame):
+	     * fetch bp table */
+	    if (this->bp_state & BPS_INVALID || this->bp_state & BPS_FR_INVALID)
+	    {
+		FREE(this->lvl3.result);
+		this->bufIsChanged = FALSE;
+
+		/* handle case where an error occured last time */
+		FREE(this->record);
+		gdb_free_bplist(&(this->tmplist));
+
+		/* fetch GDB bp table info */
+		return "server interpreter-exec mi -break-list\n";
+	    }
+
+	    this->bp_state &= ~BPS_INVALID;
+	    this->bp_state &= ~BPS_FR_INVALID;
+	    this->bp_state &= ~BPS_BP_HIT;
+	    break;
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.result);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.result);
+	    this->lvl3.result = res;
+	    break;
+
+	case OOB_COMPLETE:
+	    if ((ptr = this->lvl3.result) != NULL)
+	    {
+		/* process all records except last */
+		do
+		{
+		    if ((ptr = STRSTR(ptr, BKPT_RECORD)) != NULL
+			    && ptr > this->lvl3.result)
+		    {
+			*(ptr - 1) = NUL;
+			if (record != NULL)
+			    process_record(this, record, obs);
+
+			record = ptr;
+			ptr++;
+		    }
+		}
+		while (ptr != NULL);
+
+		/* process last  record */
+		if (record != NULL)
+		    process_record(this, record, obs);
+
+		FREE(this->record);
+
+		/* All records left in the old table are breakpoints that have
+		 * been deleted: delete the corresponding highliting sign */
+		for (p = this->bpinfo; p != NULL; p = p->next)
+		    gdb_unlite(BP_SIGN_ID(p->id));
+
+		this->bp_state &= ~BPS_INVALID;
+		this->bp_state &= ~BPS_FR_INVALID;
+		this->bp_state &= ~BPS_BP_HIT;
+
+		/* replace with new table */
+		gdb_free_bplist(&(this->bpinfo));
+		this->bpinfo = this->tmplist;
+		this->tmplist = NULL;
+
+		FREE(this->lvl3.result);
+	    }
+	    break;
+    }
+    return NULL;
+}
+
+#   define BKPT_ENABLED	    "\",enabled=\""
+#   define BKPT_DISP	    "\",disp=\""
+#   define BKPT_SCRIPT	    "\",script={"
+#   define BKPT_TYPE	    "\",type=\"breakpoint\""
+#   define BKPT_LINE	    "\",line=\""
+#   define BKPT_SOURCE	    "\",file=\""
+#   define BKPT_AT	    "\",at=\"<"
+/* Process the current info record */
+    static void
+process_record(this, record, obs)
+    gdb_T *this;
+    char_u *record;
+    struct obstack *obs;
+{
+    char_u *bp_add    = NULL;
+    char_u *bp_line   = NULL;
+    char_u *bp_source = NULL;
+    char_u *bp_at     = NULL;
+    char_u *ptr;
+    char_u *end;
+    char_u *quote;
+    char_u *plus;
+
+    /* allocate a new record or reuse an existing one
+     * and initialize its fields */
+    if (this->record == NULL)
+	this->record = (bpinfo_T *)xcalloc(sizeof(bpinfo_T));
+
+    this->record->id		= -1;
+    this->record->enabled	= TRUE;
+#   ifdef BP_INVALID_ANO_MISSING
+    this->record->disposition	= TRUE;
+#   endif
+    this->record->cont		= FALSE;
+#   ifdef FEAT_GDB
+    this->record->buf		= NULL;
+#   else
+    this->record->buf		= -1;
+    this->record->typenr_en	= -1;
+    this->record->typenr_dis	= -1;
+#   endif
+    this->record->lnum		= 0;
+    this->record->next		= NULL;
+
+    /* breakpoint number */
+    this->record->id = atoi((char *)(record + strlen(BKPT_RECORD)));
+
+    /* enabled state */
+    if ((ptr = STRSTR(record, BKPT_ENABLED)) != NULL
+	    && *(ptr + strlen(BKPT_ENABLED)) == 'n')
+	this->record->enabled = FALSE;
+
+#   ifdef BP_INVALID_ANO_MISSING
+    /* disposition */
+    if ((ptr = STRSTR(record, BKPT_DISP)) != NULL
+	    && STRSTR(ptr + strlen(BKPT_DISP), "keep") == NULL)
+	this->record->disposition = FALSE;
+#   endif
+
+    /* parse script for 'continue' as last statement */
+    if ((ptr = STRSTR(record, BKPT_SCRIPT)) != NULL)
+    {
+	ptr += strlen(BKPT_SCRIPT);
+	if ((end = STRCHR(ptr, '}')) != NULL)
+	{
+	    while ((ptr = STRCHR(ptr, '"')) != NULL && ptr < end)
+	    {
+		ptr++;
+		if (gdb_regexec(ptr, PAT_BP_CONT, 1, obs) != NULL
+			|| gdb_regexec(ptr, PAT_BP_CONT, 2, obs) != NULL)
+		{
+		    this->record->cont = TRUE;    /* continue */
+		    break;
+		}
+	    }
+	}
+    }
+
+    /* sanity check and discard watchpoints and others */
+    if (this->record->id <= 0 || STRSTR(record, BKPT_TYPE) == NULL)
+	return;
+
+    /* address */
+    if ((ptr = STRSTR(record, BKPT_ADDR)) != NULL)
+	bp_add = gdb_regexec(ptr + strlen(BKPT_ADDR), PAT_ADD, 1, obs);
+
+    /* line */
+    if ((ptr = STRSTR(record, BKPT_LINE)) != NULL)
+    {
+	ptr += strlen(BKPT_LINE);
+	if ((quote = STRCHR(ptr, '"')) != NULL)
+	    bp_line = (char_u *)obstack_copy0(obs, ptr, (quote - ptr));
+    }
+
+    /* source */
+    if ((ptr = STRSTR(record, BKPT_SOURCE)) != NULL)
+    {
+	ptr += strlen(BKPT_SOURCE);
+	if ((quote = STRCHR(ptr, '"')) != NULL)
+	    bp_source = (char_u *)obstack_copy0(obs, ptr, (quote - ptr));
+    }
+
+    /* at */
+    if ((ptr = STRSTR(record, BKPT_AT)) != NULL)
+    {
+	ptr += strlen(BKPT_AT);
+	if ((quote = STRCHR(ptr, '>')) != NULL)
+	{
+	    if ((plus = STRCHR(ptr, '+')) != NULL && plus < quote)
+		bp_at = (char_u *)obstack_copy0(obs, ptr, (plus - ptr));
+	    else
+		bp_at = (char_u *)obstack_copy0(obs, ptr, (quote - ptr));
+	}
+    }
+
+    gdb_process_record(this, bp_add, bp_at, bp_line, bp_source, obs);
+}
+
+/* Update the variables objects and the variables window */
+    static char *
+varobj_update(this, state, line, obs)
+    gdb_T *this;
+    int state;
+    char_u *line;
+    struct obstack *obs;
+{
+#  ifdef FEAT_GDB
+    char_u *ptrn;
+#  else
+    static char *result = NULL;	    /* mark the start and end of object operations */
+#  endif
+    char_u *res  = NULL;
+    varobj_T *obj;
+
+    switch (state)
+    {
+	case OOB_CMD:
+	    if (this->lvl3.varitem == NULL)
+	    {
+		/* start with first in list */
+		this->lvl3.varitem = this->lvl3.varlist;
+		this->lvl3.varnext_cmd = VCMD_INIT;
+	    }
+oob_cmd:
+    /* next OOB_CMD */
+	    if ((obj = this->lvl3.varitem) != NULL)
+	    {
+		FREE(this->lvl3.result);
+
+		/* create a new object and give it a name */
+		if (this->lvl3.varnext_cmd == VCMD_INIT && obj->name == NULL)
+		{
+		    if (
+#   ifdef FEAT_GDB
+			    this->var_buf != NULL
+#   else
+			    this->var_buf > 0
+#   endif
+		       )
+		    {
+			if (obj->format != NULL)
+			    this->lvl3.varnext_cmd = VCMD_FORMAT;
+			else
+			    this->lvl3.varnext_cmd = VCMD_PRINT;
+
+			this->lvl3.varcmd = VCMD_CREATE;
+
+			obstack_strcat(obs, "server interpreter-exec mi \"-var-create - * (");
+			obstack_strcat(obs, obj->expression);
+			obstack_strcat0(obs, ")\"\n");
+			return (char *)obstack_finish(obs);
+		    }
+		    else
+		    {
+			/* remove silently from list */
+			remove_object(this, obj);
+			goto oob_cmd;
+		    }
+		}
+
+		/* sanity check: an object must have a name
+		 * this should never occur */
+		if (obj->name == NULL)
+		{
+		    /* silently ignore this error */
+		    this->lvl3.varnext_cmd = VCMD_INIT;
+		    this->lvl3.varitem = obj->next;
+		    goto oob_cmd;
+		}
+
+		/* search for the object in the variables window
+		 * if it does not exist, then -var-delete it */
+		if (this->lvl3.varnext_cmd == VCMD_INIT)
+		{
+#  ifdef FEAT_GDB
+		    pos_T pos;
+
+		    pos.lnum = 1;
+		    pos.col = 0;
+
+		    obstack_strcat(obs, "^\\s*");
+		    obstack_strcat(obs, obj->name);
+		    obstack_strcat0(obs, ":");
+		    ptrn = (char_u *)obstack_finish(obs);
+
+		    if (this->var_buf == NULL
+			    || (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+			    || (searchit(NULL, this->var_buf, &pos,
+				    FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) == FAIL))
+#  else
+		    int lnum;
+
+		    if (this->var_buf <= 0 || cnb_search_obj(obj->name, &lnum) == NULL)
+#  endif
+		    {
+			/* not in gdb variables window, delete it */
+			this->lvl3.varcmd = VCMD_DELETE;
+
+			obstack_strcat(obs, "server interpreter-exec mi \"-var-delete var");
+			obstack_strcat(obs, obj->name);
+			obstack_strcat0(obs, "\"\n");
+			return (char *)obstack_finish(obs);
+		    }
+		}
+
+		/* list children if any (need to run this cmd before update) */
+		if (this->lvl3.varnext_cmd == VCMD_INIT)
+		{
+		    this->lvl3.varnext_cmd = VCMD_UPDATE;
+
+		    if (obj->children)
+		    {
+			this->lvl3.varcmd = VCMD_CHILDREN;
+
+			obstack_strcat(obs, "server interpreter-exec mi \"-var-list-children var");
+			obstack_strcat(obs, obj->name);
+			obstack_strcat0(obs, "\"\n");
+			return (char *)obstack_finish(obs);
+		    }
+		}
+
+		/* set the format */
+		if (this->lvl3.varnext_cmd == VCMD_FORMAT)
+		{
+		    if (obj->format != NULL && STRLEN(obj->format) == 2)
+		    {
+			obstack_strcat(obs, "server interpreter-exec mi \"-var-set-format var");
+			obstack_strcat(obs, obj->name);
+
+			switch(*(obj->format + 1))
+			{
+			    case 't':
+				obstack_strcat0(obs, " binary\"\n");
+				break;
+			    case 'd':
+				obstack_strcat0(obs, " decimal\"\n");
+				break;
+			    case 'x':
+				obstack_strcat0(obs, " hexadecimal\"\n");
+				break;
+			    case 'o':
+				obstack_strcat0(obs, " octal\"\n");
+				break;
+			    default:
+				obstack_strcat0(obs, " natural\"\n");
+				break;
+			}
+
+			this->lvl3.varnext_cmd = VCMD_PRINT;
+			this->lvl3.varcmd = VCMD_FORMAT;
+
+			return (char *)obstack_finish(obs);
+		    }
+		    else
+		    {
+			this->lvl3.varnext_cmd = VCMD_INIT;
+			this->lvl3.varitem = obj->next;
+			goto oob_cmd;
+		    }
+		}
+
+		/* update object */
+		if (this->lvl3.varnext_cmd == VCMD_UPDATE)
+		{
+		    this->lvl3.varnext_cmd = VCMD_PRINT;
+		    this->lvl3.varcmd = VCMD_UPDATE;
+
+		    obstack_strcat(obs, "server interpreter-exec mi \"-var-update var");
+		    obstack_strcat(obs, obj->name);
+		    obstack_strcat0(obs, "\"\n");
+		    return (char *)obstack_finish(obs);
+		}
+
+		/* print */
+		if (this->lvl3.varnext_cmd == VCMD_PRINT)
+		{
+		    obj->state &= ~VS_ERROR;
+		    this->lvl3.varcmd = VCMD_PRINT;
+
+		    obstack_strcat(obs, "server output ");
+		    obstack_strcat(obs, obj->format);
+		    obstack_strcat(obs, " ");
+		    obstack_strcat(obs, obj->expression);
+		    obstack_strcat0(obs, "\n");
+		    return (char *)obstack_finish(obs);
+		}
+		
+		/* evaluate object expression */
+		if (this->lvl3.varnext_cmd == VCMD_EVALUATE)
+		{
+		    this->lvl3.varcmd = VCMD_EVALUATE;
+
+		    obstack_strcat(obs, "server interpreter-exec mi \"-var-evaluate-expression var");
+		    obstack_strcat(obs, obj->name);
+		    obstack_strcat0(obs, "\"\n");
+		    return (char *)obstack_finish(obs);
+		}
+	    }
+	    break;
+
+	case OOB_COLLECT:
+	    gdb_cat(&res, this->lvl3.result);
+	    gdb_cat(&res, line);
+	    xfree(this->lvl3.result);
+	    this->lvl3.result = res;
+	    break;
+
+	case OOB_COMPLETE:
+#  ifdef FEAT_GDB
+	    return varobj_complete(this, obs);
+#  else
+	    /* start of object operations */
+	    if (result == NULL && this->var_buf > 0)
+		cnb_startAtomic(this->var_buf);
+
+	    result = varobj_complete(this, obs);
+
+	    /* end of object operations */
+	    if (result == NULL && this->var_buf > 0)
+		cnb_endAtomic(this->var_buf);
+
+	    return result;
+#  endif
+    }
+
+    return NULL;
+}
+
+#   define VOBJ_NAME	    "^done,name=\"var"
+#   define VOBJ_CHILD	    "\",numchild=\""
+#   define VOBJ_SCOPE	    "\",in_scope=\""
+#   define VOBJ_VALUE	    "^done,value=\""
+/*
+ * Process the OOB_COMPLETE part of varobj_update()
+ * Return anything not NULL except when last object in varlist
+ * and after the last varcmd which may be: a failed VCMD_CREATE,
+ * VCMD_DELETE, highlighted VCMD_UPDATE, VCMD_PRINT, VCMD_EVALUATE
+ */
+    static char *
+varobj_complete(this, obs)
+    gdb_T *this;
+    struct obstack *obs;
+{
+    char_u *displine;	/* the new display item line */
+    char_u *res;
+#  ifdef FEAT_GDB
+    buf_T *oldbuf    = curbuf;
+    linenr_T lnum;
+    win_T *win;
+#  endif
+    varobj_T *obj;
+    char_u *ptr;
+    char_u *last;
+    char_u *child;
+    char_u *quote;
+
+    if ((obj = this->lvl3.varitem) != NULL)
+    {
+	switch (this->lvl3.varcmd)
+	{
+	    case VCMD_CREATE:
+		/* result of object creation */
+		if (this->lvl3.result != NULL
+			&& (ptr = STRSTR(this->lvl3.result, VOBJ_NAME)) != NULL
+			&& (ptr += strlen(VOBJ_NAME))
+			&& (quote = STRCHR(ptr, '"')) != NULL
+			&& (child = STRSTR(this->lvl3.result, VOBJ_CHILD)) != NULL)
+		{
+		    obj->name = (char_u *)clewn_strnsave((char *)ptr, (quote - ptr));
+		    obj->children = (atoi((char *)(child + strlen(VOBJ_CHILD))) > 0);
+
+		    FREE(this->lvl3.result);
+		    return (char *)obj;   /* next command */
+		}
+		else
+		{
+		    EMSG(_("Unable to create variable object"));
+		    remove_object(this, obj);
+		    FREE(this->lvl3.result);
+		    this->lvl3.varnext_cmd = VCMD_INIT;
+		    return (char *)this->lvl3.varitem;  /* next object */
+		}
+		break;
+
+	    case VCMD_DELETE:
+		remove_object(this, obj);
+		FREE(this->lvl3.result);
+		this->lvl3.varnext_cmd = VCMD_INIT;
+		return (char *)this->lvl3.varitem;  /* next object */
+
+	    case VCMD_CHILDREN:
+		FREE(this->lvl3.result);
+		return (char *)obj;   /* next command */
+
+	    case VCMD_FORMAT:
+		FREE(this->lvl3.result);
+		return (char *)obj;   /* next command */
+
+	    case VCMD_UPDATE:
+		if (this->lvl3.result != NULL
+			&&(ptr = STRSTR(this->lvl3.result, VOBJ_SCOPE)) != NULL)
+		{
+		    ptr += strlen(VOBJ_SCOPE);
+		    if ((STRSTR(ptr, "false")) == ptr)
+		    {
+			/* set "out of scope" highlighting (={-}) */
+			varobj_hilite(this, obj, (int)'-', obs);
+			goto nextobj;
+		    }
+		    else
+		    {
+			/* object needs updating */
+			FREE(this->lvl3.result);
+			return (char *)obj;   /* next command */
+		    }
+		}
+		else
+		{
+		    /* turn off highlighting */
+		    varobj_hilite(this, obj, (int)'=', obs);
+		    goto nextobj;
+		}
+		break;
+
+	    case VCMD_PRINT:
+		/* fall back to GDB/MI when unable to print expression
+		 * because it's not the right frame */
+		if (obj->state & VS_ERROR)
+		{
+		    obj->state &= ~VS_ERROR;
+		    this->lvl3.varnext_cmd = VCMD_EVALUATE;
+		    FREE(this->lvl3.result);
+		    return (char *)obj;   /* next command */
+		}
+		
+		/* build the display line including ={*}, the hiliting sign */
+		obstack_strcat(obs, obj->name);
+		obstack_strcat(obs, ":");
+		obstack_strcat(obs, obj->format);
+		obstack_strcat(obs, " ");
+		obstack_strcat(obs, obj->expression);
+		obstack_strcat(obs, " ={*} ");
+		if (this->lvl3.result != NULL) {
+		    obstack_strcat0(obs, this->lvl3.result);
+		}
+		displine = (char_u *)obstack_finish(obs);
+
+		/* add the newly created object to variables window */
+		if (obj->state & VS_INIT)
+		{
+#  ifdef FEAT_GDB
+		    if (this->var_buf != NULL)
+		    {
+			lnum = BUFLASTL(this->var_buf);
+
+			/* edit variables buffer in available window */
+			if (gdb_edit_file(this, this->var_buf, NULL, lnum, obs) != NULL)
+			{
+			    /* add to variables buffer */
+			    if (ml_append(lnum, displine, 0, 0) == OK)
+			    {
+				/* first line ever: remove empty line after the
+				 * one just inserted */
+				if (lnum == 0)
+				    ml_delete(this->var_buf->b_ml.ml_line_count, FALSE);
+
+				changed_lines(this->var_buf->b_ml.ml_line_count - 1,
+					0, this->var_buf->b_ml.ml_line_count, 1);
+			    }
+
+			    /* update top line */
+			    curwin->w_cursor.lnum = this->var_buf->b_ml.ml_line_count;
+			    update_topline();
+
+			    /* status line changed */
+			    curwin->w_redr_status = TRUE;
+
+			    /* move back to previous window if still there */
+			    if ((win = gdb_btowin(oldbuf)) != NULL)
+				win_goto(win);
+			}
+			obj->state &= ~VS_INIT;
+		    }
+#  else
+		    if (this->var_buf > 0)
+		    {
+			cnb_append(this->var_buf, displine, obs);
+			obj->state &= ~VS_INIT;
+		    }
+#  endif
+		}
+
+		/* update and highlight object value */
+		else
+		    varobj_replace(this, obj, displine, obs);
+
+		goto nextobj;
+
+	    case VCMD_EVALUATE:
+		if (this->lvl3.result != NULL
+			&& (ptr = STRSTR(this->lvl3.result, VOBJ_VALUE)) != NULL
+			&& (ptr += strlen(VOBJ_VALUE))
+			&& (quote = (char_u *)strrchr((char *)ptr, '"')) != NULL)
+		{
+		    res = (char_u *)obstack_copy0(obs, ptr, (quote - ptr));
+
+		    /* remove all `\' in `\"' */
+		    for (ptr = last = res; *ptr; ptr++)
+		    {
+			if (*ptr != '\\' || *(ptr + 1) != '"')
+			    *last++ = *ptr;
+		    }
+		    *last = NUL;
+
+		    /* build the display line including ={*}, the hiliting sign */
+		    obstack_strcat(obs, obj->name);
+		    obstack_strcat(obs, ":");
+		    obstack_strcat(obs, obj->format);
+		    obstack_strcat(obs, " ");
+		    obstack_strcat(obs, obj->expression);
+		    obstack_strcat(obs, " ={*} ");
+		    obstack_strcat0(obs, res);
+		    displine = (char_u *)obstack_finish(obs);
+
+
+		    /* update and highlight object value */
+		    varobj_replace(this, obj, displine, obs);
+
+		}
+		goto nextobj;
+	}
+    }
+
+    return NULL;
+nextobj:
+    FREE(this->lvl3.result);
+    this->lvl3.varitem = obj->next;
+    this->lvl3.varnext_cmd = VCMD_INIT;
+
+    /* When not at the end of varlist, return a non null object
+     * to get gdb_oob_send() to call again varobj_update() for
+     * the next object */
+    return (char *)this->lvl3.varitem;
+}
+
+#   define OBHI_CHANGED	    " ={*} "
+#   define OBHI_UNCHANGED   " ={=} "
+#   define OBHI_DESCOPED    " ={-} "
+/* Change object highlighting to type */
+    static void
+varobj_hilite(this, obj, type, obs)
+    gdb_T *this;
+    varobj_T *obj;
+    int type;	    /* hiliting type, may be '*', '=' or '-' */
+    struct obstack *obs;
+#  ifdef FEAT_GDB
+{
+    buf_T *oldbuf = curbuf;
+    char_u *ptrn;
+    char_u *line;
+    char_u *oldline;
+    char_u *ptr;
+    pos_T pos;
+    win_T *win;
+
+    pos.lnum = 1;
+    pos.col = 0;
+
+    /* search for obj in variables window */
+    obstack_strcat(obs, "^\\s*");
+    obstack_strcat(obs, obj->name);
+    obstack_strcat0(obs, ":");
+    ptrn = (char_u *)obstack_finish(obs);
+
+    if (this->var_buf != NULL && obj != NULL && obj->name != NULL
+	    && ! (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+	    && searchit(NULL, this->var_buf, &pos,
+		FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+    {
+	line = ml_get_buf(this->var_buf, pos.lnum, FALSE);
+	oldline = obstack_strsave(obs, line);
+
+	if ((type == '-' && ((ptr = STRSTR(oldline, OBHI_CHANGED)) != NULL
+			|| (ptr = STRSTR(oldline, OBHI_UNCHANGED)) != NULL))
+		|| (type == '*' && ((ptr = STRSTR(oldline, OBHI_UNCHANGED)) != NULL
+			|| (ptr = STRSTR(oldline, OBHI_DESCOPED)) != NULL))
+		|| (type == '=' && ((ptr = STRSTR(oldline, OBHI_DESCOPED)) != NULL
+			|| (ptr = STRSTR(oldline, OBHI_CHANGED)) != NULL)))
+	{
+	    *(ptr + 3) = type;
+
+	    /* replace line */
+	    curbuf = this->var_buf;
+	    ml_replace(pos.lnum, oldline, TRUE);
+	    changed_lines(pos.lnum, 0, pos.lnum + 1, 0);
+	    curbuf = oldbuf;
+
+	    if ((win = gdb_btowin(this->var_buf)) != NULL)
+		redraw_win_later(win, NOT_VALID);
+	}
+    }
+}
+#  else
+{
+    char_u *oldline;
+    char_u *line;
+    char_u *ptr;
+    int lnum;
+
+    /* search for obj in variables buffer */
+    if (this->var_buf > 0 && obj != NULL && obj->name != NULL
+	    && (oldline = cnb_search_obj(obj->name, &lnum)) != NULL)
+    {
+	line = obstack_strsave(obs, oldline);
+
+	if ((type == '-' && ((ptr = STRSTR(line, OBHI_CHANGED)) != NULL
+			|| (ptr = STRSTR(line, OBHI_UNCHANGED)) != NULL))
+		|| (type == '*' && ((ptr = STRSTR(line, OBHI_UNCHANGED)) != NULL
+			|| (ptr = STRSTR(line, OBHI_DESCOPED)) != NULL))
+		|| (type == '=' && ((ptr = STRSTR(line, OBHI_DESCOPED)) != NULL
+			|| (ptr = STRSTR(line, OBHI_CHANGED)) != NULL)))
+	{
+	    *(ptr + 3) = type;
+
+	    /* replace line */
+	    cnb_replace(this->var_buf, line, lnum, obs);
+	}
+    }
+}
+#  endif
+
+/* Replace object line in variables buffer with line */
+    static void
+varobj_replace(this, obj, line, obs)
+    gdb_T *this;
+    varobj_T *obj;
+    char_u *line;
+    struct obstack *obs;
+#  ifdef FEAT_GDB
+{
+    buf_T *oldbuf = curbuf;
+    win_T *oldwin = curwin;
+    char_u *ptrn;
+    linenr_T lnum;
+    win_T *win;
+    pos_T pos;
+
+    pos.lnum = 1;
+    pos.col = 0;
+
+    /* search for object in variables window */
+    obstack_strcat(obs, "^\\s*");
+    obstack_strcat(obs, obj->name);
+    obstack_strcat0(obs, ":");
+    ptrn = (char_u *)obstack_finish(obs);
+
+    if (this->var_buf != NULL && obj != NULL && obj->name != NULL
+	    && ! (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+	    && searchit(NULL, this->var_buf, &pos,
+		FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+    {
+	lnum = pos.lnum;
+
+	/* replace line */
+	curbuf = this->var_buf;
+	ml_replace(lnum, line, TRUE);
+	changed_lines(lnum, 0, lnum + 1, 0);
+
+	if ((win = gdb_btowin(this->var_buf)) != NULL)
+	{
+	    win->w_cursor.lnum = lnum;
+
+	    curwin = win;
+	    check_cursor();
+	    update_topline();
+	    curwin = oldwin;
+
+	    win->w_redr_status = TRUE;
+
+	    redraw_win_later(win, NOT_VALID);
+	}
+	curbuf = oldbuf;
+    }
+}
+#  else
+{
+    int lnum;
+
+    /* search for object in variables buffer */
+    if (this->var_buf > 0 && obj != NULL && obj->name != NULL
+	    && cnb_search_obj(obj->name, &lnum) != NULL)
+	cnb_replace(this->var_buf, line, lnum, obs);
+}
+#  endif
+
+/* Remove varobj item from valist */
+    static void
+remove_object(this, item)
+    gdb_T *this;
+    varobj_T *item;
+{
+    varobj_T **pt;
+    varobj_T *next;
+
+    for (pt = &(this->lvl3.varlist); *pt != NULL; pt = &((*pt)->next))
+	if (*pt == item)
+	{
+	    next = (*pt)->next;
+	    this->lvl3.varitem = next;
+
+	    xfree(item->name);
+	    xfree(item->format);
+	    xfree(item->expression);
+	    xfree(item);
+	    *pt = next;
+	    return;
+	}
+}
+#  endif /* GDB_LVL3_SUPPORT */
+
+/*
+ * Add a breakpoint record to the head of the tmp list and highlite
+ * the corresponding sign if the record refers to a loaded buffer
+ * or to an editable file, and in this case load it.
+ */
+    void
+gdb_process_record(this, address, at, line, source, obs)
+    gdb_T *this;
+    char_u *address;	/* breakpoint address */
+    char_u *at;		/* breakpoint function */
+    char_u *line;	/* breakpoint line in source */
+    char_u *source;	/* breakpoint source file name */
+    struct obstack *obs;
+#  ifdef FEAT_GDB
+{
+    win_T *oldwin    = curwin;
+    bpinfo_T *record = this->record;
+    char_u *bp_file  = NULL;
+    buf_T *buf       = NULL;
+    char_u *ptrn;
+    bpinfo_T *p, **pt;
+    pos_T pos;
+    int i;
+    int lnum;
+
+    /*
+     * Look for this breakpoint in previous list
+     */
+    for (pt = &(this->bpinfo); *pt != NULL; pt = &((*pt)->next))
+    {
+	p = *pt;
+
+	/* The breakpoint number exists in the old table:
+	 *	update the highliting sign and do not even parse
+	 *	the line (assume the file and line of a breakpoint
+	 *	are immutable)
+	 *	move the old record to tmplist and update its sign
+	 */
+	if (record->id == p->id)
+	{
+	    /* update enabled */
+	    if (record->enabled != p->enabled)
+	    {
+		p->enabled = record->enabled;
+		if ((p->typenr = gdb_define_sign(p->id, p->enabled)) != -1)
+		{
+		    buf_addsign(p->buf, BP_SIGN_ID(p->id), p->lnum, p->typenr);
+		    update_debug_sign(p->buf, p->lnum);
+		}
+	    }
+
+#  ifdef BP_INVALID_ANO_MISSING
+	    /* update disposition */
+	    p->disposition = record->disposition;
+#  endif
+
+	    /* update 'continue' */
+	    p->cont = record->cont;
+
+	    /* move from old list to new list */
+	    *pt = p->next;		    /* unlink from old list */
+	    p->next = this->tmplist;	    /* link to head of new table */
+	    this->tmplist = p;
+	    return;			    /* record may be reused */
+	}
+    }
+
+    /*
+     * A new breakpoint number: edit the file if possible
+     */
+    /* An asm breakpoint */
+    if (address != NULL && at != NULL)
+    {
+	bp_file = obstack_strsave(obs, at);
+
+	/* Search all buffers in the asm buffer pool whose name starts
+	 * with bp_file and find the one containing a line starting
+	 * with address */
+	obstack_strcat(obs, "^\\s*0x0*");
+	obstack_strcat0(obs, address);
+	ptrn = (char_u *)obstack_finish(obs);
+
+	for (i = 0; i < this->pool.max; i++)
+	{
+	    pos.lnum = 1;
+	    pos.col = 0;
+
+	    if (this->pool.buf[i] != NULL
+		    && STRSTR(this->pool.buf[i]->b_fname, bp_file) != NULL
+		    && !(this->pool.buf[i]->b_ml.ml_flags & ML_EMPTY)
+		    && searchit(NULL, this->pool.buf[i], &pos,
+			FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+	    {
+		this->pool.age[i] = 0;
+		record->lnum = pos.lnum;
+		buf = this->pool.buf[i];
+		break;
+	    }
+	}
+
+	bp_file = NULL;
+    }
+
+    /* A plain breakpoint */
+    else if (line != NULL && (record->lnum = atoi((char *)line)) > 0
+	    && source != NULL)
+    {
+	bp_file = obstack_strsave(obs, source);
+    }
+
+    /*
+     * Edit the file or asm buffer
+     * when the table is reported by GDB as having changed
+     * or when this buffer is the frame buffer and the frame
+     * is invalid (because: we might be setting a frame in
+     * a newly disassembled buffer and must set again all
+     * its breakpoints)
+     */
+    if ((bp_file != NULL || buf != NULL)
+	    && (this->bp_state & BPS_INVALID
+		    || (p_asm != 0
+			&& buf != NULL
+			&& buf == this->fr_buf
+			&& (this->bp_state & BPS_FR_INVALID)))
+	    )
+    {
+	/* bufIsChanged is TRUE when previous gdb_edit_file() failed because
+	 * the user cancelled the operation after having been warned the
+	 * buffer is changed. In this case, do not try to gdb_edit_file()
+	 * again for the next new breakpoints
+	 * (as the operation is cancelled). */
+	if (! this->bufIsChanged)
+	{
+	    if (gdb_edit_file(this, buf, bp_file, record->lnum, obs) != NULL)
+	    {
+		/* MUST redraw the screen before calling update_debug_sign():
+		 *  update_debug_sign() invokes win_update()
+		 *  the screen might have been scrolled when Vim ask the
+		 *  user to confirm changes made to the previous buffer */
+		gdb_redraw(curwin->w_buffer);
+
+		record->buf = curwin->w_buffer;
+
+		if ((record->typenr =
+			    gdb_define_sign(record->id, record->enabled)) != -1)
+		{
+		    /* add bp sign */
+		    buf_addsign(record->buf, BP_SIGN_ID(record->id),
+			    record->lnum, record->typenr);
+		    update_debug_sign(record->buf, record->lnum);
+
+		    /* Set the frame sign again in case this is
+		     * a newly disassembled buffer */
+		    if (this->frame_pc != NULL
+			    && p_asm != 0
+			    && this->fr_buf == NULL
+			    && ! (record->buf->b_ml.ml_flags & ML_EMPTY))
+		    {
+			pos.lnum = 1;
+			pos.col = 0;
+
+			obstack_strcat(obs, "^\\s*0x0*");
+			obstack_strcat0(obs, this->frame_pc);
+			ptrn = (char_u *)obstack_finish(obs);
+
+			if (ptrn != NULL
+				&& searchit(NULL, record->buf, &pos, FORWARD,
+				    ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+			{
+			    gdb_fr_lite(this, record->buf, pos.lnum, obs);
+			}
+		    }
+
+		    /* Handle the case where bps are set after the frame sign:
+		     * new disassembled code or reediting a wiped-out plain
+		     * buffer or stepping in a newly disassembled buffer */
+		    if (record->buf == this->fr_buf
+			    && (this->bp_state & BPS_BP_HIT
+				|| (p_asm != 0
+				    && (this->bp_state & BPS_FR_INVALID)))
+			    && (lnum =
+				buf_findsign(this->fr_buf, FRAME_SIGN)) != 0)
+		    {
+			/* remove frame sign and add it again on top
+			 * of this new breakpoint */
+			if (lnum == record->lnum)
+			    gdb_fr_lite(this, this->fr_buf, lnum, obs);
+
+			/* move back cursor to frame */
+			gdb_set_cursor(gdb_btowin(this->fr_buf), lnum);
+		    }
+		}
+
+		record->next = this->tmplist;	/* link to head of new table */
+		this->tmplist = record;
+		this->record = NULL;		/* forget record */
+	    }
+	    else
+	    {
+		this->bufIsChanged = bufIsChanged(curbuf);
+		win_goto(oldwin);
+	    }
+	}
+    }
+
+    return;
+}
+#  else
+{
+    bpinfo_T *record = this->record;
+    char_u *bp_file  = NULL;
+    int buf          = -1;
+    bpinfo_T *p, **pt;
+    char_u *fname;
+    linenr_T lnum;
+    int bufno;
+
+    /*
+     * Look for this breakpoint in previous list
+     */
+    for (pt = &(this->bpinfo); *pt != NULL; pt = &((*pt)->next))
+    {
+	p = *pt;
+
+	/* The breakpoint number exists in the old table:
+	 *	remove old sign and replace by new one
+	 *	move the old record to tmplist and update its sign
+	 */
+	if (record->id == p->id)
+	{
+	    /* update enabled */
+	    if (record->enabled != p->enabled)
+	    {
+		p->enabled = record->enabled;
+		if ((p->typenr = gdb_define_bpsign(p, obs)) != -1)
+		{
+		    cnb_buf_delsign(p->buf, BP_SIGN_ID(p->id));
+		    cnb_buf_addsign(p->buf, BP_SIGN_ID(p->id), p->typenr, p->lnum, obs);
+		}
+	    }
+
+#  ifdef BP_INVALID_ANO_MISSING
+	    /* update disposition */
+	    p->disposition = record->disposition;
+#  endif
+
+	    /* update 'continue' */
+	    p->cont = record->cont;
+
+	    /* move from old list to new list */
+	    *pt = p->next;		    /* unlink from old list */
+	    p->next = this->tmplist;	    /* link to head of new table */
+	    this->tmplist = p;
+	    return;			    /* record may be reused */
+	}
+    }
+
+    /*
+     * A new breakpoint number: edit the file if possible
+     */
+    /* An asm breakpoint */
+    if (address != NULL && at != NULL)
+    {
+	bp_file = obstack_strsave(obs, at);
+
+	/* Search all buffers in the asm buffer pool whose name starts
+	 * with bp_file and find the one containing a line starting
+	 * with address */
+	for (bufno = 1; ! cnb_outofbounds(bufno); bufno++)
+	{
+	    if ((fname = cnb_filename(bufno)) != NULL
+		    && STRSTR(fname, bp_file) != NULL
+		    && (lnum = searchfor(fname, address)) > 0)
+	    {
+		record->lnum = lnum;
+		buf = bufno;
+		break;
+	    }
+	}
+
+	bp_file = NULL;
+    }
+
+    /* A plain breakpoint */
+    else if (line != NULL && (record->lnum = atoi((char *)line)) > 0
+	    && source != NULL)
+    {
+	bp_file = obstack_strsave(obs, source);
+    }
+
+    /*
+     * Edit the file or asm buffer
+     * when the table is reported by GDB as having changed
+     * or when this buffer is the frame buffer and the frame
+     * is invalid (because: we might be setting a frame in
+     * a newly disassembled buffer and must set again all
+     * its breakpoints)
+     */
+    if ((bp_file != NULL || cnb_isvalid_buffer(buf))
+	    && (this->bp_state & BPS_INVALID
+		    || (p_asm != 0
+			&& cnb_isvalid_buffer(buf)
+			&& buf == this->fr_buf
+			&& (this->bp_state & BPS_FR_INVALID)))
+	    )
+    {
+	if ((record->buf = gdb_edit_file(buf, bp_file, record->lnum, 1, obs)) > 0)
+	{
+	    if ((record->typenr = gdb_define_bpsign(record, obs)) != -1)
+	    {
+		/* add bp sign */
+		cnb_buf_addsign(record->buf, BP_SIGN_ID(record->id),
+			record->typenr, record->lnum, obs);
+
+		/* Set the frame sign again in case this is
+		 * a newly disassembled buffer */
+		if (this->frame_pc != NULL
+			&& p_asm != 0
+			&& ! cnb_isvalid_buffer(this->fr_buf)
+			&& (fname = cnb_filename(record->buf)) != NULL
+			&& (lnum = searchfor(fname, this->frame_pc)) > 0)
+		{
+		    gdb_fr_lite(this, record->buf, lnum, obs);
+		}
+
+		/* Handle the case where bps are set after the frame sign:
+		 * new disassembled code or reediting a wiped-out plain
+		 * buffer or stepping in a newly disassembled buffer */
+		if (record->buf == this->fr_buf
+			&& (this->bp_state & BPS_BP_HIT
+			    || (p_asm != 0
+				&& (this->bp_state & BPS_FR_INVALID)))
+			&& (lnum = find_fr_sign(this->fr_buf)) != 0)
+		{
+		    /* remove frame sign and add it again on top
+		     * of this new breakpoint */
+		    if (lnum == record->lnum)
+			gdb_fr_lite(this, this->fr_buf, lnum, obs);
+		}
+	    }
+
+	    record->next = this->tmplist;	/* link to head of new table */
+	    this->tmplist = record;
+	    this->record = NULL;		/* forget record */
+	}
+    }
+
+    return;
+}
+#  endif /* FEAT_GDB */
+
+/*
+ * Parse str for annotation, set this->note.
+ * Return byte address following annotation, NULL if none found.
+ * Return byte address following ^Z^Z when unknown annotation.
+ */
+    static char_u *
+parse_note(this, str)
+    gdb_T *this;
+    char_u *str;	/* string to parse */
+{
+    char_u *note = NULL;
+    annotation_T *pt;
+    int len;
+
+    if (str != NULL && (note = STRSTR(str, "\032\032")) != NULL)
+    {
+	this->note = ANO_ANY;
+	note += 2;
+
+	for (pt = annotations; pt->str != NULL; pt++)
+	{
+	    len = STRLEN(pt->str);
+
+	    if (STRSTR(note, pt->str) == note
+		    && (*(note + len) == NUL || isspace(*(note + len))))
+	    {
+		this->note = pt->id;
+		return note + strlen((char *)pt->str);
+	    }
+	}
+    }
+    return note;
+}
+
+#  ifndef FEAT_GDB
+/* Return annotation type of 'str' or ANO_NONE when not found. */
+    static int
+get_note(this, str)
+    gdb_T *this;
+    char_u *str;	/* string to parse */
+{
+    int oldnote = this->note;
+    int note    = ANO_NONE;
+
+    if (IS_ANNOTATION(str) && parse_note(this, str) != NULL)
+	note = this->note;
+
+    this->note = oldnote;
+    return note;
+}
+#  endif /* FEAT_GDB */
+# endif /* defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT) */
+#endif /* defined(FEAT_GDB) || defined(HAVE_CLEWN) */
diff --git a/src/clewn/misc.c b/src/clewn/misc.c
new file mode 100644
index 0000000..b5ebe37
--- /dev/null
+++ b/src/clewn/misc.c
@@ -0,0 +1,645 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * Copyright (C) 2004 Xavier de Gaye.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (see the file COPYING); if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: misc.c 217 2008-10-11 14:29:18Z xavier $
+ */
+
+#ifdef HAVE_CLEWN
+# include <config.h>
+#else
+# include <auto/config.h>
+void vim_beep ();
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+#include <sys/stat.h>
+
+#ifdef HAVE_READLINE_READLINE_H
+# include <readline/readline.h>
+#endif
+
+#ifdef HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
+#ifndef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#endif
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+
+#if !defined(HAVE_SYS_TIME_H) || defined(TIME_WITH_SYS_TIME)
+# include <time.h>	    /* on some systems time.h should not be
+			       included together with sys/time.h */
+#endif
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>
+#endif
+
+#ifndef HAVE_SELECT
+# ifdef HAVE_SYS_POLL_H
+#  include <sys/poll.h>
+# else
+#  ifdef HAVE_POLL_H
+#   include <poll.h>
+#  endif
+# endif
+#endif
+
+/* Note: Some systems need both string.h and strings.h (Savage).  However,
+ * some systems can't handle both, only use string.h in that case. */
+#if defined(HAVE_STRINGS_H) && !defined(NO_STRINGS_WITH_STRING_H)
+# include <strings.h>
+#endif
+
+#include "obstack.h"
+#ifdef FEAT_GDB
+# include "vim.h"
+#else
+# include "clewn.h"
+#endif
+
+/* do not define xmalloc and family */
+#undef GDB_MTRACE
+#include "gdb.h"
+
+#include "misc.h"
+
+#if defined(__CYGWIN__) || defined(__CYGWIN32__)
+# define WIN32UNIX	/* Compiling for Win32 using Unix files. */
+# define BINARY_FILE_IO
+# undef HAVE_FCHDIR	/* doesn't work well in most versions */
+#endif
+
+#if defined(HAVE_GETCWD) && defined(HAVE_GETWD)
+# define USE_GETCWD
+#endif
+
+/* boolean constants */
+#define FALSE	0
+#define TRUE	1
+
+/*
+ * EMX doesn't have a global way of making open() use binary I/O.
+ * Use O_BINARY for all open() calls.
+ */
+#if defined(__EMX__) || defined(__CYGWIN32__)
+# define O_EXTRA    O_BINARY
+#else
+# define O_EXTRA    0
+#endif
+
+static void (*misc_abort)(void) = NULL;	    /* registered abort function */
+
+/* Register an abort function for when allocating memory fails. */
+    void
+xatabort(abort_func)
+    void (*abort_func)(void);
+{
+    misc_abort = abort_func;
+}
+
+/* allocate memory */
+    void *
+xmalloc(size)
+    size_t size;
+{
+    void *value = malloc(size);
+
+    if (value == 0)
+    {
+#ifdef HAVE_CLEWN
+	rl_cleanup_after_signal();	/* have readline reset terminal */
+	fprintf(stderr, "\nvirtual memory exhausted\n");
+#endif
+	if (misc_abort != NULL)
+	    misc_abort();
+	else
+	    exit(EXIT_FAILURE);
+    }
+    return value;
+}
+
+/* Allocate memory and set all bytes to zero */
+    void *
+xcalloc(size)
+    size_t size;
+{
+    void *p = xmalloc(size);
+    clewn_memset(p, 0, size);
+    return p;
+}
+
+/* Changes the size of the memory block pointed to by ptr to size bytes. */
+    void *
+xrealloc(ptr, size)
+    void *ptr;
+    size_t size;
+{
+    void *value = realloc(ptr, size);
+
+    if (value == 0)
+    {
+#ifdef HAVE_CLEWN
+	rl_cleanup_after_signal();	/* have readline reset terminal */
+	fprintf(stderr, "\nvirtual memory exhausted\n");
+#endif
+	if (misc_abort != NULL)
+	    misc_abort();
+	else
+	    exit(EXIT_FAILURE);
+    }
+    return value;
+}
+
+/* Replacement for free() that ignores NULL pointers. */
+    void
+xfree(x)
+    void *x;
+{
+    if (x != NULL)
+	free(x);
+}
+
+#ifndef HAVE_MEMSET
+    void *
+clewn_memset(ptr, c, size)
+    void *ptr;
+    int c;
+    size_t size;
+{
+    char *p = ptr;
+
+    while (size-- > 0)
+	*p++ = c;
+    return ptr;
+}
+#endif
+
+#ifdef CLEWN_MEMMOVE
+/*
+ * Version of memmove() that handles overlapping source and destination.
+ * For systems that don't have a function that is guaranteed to do that (SYSV).
+ */
+    void
+clewn_memmove(d, s, len)
+    void *d;
+    void *s;
+    size_t len;
+{
+    /* a void doesn't have a size, we use char pointers */
+    char *dst = d;
+    char *src = s;
+
+    /* overlap, copy backwards */
+    if (dst > src && dst < src + len)
+    {
+	src += len;
+	dst += len;
+	while (len-- > 0)
+	    *--dst = *--src;
+    }
+    else    /* copy forwards */
+	while (len-- > 0)
+	    *dst++ = *src++;
+}
+#endif
+
+/* copy a string into newly allocated memory */
+    char *
+clewn_strsave(string)
+    char *string;
+{
+    char *p;
+    size_t len;
+
+    if (string != NULL) {
+	len = strlen(string) + 1;
+	p = xmalloc(len);
+	clewn_memmove(p, string, len);
+    }
+    else {
+	p = xmalloc(1);
+	*p = '\0';
+    }
+    return p;
+}
+
+    char *
+clewn_strnsave(string, len)
+    char *string;
+    size_t len;
+{
+    char *p = xmalloc(len + 1);
+
+    *p = '\0';
+    if (string != NULL)
+	strncpy(p, string, len);
+    *(p + len) = '\0';
+    return p;
+}
+
+    void
+clewn_sleep(msec)
+    int msec;
+{
+    /*
+     * Everybody sleeps in a different way...
+     * Prefer nanosleep(), some versions of usleep() can only sleep up to
+     * one second.
+     */
+#ifdef HAVE_NANOSLEEP
+    {
+	struct timespec ts;
+
+	ts.tv_sec = msec / 1000;
+	ts.tv_nsec = (msec % 1000) * 1000000;
+	(void)nanosleep(&ts, NULL);
+    }
+#else
+# ifdef HAVE_USLEEP
+    while (msec >= 1000)
+    {
+	usleep((999 * 1000));
+	msec -= 999;
+    }
+    usleep((msec * 1000));
+# else
+#  ifndef HAVE_SELECT
+    poll(NULL, 0, msec);
+#  else
+#   ifdef __EMX__
+    _sleep2(msec);
+#   else
+    {
+	struct timeval tv;
+
+	tv.tv_sec = msec / 1000;
+	tv.tv_usec = (msec % 1000) * 1000;
+	/*
+	 * NOTE: Solaris 2.6 has a bug that makes select() hang here.  Get
+	 * a patch from Sun to fix this.  Reported by Gunnar Pedersen.
+	 */
+	select(0, NULL, NULL, NULL, &tv);
+    }
+#   endif /* __EMX__ */
+#  endif /* HAVE_SELECT */
+# endif /* HAVE_NANOSLEEP */
+#endif /* HAVE_USLEEP */
+}
+
+/* Give a warning for an error. */
+    void
+clewn_beep()
+{
+#ifdef HAVE_CLEWN
+    /* use readline utility */
+# ifdef HAVE_RL_DING
+    rl_ding();
+# else
+    ding();	/* deprecated */
+# endif
+#else
+    vim_beep();
+#endif
+}
+
+/*
+ * Get name of current directory into buffer 'buf' of length 'len' bytes.
+ * Return 1 for success, 0 for failure.
+ */
+    int
+clewn_getwd(buf, len)
+    char *buf;
+    int len;
+{
+#if defined(USE_GETCWD)
+    if (getcwd(buf, len) == NULL)
+    {
+	strcpy(buf, strerror(errno));
+	return 0;
+    }
+    return 1;
+#else
+    return (getwd(buf) != NULL ? 1 : 0);
+#endif
+}
+
+/*
+ * Get absolute file name into buffer 'buf' of length 'len' bytes.
+ * return 0 for failure, 1 for success
+ */
+    int
+clewn_fullpath(fname, buf, len, force)
+    char *fname;
+    char *buf;
+    int len;
+    int force;		/* also expand when already absolute path */
+{
+    int		l;
+#ifdef HAVE_FCHDIR
+    int		fd = -1;
+    static int	dont_fchdir = FALSE;	/* TRUE when fchdir() doesn't work */
+#endif
+    char	olddir[MAXPATHL];
+    char	*p;
+    int		retval = 1;
+
+    *buf = '\0';
+    if (fname == NULL)
+	return 0;
+
+    /* expand it if forced or not an absolute path */
+    if (force || *fname != '/')
+    {
+	/*
+	 * If the file name has a path, change to that directory for a moment,
+	 * and then do the getwd() (and get back to where we were).
+	 * This will get the correct path name with "../" things.
+	 */
+	if ((p = strrchr(fname, '/')) != NULL)
+	{
+#ifdef HAVE_FCHDIR
+	    /*
+	     * Use fchdir() if possible, it's said to be faster and more
+	     * reliable.  But on SunOS 4 it might not work.  Check this by
+	     * doing a fchdir() right now.
+	     */
+	    if (!dont_fchdir)
+	    {
+		fd = open(".", O_RDONLY | O_EXTRA, 0);
+		if (fd >= 0 && fchdir(fd) < 0)
+		{
+		    close(fd);
+		    fd = -1;
+		    dont_fchdir = TRUE;	    /* don't try again */
+		}
+	    }
+#endif
+
+	    /* Only change directory when we are sure we can return to where
+	     * we are now.  After doing "su" chdir(".") might not work. */
+	    if (
+#ifdef HAVE_FCHDIR
+		fd < 0 &&
+#endif
+			(clewn_getwd(olddir, MAXPATHL) == 0
+					   || chdir((char *)olddir) != 0))
+	    {
+		p = NULL;	/* can't get current dir: don't chdir */
+		retval = 0;
+	    }
+	    else
+	    {
+		/* The directory is copied into buf[], to be able to remove
+		 * the file name without changing it (could be a string in
+		 * read-only memory) */
+		if (p - fname >= len)
+		    retval = 0;
+		else
+		{
+		    strncpy(buf, fname, p - fname);
+		    buf[p - fname] = '\0';
+		    if (chdir((char *)buf))
+			retval = 0;
+		    else
+			fname = p + 1;
+		    *buf = '\0';
+		}
+	    }
+	}
+
+	if (clewn_getwd(buf, len) == 0)
+	{
+	    retval = 0;
+	    *buf = '\0';
+	}
+
+	if (p != NULL)
+	{
+#ifdef HAVE_FCHDIR
+	    if (fd >= 0)
+	    {
+		(void)fchdir(fd);
+		close(fd);
+	    }
+	    else
+#endif
+		(void)chdir((char *)olddir);
+	}
+
+	l = strlen(buf);
+	if (l >= len)
+	    retval = 0;
+	else
+	{
+	    if (l > 0 && buf[l - 1] != '/' && *fname != '\0')
+		strcat(buf, "/");
+	}
+    }
+
+    /* catch file names which are too long */
+    if (retval == 0 || ((int)(strlen(buf) + strlen(fname)) >= len))
+	return 0;
+
+    strcat(buf, fname);
+
+    return 1;
+}
+
+/*
+ * Get a full path name for the file named 'name'.
+ * If name is an absolute path, just stat it. Otherwise, add name to
+ * each directory in GDB source directories and stat the result.
+ */
+    char *
+get_fullpath(name, sourcedir, source_cur, source_list, obs)
+    char *name;	        /* file name */
+    char *sourcedir;	/* GDB source directories */
+    char *source_cur;	/* GDB current source */
+    char *source_list;  /* GDB source list */
+    struct obstack *obs;
+{
+    char *pathname;
+    char pathbuf[MAXPATHL];
+    struct stat st;
+    char *dir;
+    char *ptr;
+    char *last;
+    char *hay;
+    char *found;
+    char *end;
+
+    if (name == NULL || *name == NUL)
+	return NULL;
+
+    /* an absolute path name */
+    if (*name == '/')
+    {
+	if (stat((char *)name, &st) == 0)
+	    return name;
+	else
+	    /* strip off the directory part and continue */
+	    name = strrchr(name, '/') + 1;
+    }
+
+    if (sourcedir == NULL)		    /* use current working directory */
+	sourcedir = GDB_CWD;
+
+    /* proceed with each directory in GDB source directories */
+    ptr = sourcedir;
+    do
+    {
+	if ((last = strchr(ptr, ':')) != NULL)
+	    *last++ = NUL;
+
+	if (strcmp(ptr, GDB_CDIR) == 0)	    /* compilation directory */
+	{
+	    /* hay: file="NAME",fullname=" */
+	    obstack_strcat(obs, "file=\"");
+	    obstack_strcat(obs, name);
+	    obstack_strcat0(obs, "\",fullname=\"");
+	    hay = (char *)obstack_finish(obs);
+
+	    /* name is the current sourcefile: use gdb compilation directory */
+	    if (source_cur != NULL && (found=strstr(source_cur, hay)) != NULL ){
+		found += strlen(hay);
+		if ((end=strstr(found, "\"")) != NULL)
+		    return (char *)obstack_copy0(obs, found, end - found);
+	    }
+
+	    /* lookup for first occurence of name in source list */
+	    if (source_list != NULL && (found=strstr(source_list, hay)) != NULL ){
+		found += strlen(hay);
+		if ((end=strstr(found, "\"")) != NULL)
+		    return (char *)obstack_copy0(obs, found, end - found);
+	    }
+
+	    dir = NULL;
+	}
+	else if (strcmp(ptr, GDB_CWD) == 0) /* current working directory */
+	{
+	    if (clewn_getwd(pathbuf, MAXPATHL))
+		dir = pathbuf;
+	    else
+		dir = NULL;
+	}
+	else
+	    dir = ptr;
+
+	if (dir != NULL)
+	{
+	    obstack_strcat(obs, dir);
+	    obstack_strcat(obs, "/");
+	    obstack_strcat0(obs, name);
+	    pathname = (char *)obstack_finish(obs);
+
+	    if (stat((char *)pathname, &st) == 0) {
+		/* need to handle the case where the path includes '..'
+		 * for example "/home/xavier/tmp/.." must be converted
+		 * to "/home/xavier" */
+		if (clewn_fullpath(pathname, pathbuf, MAXPATHL, TRUE))
+		    return (char *)obstack_strsave(obs, pathbuf);
+	    }
+	}
+
+	ptr = last;
+    } while (ptr != NULL && *ptr != NUL);
+
+    return NULL;
+}
+
+/*
+ * Execute a program with (optionnaly quoted) arguments
+ */
+    void
+clewn_exec(cmd)
+    char *cmd;
+{
+    char ** argv = NULL;	/* keep compiler happy */
+    char * newcmd;
+    int argc;
+    char * ptr;
+    int inquote;
+    int i;
+
+    if ((newcmd = clewn_strsave(cmd)) == NULL)
+	return;
+
+    /*
+     * step 1: find number of arguments
+     * step 2: separate them and built argv[]
+     */
+    for (i = 0; i < 2; i++)
+    {
+	ptr = newcmd;
+	argc = 0;
+
+	for (;;)
+	{
+	    inquote = FALSE;
+
+	    while (*ptr == ' ' || *ptr == '\t')	/* skip to next non-white */
+		ptr++;
+
+	    if (*ptr == '\0')
+		break;
+
+	    if (*ptr == '"' || *ptr == '\'')
+	    {
+		ptr++;
+		inquote = TRUE;
+	    }
+
+	    if (i == 1)
+		argv[argc] = ptr;
+
+	    argc++;
+	    while (*ptr && (inquote || (*ptr != ' ' && *ptr != '\t')))
+	    {
+		if (*ptr == '"' || *ptr == '\'')
+		    break;
+
+		ptr++;
+	    }
+
+	    if (*ptr == '\0')
+		break;
+
+	    if (i == 1)
+		*ptr = '\0';
+
+	    ptr++;
+	}
+
+	/* got the number of arguments */
+	if (i == 0 && (argv = (char **) xcalloc((size_t)((argc + 1) * sizeof(char *)))) == NULL)
+	    return;
+    }
+
+    execvp(argv[0], argv);
+}
diff --git a/src/clewn/misc.h b/src/clewn/misc.h
new file mode 100644
index 0000000..0e3b617
--- /dev/null
+++ b/src/clewn/misc.h
@@ -0,0 +1,92 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * Copyright (C) 2004 Xavier de Gaye.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (see the file COPYING); if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: misc.h 148 2007-07-21 16:35:40Z xavier $
+ */
+
+#ifndef MISC_H
+# define MISC_H
+
+#ifndef __ARGS
+    /* The AIX VisualAge cc compiler defines __EXTENDED__ instead of __STDC__
+     * because it includes pre-ansi features. */
+# if defined(__STDC__) || defined(__GNUC__) || defined(__EXTENDED__)
+#  define __ARGS(x) x
+# else
+#  define __ARGS(x) ()
+# endif
+#endif
+
+/* memmove is not present on all systems, use memmove, bcopy, memcpy or our
+ * own version */
+/* Some systems have (void *) arguments, some (char *). If we use (char *) it
+ * works for all */
+#ifdef USEMEMMOVE
+# define clewn_memmove(to, from, len) memmove((char *)(to), (char *)(from), len)
+#else
+# ifdef USEBCOPY
+#  define clewn_memmove(to, from, len) bcopy((char *)(from), (char *)(to), len)
+# else
+#  ifdef USEMEMCPY
+#   define clewn_memmove(to, from, len) memcpy((char *)(to), (char *)(from), len)
+#  else
+#   define CLEWN_MEMMOVE
+void clewn_memmove __ARGS((void *, void *, size_t));
+#  endif
+# endif
+#endif
+
+#ifdef HAVE_MEMSET
+# define clewn_memset(ptr, c, size)   memset((ptr), (c), (size))
+#else
+void *clewn_memset __ARGS((void *, int, size_t));
+#endif
+
+/*
+ * Maximum length of a path (for non-unix systems) Make it a bit long, to stay
+ * on the safe side.  But not too long to put on the stack.
+ */
+#ifndef MAXPATHL
+# ifdef MAXPATHLEN
+#  define MAXPATHL	MAXPATHLEN
+# else
+#  define MAXPATHL	256
+# endif
+#endif
+
+/* gdb directory constants */
+#define GDB_CDIR    "$cdir"
+#define GDB_CWD	    "$cwd"
+
+void xatabort __ARGS((void (*)(void)));
+void * xmalloc __ARGS((size_t));
+void * xcalloc __ARGS((size_t));
+void * xrealloc __ARGS((void *, size_t));
+void xfree __ARGS((void *));
+char * clewn_strsave __ARGS((char *));
+char * clewn_strnsave __ARGS((char *, size_t));
+void clewn_sleep __ARGS((int));
+void clewn_beep __ARGS((void));
+int clewn_getwd __ARGS((char *, int));
+int clewn_fullpath __ARGS((char *, char *, int, int));
+char * get_fullpath __ARGS((char *, char *, char *, char *, struct obstack *));
+void clewn_exec(char *);
+
+#endif	/* MISC_H */
+
diff --git a/src/clewn/obstack.c b/src/clewn/obstack.c
new file mode 100644
index 0000000..0ee0390
--- /dev/null
+++ b/src/clewn/obstack.c
@@ -0,0 +1,442 @@
+/* obstack.c - subroutines used implicitly by object stack macros
+   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+
+#ifdef _LIBC
+# include <obstack.h>
+# include <shlib-compat.h>
+#else
+# ifdef HAVE_CONFIG_H
+#  ifdef HAVE_CLEWN
+#   include <config.h>
+#  else
+#   include <auto/config.h>
+#  endif
+# endif
+# include <stdint.h>
+# include "obstack.h"
+#endif
+
+/* NOTE BEFORE MODIFYING THIS FILE: This version number must be
+   incremented whenever callers compiled using an old obstack.h can no
+   longer properly call the functions in this obstack.c.  */
+#define OBSTACK_INTERFACE_VERSION 1
+
+/* Comment out all this code if we are using the GNU C Library, and are not
+   actually compiling the library itself, and the installed library
+   supports the same library interface we do.  This code is part of the GNU
+   C Library, but also included in many other GNU distributions.  Compiling
+   and linking in this code is a waste when using the GNU C library
+   (especially if it is a shared library).  Rather than having every GNU
+   program understand `configure --with-gnu-libc' and omit the object
+   files, it is simpler to just do this in the source for each such file.  */
+
+#include <stdio.h>		/* Random thing to get __GNU_LIBRARY__.  */
+#if !defined _LIBC && defined __GNU_LIBRARY__ && __GNU_LIBRARY__ > 1
+# include <gnu-versions.h>
+# if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
+#  define ELIDE_CODE
+# endif
+#endif
+
+#include <stddef.h>
+
+#ifndef ELIDE_CODE
+
+
+# if HAVE_INTTYPES_H
+#  include <inttypes.h>
+# endif
+# if HAVE_STDINT_H || defined _LIBC
+#  include <stdint.h>
+# endif
+
+/* Determine default alignment.  */
+union fooround
+{
+  uintmax_t i;
+  long double d;
+  void *p;
+};
+struct fooalign
+{
+  char c;
+  union fooround u;
+};
+/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
+   But in fact it might be less smart and round addresses to as much as
+   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
+enum
+  {
+    DEFAULT_ALIGNMENT = offsetof (struct fooalign, u),
+    DEFAULT_ROUNDING = sizeof (union fooround)
+  };
+
+/* When we copy a long block of data, this is the unit to do it with.
+   On some machines, copying successive ints does not work;
+   in such a case, redefine COPYING_UNIT to `long' (if that works)
+   or `char' as a last resort.  */
+# ifndef COPYING_UNIT
+#  define COPYING_UNIT int
+# endif
+
+
+/* The functions allocating more room by calling `obstack_chunk_alloc'
+   jump to the handler pointed to by `obstack_alloc_failed_handler'.
+   This can be set to a user defined function which should either
+   abort gracefully or use longjump - but shouldn't return.  This
+   variable by default points to the internal function
+   `print_and_abort'.  */
+static void print_and_abort (void);
+void (*obstack_alloc_failed_handler) (void) = print_and_abort;
+
+/* Exit value used when `print_and_abort' is used.  */
+# include <stdlib.h>
+# ifdef _LIBC
+int obstack_exit_failure = EXIT_FAILURE;
+# else
+#  define obstack_exit_failure EXIT_FAILURE
+# endif
+
+# ifdef _LIBC
+#  if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3_4)
+/* A looong time ago (before 1994, anyway; we're not sure) this global variable
+   was used by non-GNU-C macros to avoid multiple evaluation.  The GNU C
+   library still exports it because somebody might use it.  */
+struct obstack *_obstack_compat;
+compat_symbol (libc, _obstack_compat, _obstack, GLIBC_2_0);
+#  endif
+# endif
+
+/* Define a macro that either calls functions with the traditional malloc/free
+   calling interface, or calls functions with the mmalloc/mfree interface
+   (that adds an extra first argument), based on the state of use_extra_arg.
+   For free, do not use ?:, since some compilers, like the MIPS compilers,
+   do not allow (expr) ? void : void.  */
+
+# define CALL_CHUNKFUN(h, size) \
+  (((h) -> use_extra_arg) \
+   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
+   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
+
+# define CALL_FREEFUN(h, old_chunk) \
+  do { \
+    if ((h) -> use_extra_arg) \
+      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
+    else \
+      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \
+  } while (0)
+
+
+/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
+   Objects start on multiples of ALIGNMENT (0 means use default).
+   CHUNKFUN is the function to use to allocate chunks,
+   and FREEFUN the function to free them.
+
+   Return nonzero if successful, calls obstack_alloc_failed_handler if
+   allocation fails.  */
+
+int
+_obstack_begin (struct obstack *h,
+		int size, int alignment,
+		void *(*chunkfun) (long),
+		void (*freefun) (void *))
+{
+  register struct _obstack_chunk *chunk; /* points to new chunk */
+
+  if (alignment == 0)
+    alignment = DEFAULT_ALIGNMENT;
+  if (size == 0)
+    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
+    {
+      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
+	 Use the values for range checking, because if range checking is off,
+	 the extra bytes won't be missed terribly, but if range checking is on
+	 and we used a larger request, a whole extra 4096 bytes would be
+	 allocated.
+
+	 These number are irrelevant to the new GNU malloc.  I suspect it is
+	 less sensitive to the size of the request.  */
+      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
+		    + 4 + DEFAULT_ROUNDING - 1)
+		   & ~(DEFAULT_ROUNDING - 1));
+      size = 4096 - extra;
+    }
+
+  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;
+  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
+  h->chunk_size = size;
+  h->alignment_mask = alignment - 1;
+  h->use_extra_arg = 0;
+
+  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
+  if (!chunk)
+    (*obstack_alloc_failed_handler) ();
+  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,
+					       alignment - 1);
+  h->chunk_limit = chunk->limit
+    = (char *) chunk + h->chunk_size;
+  chunk->prev = 0;
+  /* The initial chunk now contains no empty object.  */
+  h->maybe_empty_object = 0;
+  h->alloc_failed = 0;
+  return 1;
+}
+
+int
+_obstack_begin_1 (struct obstack *h, int size, int alignment,
+		  void *(*chunkfun) (void *, long),
+		  void (*freefun) (void *, void *),
+		  void *arg)
+{
+  register struct _obstack_chunk *chunk; /* points to new chunk */
+
+  if (alignment == 0)
+    alignment = DEFAULT_ALIGNMENT;
+  if (size == 0)
+    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
+    {
+      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
+	 Use the values for range checking, because if range checking is off,
+	 the extra bytes won't be missed terribly, but if range checking is on
+	 and we used a larger request, a whole extra 4096 bytes would be
+	 allocated.
+
+	 These number are irrelevant to the new GNU malloc.  I suspect it is
+	 less sensitive to the size of the request.  */
+      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
+		    + 4 + DEFAULT_ROUNDING - 1)
+		   & ~(DEFAULT_ROUNDING - 1));
+      size = 4096 - extra;
+    }
+
+  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;
+  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
+  h->chunk_size = size;
+  h->alignment_mask = alignment - 1;
+  h->extra_arg = arg;
+  h->use_extra_arg = 1;
+
+  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
+  if (!chunk)
+    (*obstack_alloc_failed_handler) ();
+  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,
+					       alignment - 1);
+  h->chunk_limit = chunk->limit
+    = (char *) chunk + h->chunk_size;
+  chunk->prev = 0;
+  /* The initial chunk now contains no empty object.  */
+  h->maybe_empty_object = 0;
+  h->alloc_failed = 0;
+  return 1;
+}
+
+/* Allocate a new current chunk for the obstack *H
+   on the assumption that LENGTH bytes need to be added
+   to the current object, or a new object of length LENGTH allocated.
+   Copies any partial object from the end of the old chunk
+   to the beginning of the new one.  */
+
+void
+_obstack_newchunk (struct obstack *h, int length)
+{
+  register struct _obstack_chunk *old_chunk = h->chunk;
+  register struct _obstack_chunk *new_chunk;
+  register long	new_size;
+  register long obj_size = h->next_free - h->object_base;
+  register long i;
+  long already;
+  char *object_base;
+
+  /* Compute size for new chunk.  */
+  new_size = (obj_size + length) + (obj_size >> 3) + h->alignment_mask + 100;
+  if (new_size < h->chunk_size)
+    new_size = h->chunk_size;
+
+  /* Allocate and initialize the new chunk.  */
+  new_chunk = CALL_CHUNKFUN (h, new_size);
+  if (!new_chunk)
+    (*obstack_alloc_failed_handler) ();
+  h->chunk = new_chunk;
+  new_chunk->prev = old_chunk;
+  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
+
+  /* Compute an aligned object_base in the new chunk */
+  object_base =
+    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);
+
+  /* Move the existing object to the new chunk.
+     Word at a time is fast and is safe if the object
+     is sufficiently aligned.  */
+  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
+    {
+      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
+	   i >= 0; i--)
+	((COPYING_UNIT *)object_base)[i]
+	  = ((COPYING_UNIT *)h->object_base)[i];
+      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
+	 but that can cross a page boundary on a machine
+	 which does not do strict alignment for COPYING_UNITS.  */
+      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
+    }
+  else
+    already = 0;
+  /* Copy remaining bytes one by one.  */
+  for (i = already; i < obj_size; i++)
+    object_base[i] = h->object_base[i];
+
+  /* If the object just copied was the only data in OLD_CHUNK,
+     free that chunk and remove it from the chain.
+     But not if that chunk might contain an empty object.  */
+  if (! h->maybe_empty_object
+      && (h->object_base
+	  == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,
+			  h->alignment_mask)))
+    {
+      new_chunk->prev = old_chunk->prev;
+      CALL_FREEFUN (h, old_chunk);
+    }
+
+  h->object_base = object_base;
+  h->next_free = h->object_base + obj_size;
+  /* The new chunk certainly contains no empty object yet.  */
+  h->maybe_empty_object = 0;
+}
+# ifdef _LIBC
+libc_hidden_def (_obstack_newchunk)
+# endif
+
+/* Return nonzero if object OBJ has been allocated from obstack H.
+   This is here for debugging.
+   If you use it in a program, you are probably losing.  */
+
+/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
+   obstack.h because it is just for debugging.  */
+int _obstack_allocated_p (struct obstack *h, void *obj);
+
+int
+_obstack_allocated_p (struct obstack *h, void *obj)
+{
+  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
+
+  lp = (h)->chunk;
+  /* We use >= rather than > since the object cannot be exactly at
+     the beginning of the chunk but might be an empty object exactly
+     at the end of an adjacent chunk.  */
+  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
+    {
+      plp = lp->prev;
+      lp = plp;
+    }
+  return lp != 0;
+}
+
+/* Free objects in obstack H, including OBJ and everything allocate
+   more recently than OBJ.  If OBJ is zero, free everything in H.  */
+
+# undef obstack_free
+
+void
+obstack_free (struct obstack *h, void *obj)
+{
+  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
+
+  lp = h->chunk;
+  /* We use >= because there cannot be an object at the beginning of a chunk.
+     But there can be an empty object at that address
+     at the end of another chunk.  */
+  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
+    {
+      plp = lp->prev;
+      CALL_FREEFUN (h, lp);
+      lp = plp;
+      /* If we switch chunks, we can't tell whether the new current
+	 chunk contains an empty object, so assume that it may.  */
+      h->maybe_empty_object = 1;
+    }
+  if (lp)
+    {
+      h->object_base = h->next_free = (char *) (obj);
+      h->chunk_limit = lp->limit;
+      h->chunk = lp;
+    }
+  else if (obj != 0)
+    /* obj is not in any of the chunks! */
+    abort ();
+}
+
+# ifdef _LIBC
+/* Older versions of libc used a function _obstack_free intended to be
+   called by non-GCC compilers.  */
+strong_alias (obstack_free, _obstack_free)
+# endif
+
+int
+_obstack_memory_used (struct obstack *h)
+{
+  register struct _obstack_chunk* lp;
+  register int nbytes = 0;
+
+  for (lp = h->chunk; lp != 0; lp = lp->prev)
+    {
+      nbytes += lp->limit - (char *) lp;
+    }
+  return nbytes;
+}
+
+/* Define the error handler.  */
+# ifdef _LIBC
+#  include <libintl.h>
+# endif
+# ifndef _
+#  define _(msgid) (msgid)
+# endif
+
+# ifdef _LIBC
+#  include <libio/iolibio.h>
+# endif
+
+# ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+#  if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
+#   define __attribute__(Spec) /* empty */
+#  endif
+# endif
+
+static void
+__attribute__ ((noreturn))
+print_and_abort (void)
+{
+  /* Don't change any of these strings.  Yes, it would be possible to add
+     the newline to the string and use fputs or so.  But this must not
+     happen because the "memory exhausted" message appears in other places
+     like this and the translation should be reused instead of creating
+     a very similar string which requires a separate translation.  */
+# ifdef _LIBC
+  (void) __fxprintf (NULL, "%s\n", _("memory exhausted"));
+# else
+  fprintf (stderr, "%s\n", _("memory exhausted"));
+# endif
+  exit (obstack_exit_failure);
+}
+
+#endif	/* !ELIDE_CODE */
diff --git a/src/clewn/obstack.h b/src/clewn/obstack.h
new file mode 100644
index 0000000..206fe55
--- /dev/null
+++ b/src/clewn/obstack.h
@@ -0,0 +1,509 @@
+/* obstack.h - object stack macros
+   Copyright (C) 1988-1994,1996-1999,2003,2004,2005
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* Summary:
+
+All the apparent functions defined here are macros. The idea
+is that you would use these pre-tested macros to solve a
+very specific set of problems, and they would run fast.
+Caution: no side-effects in arguments please!! They may be
+evaluated MANY times!!
+
+These macros operate a stack of objects.  Each object starts life
+small, and may grow to maturity.  (Consider building a word syllable
+by syllable.)  An object can move while it is growing.  Once it has
+been "finished" it never changes address again.  So the "top of the
+stack" is typically an immature growing object, while the rest of the
+stack is of mature, fixed size and fixed address objects.
+
+These routines grab large chunks of memory, using a function you
+supply, called `obstack_chunk_alloc'.  On occasion, they free chunks,
+by calling `obstack_chunk_free'.  You must define them and declare
+them before using any obstack macros.
+
+Each independent stack is represented by a `struct obstack'.
+Each of the obstack macros expects a pointer to such a structure
+as the first argument.
+
+One motivation for this package is the problem of growing char strings
+in symbol tables.  Unless you are "fascist pig with a read-only mind"
+--Gosper's immortal quote from HAKMEM item 154, out of context--you
+would not like to put any arbitrary upper limit on the length of your
+symbols.
+
+In practice this often means you will build many short symbols and a
+few long symbols.  At the time you are reading a symbol you don't know
+how long it is.  One traditional method is to read a symbol into a
+buffer, realloc()ating the buffer every time you try to read a symbol
+that is longer than the buffer.  This is beaut, but you still will
+want to copy the symbol from the buffer to a more permanent
+symbol-table entry say about half the time.
+
+With obstacks, you can work differently.  Use one obstack for all symbol
+names.  As you read a symbol, grow the name in the obstack gradually.
+When the name is complete, finalize it.  Then, if the symbol exists already,
+free the newly read name.
+
+The way we do this is to take a large chunk, allocating memory from
+low addresses.  When you want to build a symbol in the chunk you just
+add chars above the current "high water mark" in the chunk.  When you
+have finished adding chars, because you got to the end of the symbol,
+you know how long the chars are, and you can create a new object.
+Mostly the chars will not burst over the highest address of the chunk,
+because you would typically expect a chunk to be (say) 100 times as
+long as an average object.
+
+In case that isn't clear, when we have enough chars to make up
+the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)
+so we just point to it where it lies.  No moving of chars is
+needed and this is the second win: potentially long strings need
+never be explicitly shuffled. Once an object is formed, it does not
+change its address during its lifetime.
+
+When the chars burst over a chunk boundary, we allocate a larger
+chunk, and then copy the partly formed object from the end of the old
+chunk to the beginning of the new larger chunk.  We then carry on
+accreting characters to the end of the object as we normally would.
+
+A special macro is provided to add a single char at a time to a
+growing object.  This allows the use of register variables, which
+break the ordinary 'growth' macro.
+
+Summary:
+	We allocate large chunks.
+	We carve out one object at a time from the current chunk.
+	Once carved, an object never moves.
+	We are free to append data of any size to the currently
+	  growing object.
+	Exactly one object is growing in an obstack at any one time.
+	You can run one obstack per control block.
+	You may have as many control blocks as you dare.
+	Because of the way we do it, you can `unwind' an obstack
+	  back to a previous state. (You may remove objects much
+	  as you would with a stack.)
+*/
+
+
+/* Don't do the contents of this file more than once.  */
+
+#ifndef _OBSTACK_H
+#define _OBSTACK_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* We need the type of a pointer subtraction.  If __PTRDIFF_TYPE__ is
+   defined, as with GNU C, use that; that way we don't pollute the
+   namespace with <stddef.h>'s symbols.  Otherwise, include <stddef.h>
+   and use ptrdiff_t.  */
+
+#ifdef __PTRDIFF_TYPE__
+# define PTR_INT_TYPE __PTRDIFF_TYPE__
+#else
+# include <stddef.h>
+# define PTR_INT_TYPE ptrdiff_t
+#endif
+
+/* If B is the base of an object addressed by P, return the result of
+   aligning P to the next multiple of A + 1.  B and P must be of type
+   char *.  A + 1 must be a power of 2.  */
+
+#define __BPTR_ALIGN(B, P, A) ((B) + (((P) - (B) + (A)) & ~(A)))
+
+/* Similiar to _BPTR_ALIGN (B, P, A), except optimize the common case
+   where pointers can be converted to integers, aligned as integers,
+   and converted back again.  If PTR_INT_TYPE is narrower than a
+   pointer (e.g., the AS/400), play it safe and compute the alignment
+   relative to B.  Otherwise, use the faster strategy of computing the
+   alignment relative to 0.  */
+
+#define __PTR_ALIGN(B, P, A)						    \
+  __BPTR_ALIGN (sizeof (PTR_INT_TYPE) < sizeof (void *) ? (B) : (char *) 0, \
+		P, A)
+
+#include <string.h>
+
+struct _obstack_chunk		/* Lives at front of each chunk. */
+{
+  char  *limit;			/* 1 past end of this chunk */
+  struct _obstack_chunk *prev;	/* address of prior chunk or NULL */
+  char	contents[4];		/* objects begin here */
+};
+
+struct obstack		/* control current object in current chunk */
+{
+  long	chunk_size;		/* preferred size to allocate chunks in */
+  struct _obstack_chunk *chunk;	/* address of current struct obstack_chunk */
+  char	*object_base;		/* address of object we are building */
+  char	*next_free;		/* where to add next char to current object */
+  char	*chunk_limit;		/* address of char after current chunk */
+  union
+  {
+    PTR_INT_TYPE tempint;
+    void *tempptr;
+  } temp;			/* Temporary for some macros.  */
+  int   alignment_mask;		/* Mask of alignment for each object. */
+  /* These prototypes vary based on `use_extra_arg', and we use
+     casts to the prototypeless function type in all assignments,
+     but having prototypes here quiets -Wstrict-prototypes.  */
+  struct _obstack_chunk *(*chunkfun) (void *, long);
+  void (*freefun) (void *, struct _obstack_chunk *);
+  void *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
+  unsigned use_extra_arg:1;	/* chunk alloc/dealloc funcs take extra arg */
+  unsigned maybe_empty_object:1;/* There is a possibility that the current
+				   chunk contains a zero-length object.  This
+				   prevents freeing the chunk if we allocate
+				   a bigger chunk to replace it. */
+  unsigned alloc_failed:1;	/* No longer used, as we now call the failed
+				   handler on error, but retained for binary
+				   compatibility.  */
+};
+
+/* Declare the external functions we use; they are in obstack.c.  */
+
+extern void _obstack_newchunk (struct obstack *, int);
+extern int _obstack_begin (struct obstack *, int, int,
+			    void *(*) (long), void (*) (void *));
+extern int _obstack_begin_1 (struct obstack *, int, int,
+			     void *(*) (void *, long),
+			     void (*) (void *, void *), void *);
+extern int _obstack_memory_used (struct obstack *);
+
+void obstack_free (struct obstack *obstack, void *block);
+
+
+/* Error handler called when `obstack_chunk_alloc' failed to allocate
+   more memory.  This can be set to a user defined function which
+   should either abort gracefully or use longjump - but shouldn't
+   return.  The default action is to print a message and abort.  */
+extern void (*obstack_alloc_failed_handler) (void);
+
+/* Exit value used when `print_and_abort' is used.  */
+extern int obstack_exit_failure;
+
+/* Pointer to beginning of object being allocated or to be allocated next.
+   Note that this might not be the final address of the object
+   because a new chunk might be needed to hold the final size.  */
+
+#define obstack_base(h) ((void *) (h)->object_base)
+
+/* Size for allocating ordinary chunks.  */
+
+#define obstack_chunk_size(h) ((h)->chunk_size)
+
+/* Pointer to next byte not yet allocated in current chunk.  */
+
+#define obstack_next_free(h)	((h)->next_free)
+
+/* Mask specifying low bits that should be clear in address of an object.  */
+
+#define obstack_alignment_mask(h) ((h)->alignment_mask)
+
+/* To prevent prototype warnings provide complete argument list.  */
+#define obstack_init(h)						\
+  _obstack_begin ((h), 0, 0,					\
+		  (void *(*) (long)) obstack_chunk_alloc,	\
+		  (void (*) (void *)) obstack_chunk_free)
+
+#define obstack_begin(h, size)					\
+  _obstack_begin ((h), (size), 0,				\
+		  (void *(*) (long)) obstack_chunk_alloc,	\
+		  (void (*) (void *)) obstack_chunk_free)
+
+#define obstack_specify_allocation(h, size, alignment, chunkfun, freefun)  \
+  _obstack_begin ((h), (size), (alignment),				   \
+		  (void *(*) (long)) (chunkfun),			   \
+		  (void (*) (void *)) (freefun))
+
+#define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
+  _obstack_begin_1 ((h), (size), (alignment),				\
+		    (void *(*) (void *, long)) (chunkfun),		\
+		    (void (*) (void *, void *)) (freefun), (arg))
+
+#define obstack_chunkfun(h, newchunkfun) \
+  ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))
+
+#define obstack_freefun(h, newfreefun) \
+  ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))
+
+#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = (achar))
+
+#define obstack_blank_fast(h,n) ((h)->next_free += (n))
+
+#define obstack_memory_used(h) _obstack_memory_used (h)
+
+#if defined __GNUC__ && defined __STDC__ && __STDC__
+/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and
+   does not implement __extension__.  But that compiler doesn't define
+   __GNUC_MINOR__.  */
+# if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)
+#  define __extension__
+# endif
+
+/* For GNU C, if not -traditional,
+   we can define these macros to compute all args only once
+   without using a global variable.
+   Also, we can avoid using the `temp' slot, to make faster code.  */
+
+# define obstack_object_size(OBSTACK)					\
+  __extension__								\
+  ({ struct obstack const *__o = (OBSTACK);				\
+     (unsigned) (__o->next_free - __o->object_base); })
+
+# define obstack_room(OBSTACK)						\
+  __extension__								\
+  ({ struct obstack const *__o = (OBSTACK);				\
+     (unsigned) (__o->chunk_limit - __o->next_free); })
+
+# define obstack_make_room(OBSTACK,length)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->chunk_limit - __o->next_free < __len)			\
+     _obstack_newchunk (__o, __len);					\
+   (void) 0; })
+
+# define obstack_empty_p(OBSTACK)					\
+  __extension__								\
+  ({ struct obstack const *__o = (OBSTACK);				\
+     (__o->chunk->prev == 0						\
+      && __o->next_free == __PTR_ALIGN ((char *) __o->chunk,		\
+					__o->chunk->contents,		\
+					__o->alignment_mask)); })
+
+# define obstack_grow(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->next_free + __len > __o->chunk_limit)			\
+     _obstack_newchunk (__o, __len);					\
+   memcpy (__o->next_free, where, __len);				\
+   __o->next_free += __len;						\
+   (void) 0; })
+
+# define obstack_grow0(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->next_free + __len + 1 > __o->chunk_limit)			\
+     _obstack_newchunk (__o, __len + 1);				\
+   memcpy (__o->next_free, where, __len);				\
+   __o->next_free += __len;						\
+   *(__o->next_free)++ = 0;						\
+   (void) 0; })
+
+# define obstack_1grow(OBSTACK,datum)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   if (__o->next_free + 1 > __o->chunk_limit)				\
+     _obstack_newchunk (__o, 1);					\
+   obstack_1grow_fast (__o, datum);					\
+   (void) 0; })
+
+/* These assume that the obstack alignment is good enough for pointers
+   or ints, and that the data added so far to the current object
+   shares that much alignment.  */
+
+# define obstack_ptr_grow(OBSTACK,datum)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
+     _obstack_newchunk (__o, sizeof (void *));				\
+   obstack_ptr_grow_fast (__o, datum); })				\
+
+# define obstack_int_grow(OBSTACK,datum)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   if (__o->next_free + sizeof (int) > __o->chunk_limit)		\
+     _obstack_newchunk (__o, sizeof (int));				\
+   obstack_int_grow_fast (__o, datum); })
+
+# define obstack_ptr_grow_fast(OBSTACK,aptr)				\
+__extension__								\
+({ struct obstack *__o1 = (OBSTACK);					\
+   *(const void **) __o1->next_free = (aptr);				\
+   __o1->next_free += sizeof (const void *);				\
+   (void) 0; })
+
+# define obstack_int_grow_fast(OBSTACK,aint)				\
+__extension__								\
+({ struct obstack *__o1 = (OBSTACK);					\
+   *(int *) __o1->next_free = (aint);					\
+   __o1->next_free += sizeof (int);					\
+   (void) 0; })
+
+# define obstack_blank(OBSTACK,length)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->chunk_limit - __o->next_free < __len)			\
+     _obstack_newchunk (__o, __len);					\
+   obstack_blank_fast (__o, __len);					\
+   (void) 0; })
+
+# define obstack_alloc(OBSTACK,length)					\
+__extension__								\
+({ struct obstack *__h = (OBSTACK);					\
+   obstack_blank (__h, (length));					\
+   obstack_finish (__h); })
+
+# define obstack_copy(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__h = (OBSTACK);					\
+   obstack_grow (__h, (where), (length));				\
+   obstack_finish (__h); })
+
+# define obstack_copy0(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__h = (OBSTACK);					\
+   obstack_grow0 (__h, (where), (length));				\
+   obstack_finish (__h); })
+
+/* The local variable is named __o1 to avoid a name conflict
+   when obstack_blank is called.  */
+# define obstack_finish(OBSTACK)					\
+__extension__								\
+({ struct obstack *__o1 = (OBSTACK);					\
+   void *__value = (void *) __o1->object_base;				\
+   if (__o1->next_free == __value)					\
+     __o1->maybe_empty_object = 1;					\
+   __o1->next_free							\
+     = __PTR_ALIGN (__o1->object_base, __o1->next_free,			\
+		    __o1->alignment_mask);				\
+   if (__o1->next_free - (char *)__o1->chunk				\
+       > __o1->chunk_limit - (char *)__o1->chunk)			\
+     __o1->next_free = __o1->chunk_limit;				\
+   __o1->object_base = __o1->next_free;					\
+   __value; })
+
+# define obstack_free(OBSTACK, OBJ)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   void *__obj = (OBJ);							\
+   if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \
+     __o->next_free = __o->object_base = (char *)__obj;			\
+   else (obstack_free) (__o, __obj); })
+
+#else /* not __GNUC__ or not __STDC__ */
+
+# define obstack_object_size(h) \
+ (unsigned) ((h)->next_free - (h)->object_base)
+
+# define obstack_room(h)		\
+ (unsigned) ((h)->chunk_limit - (h)->next_free)
+
+# define obstack_empty_p(h) \
+ ((h)->chunk->prev == 0							\
+  && (h)->next_free == __PTR_ALIGN ((char *) (h)->chunk,		\
+				    (h)->chunk->contents,		\
+				    (h)->alignment_mask))
+
+/* Note that the call to _obstack_newchunk is enclosed in (..., 0)
+   so that we can avoid having void expressions
+   in the arms of the conditional expression.
+   Casting the third operand to void was tried before,
+   but some compilers won't accept it.  */
+
+# define obstack_make_room(h,length)					\
+( (h)->temp.tempint = (length),						\
+  (((h)->next_free + (h)->temp.tempint > (h)->chunk_limit)		\
+   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0))
+
+# define obstack_grow(h,where,length)					\
+( (h)->temp.tempint = (length),						\
+  (((h)->next_free + (h)->temp.tempint > (h)->chunk_limit)		\
+   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0),		\
+  memcpy ((h)->next_free, where, (h)->temp.tempint),			\
+  (h)->next_free += (h)->temp.tempint)
+
+# define obstack_grow0(h,where,length)					\
+( (h)->temp.tempint = (length),						\
+  (((h)->next_free + (h)->temp.tempint + 1 > (h)->chunk_limit)		\
+   ? (_obstack_newchunk ((h), (h)->temp.tempint + 1), 0) : 0),		\
+  memcpy ((h)->next_free, where, (h)->temp.tempint),			\
+  (h)->next_free += (h)->temp.tempint,					\
+  *((h)->next_free)++ = 0)
+
+# define obstack_1grow(h,datum)						\
+( (((h)->next_free + 1 > (h)->chunk_limit)				\
+   ? (_obstack_newchunk ((h), 1), 0) : 0),				\
+  obstack_1grow_fast (h, datum))
+
+# define obstack_ptr_grow(h,datum)					\
+( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
+   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		\
+  obstack_ptr_grow_fast (h, datum))
+
+# define obstack_int_grow(h,datum)					\
+( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
+   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			\
+  obstack_int_grow_fast (h, datum))
+
+# define obstack_ptr_grow_fast(h,aptr)					\
+  (((const void **) ((h)->next_free += sizeof (void *)))[-1] = (aptr))
+
+# define obstack_int_grow_fast(h,aint)					\
+  (((int *) ((h)->next_free += sizeof (int)))[-1] = (aint))
+
+# define obstack_blank(h,length)					\
+( (h)->temp.tempint = (length),						\
+  (((h)->chunk_limit - (h)->next_free < (h)->temp.tempint)		\
+   ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0),		\
+  obstack_blank_fast (h, (h)->temp.tempint))
+
+# define obstack_alloc(h,length)					\
+ (obstack_blank ((h), (length)), obstack_finish ((h)))
+
+# define obstack_copy(h,where,length)					\
+ (obstack_grow ((h), (where), (length)), obstack_finish ((h)))
+
+# define obstack_copy0(h,where,length)					\
+ (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))
+
+# define obstack_finish(h)						\
+( ((h)->next_free == (h)->object_base					\
+   ? (((h)->maybe_empty_object = 1), 0)					\
+   : 0),								\
+  (h)->temp.tempptr = (h)->object_base,					\
+  (h)->next_free							\
+    = __PTR_ALIGN ((h)->object_base, (h)->next_free,			\
+		   (h)->alignment_mask),				\
+  (((h)->next_free - (char *) (h)->chunk				\
+    > (h)->chunk_limit - (char *) (h)->chunk)				\
+   ? ((h)->next_free = (h)->chunk_limit) : 0),				\
+  (h)->object_base = (h)->next_free,					\
+  (h)->temp.tempptr)
+
+# define obstack_free(h,obj)						\
+( (h)->temp.tempint = (char *) (obj) - (char *) (h)->chunk,		\
+  ((((h)->temp.tempint > 0						\
+    && (h)->temp.tempint < (h)->chunk_limit - (char *) (h)->chunk))	\
+   ? (int) ((h)->next_free = (h)->object_base				\
+	    = (h)->temp.tempint + (char *) (h)->chunk)			\
+   : (((obstack_free) ((h), (h)->temp.tempint + (char *) (h)->chunk), 0), 0)))
+
+#endif /* not __GNUC__ or not __STDC__ */
+
+#ifdef __cplusplus
+}	/* C++ */
+#endif
+
+#endif /* obstack.h */
diff --git a/src/config.h.in b/src/config.h.in
index 422fd1f..6c6d159 100644
--- a/src/config.h.in
+++ b/src/config.h.in
@@ -425,6 +425,10 @@
 /* Define if you want to include Sun Visual Workshop support. */
 #undef FEAT_SUN_WORKSHOP
 
+/* Define if you want to include GDB support. */
+#undef FEAT_GDB
+
+
 /* Define if you want to include NetBeans integration. */
 #undef FEAT_NETBEANS_INTG
 
diff --git a/src/config.mk.in b/src/config.mk.in
index 3b08766..54a7c70 100644
--- a/src/config.mk.in
+++ b/src/config.mk.in
@@ -86,6 +86,9 @@ HANGULIN_OBJ	= @HANGULIN_OBJ@
 WORKSHOP_SRC	= @WORKSHOP_SRC@
 WORKSHOP_OBJ	= @WORKSHOP_OBJ@
 
+GDB_SRC		= @GDB_SRC@
+GDB_OBJ		= @GDB_OBJ@
+
 NETBEANS_SRC	= @NETBEANS_SRC@
 NETBEANS_OBJ	= @NETBEANS_OBJ@
 
diff --git a/src/configure.in b/src/configure.in
index ed30bed..075c5fc 100644
--- a/src/configure.in
+++ b/src/configure.in
@@ -1731,6 +1731,13 @@ if test "$enable_cscope" = "yes"; then
   AC_DEFINE(FEAT_CSCOPE)
 fi
 
+dnl FEAT_GDB defined later
+AC_MSG_CHECKING(--enable-gdb argument)
+AC_ARG_ENABLE(gdb,
+	[  --enable-gdb       Include GDB support.], ,
+	[enable_gdb="no"])
+AC_MSG_RESULT($enable_gdb)
+
 AC_MSG_CHECKING(--enable-workshop argument)
 AC_ARG_ENABLE(workshop,
 	[  --enable-workshop       Include Sun Visual Workshop support.], ,
@@ -2648,6 +2655,20 @@ AC_SUBST(GUI_LIB_LOC)
 AC_SUBST(GUITYPE)
 AC_SUBST(GUI_X_LIBS)
 
+dnl do not add pty.o when a GUI is used
+if test "$enable_gdb" = "yes"; then
+  AC_DEFINE(FEAT_GDB)
+  if test "x$GUITYPE" = "xNONE"; then
+    GDB_SRC="gdb.c clewn/gdb_lvl2.c clewn/gdb_lvl3.c clewn/misc.c clewn/obstack.c pty.c"
+    GDB_OBJ="objects/gdb.o objects/gdb_lvl2.o objects/gdb_lvl3.o objects/misc.o objects/obstack.o objects/pty.o"
+  else
+    GDB_SRC="gdb.c clewn/gdb_lvl2.c clewn/gdb_lvl3.c clewn/misc.c clewn/obstack.c"
+    GDB_OBJ="objects/gdb.o objects/gdb_lvl2.o objects/gdb_lvl3.o objects/misc.o objects/obstack.o"
+  fi
+  AC_SUBST(GDB_SRC)
+  AC_SUBST(GDB_OBJ)
+fi
+
 if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
   AC_MSG_ERROR([cannot use workshop without Motif])
 fi
diff --git a/src/eval.c b/src/eval.c
index b9d739d..71d80b0 100644
--- a/src/eval.c
+++ b/src/eval.c
@@ -535,6 +535,9 @@ static void f_foldtextresult __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_foreground __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_function __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_garbagecollect __ARGS((typval_T *argvars, typval_T *rettv));
+#ifdef FEAT_GDB
+static void f_gdb __ARGS((typval_T *argvars, typval_T *rettv));
+#endif
 static void f_get __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getbufline __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getbufvar __ARGS((typval_T *argvars, typval_T *rettv));
@@ -7921,6 +7924,9 @@ static struct fst
     {"foreground",	0, 0, f_foreground},
     {"function",	1, 1, f_function},
     {"garbagecollect",	0, 1, f_garbagecollect},
+#ifdef FEAT_GDB
+    {"gdb",		1, 1, f_gdb},
+#endif
     {"get",		2, 3, f_get},
     {"getbufline",	2, 3, f_getbufline},
     {"getbufvar",	2, 3, f_getbufvar},
@@ -11026,6 +11032,26 @@ f_garbagecollect(argvars, rettv)
 	garbage_collect_at_exit = TRUE;
 }
 
+#ifdef FEAT_GDB
+/*
+ * "gdb()" function
+ */
+    static void
+f_gdb(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    char_u *cmd = get_tv_string(&argvars[0]);
+
+    if (*cmd == NUL)
+	gdb_setwinput(gdb, (char_u *)"");   /* open the window input-line */
+    else
+	gdb_docmd(gdb, cmd);	/* send cmd to gdb */
+    rettv->vval.v_number = 1;
+}
+#endif
+
+
 /*
  * "get()" function
  */
@@ -12246,6 +12272,9 @@ f_has(argvars, rettv)
 #if !defined(USE_SYSTEM) && defined(UNIX)
 	"fork",
 #endif
+#ifdef FEAT_GDB
+	"gdb",
+#endif
 #ifdef FEAT_GETTEXT
 	"gettext",
 #endif
diff --git a/src/ex_cmds.c b/src/ex_cmds.c
index b79a259..dfa31d0 100644
--- a/src/ex_cmds.c
+++ b/src/ex_cmds.c
@@ -6785,7 +6785,8 @@ struct sign
 };
 
 static sign_T	*first_sign = NULL;
-static int	next_sign_typenr = 1;
+/* static int	next_sign_typenr = 1; */
+static int	next_sign_typenr = MAX_TYPENR;	/* is decremented */
 
 static int sign_cmd_idx __ARGS((char_u *begin_cmd, char_u *end_cmd));
 static void sign_list_defined __ARGS((sign_T *sp));
@@ -6887,9 +6888,6 @@ ex_sign(eap)
 		/* ":sign define {name} ...": define a sign */
 		if (sp == NULL)
 		{
-		    sign_T	*lp;
-		    int		start = next_sign_typenr;
-
 		    /* Allocate a new sign. */
 		    sp = (sign_T *)alloc_clear((unsigned)sizeof(sign_T));
 		    if (sp == NULL)
@@ -6898,6 +6896,14 @@ ex_sign(eap)
 		    /* Check that next_sign_typenr is not already being used.
 		     * This only happens after wrapping around.  Hopefully
 		     * another one got deleted and we can use its number. */
+
+                    if (VIM_ISDIGIT(*arg))
+                        sp->sn_typenr = atoi((char *)arg);
+                    else
+                    {
+                        sign_T	*lp;
+                        int     start = next_sign_typenr;
+
 		    for (lp = first_sign; lp != NULL; )
 		    {
 			if (lp->sn_typenr == next_sign_typenr)
@@ -6920,6 +6926,7 @@ ex_sign(eap)
 		    sp->sn_typenr = next_sign_typenr;
 		    if (++next_sign_typenr == MAX_TYPENR)
 			next_sign_typenr = 1; /* wrap around */
+                    }
 
 		    sp->sn_name = vim_strsave(arg);
 		    if (sp->sn_name == NULL)  /* out of memory */
diff --git a/src/ex_getln.c b/src/ex_getln.c
index cdd59de..701bfc5 100644
--- a/src/ex_getln.c
+++ b/src/ex_getln.c
@@ -752,6 +752,12 @@ getcmdline(firstc, count, indent)
 #ifdef FEAT_CMDWIN
 	if (c == cedit_key || c == K_CMDWIN)
 	{
+#ifdef FEAT_GDB
+            /* Set cmdfirstc before calling ex_window (up to now it is NUL:
+	     * the input line does not have a '@' leading character) */
+            if (firstc == '@')
+                ccline.cmdfirstc = firstc;
+#endif
 	    /*
 	     * Open a window to edit the command line (and history).
 	     */
@@ -6369,6 +6375,30 @@ ex_window()
     /* don't use a new tab page */
     cmdmod.tab = 0;
 
+# ifdef FEAT_GDB
+    /* Split below the displayed gdb window */
+    if (gdb_iswinput(gdb) && (wp = gdb_window(gdb)) != NULL
+	    && (wp = wp->w_next) != NULL)
+    {
+	linenr_T topline;
+	
+	curwin = wp;
+	curbuf = curwin->w_buffer;
+	topline = curwin->w_topline;
+
+	if (win_split((int)p_cwh, WSP_ABOVE) == FAIL)
+	{
+	    curwin = old_curwin;
+	    curbuf = old_curbuf;
+	    beep_flush();
+	    return K_IGNORE;
+	}
+
+	/* Do not scroll the window below gdb window */
+	set_topline(wp, topline + p_cwh + STATUS_HEIGHT);
+    }
+    else
+# endif
     /* Create a window for the command-line buffer. */
     if (win_split((int)p_cwh, WSP_BOT) == FAIL)
     {
@@ -6414,6 +6444,20 @@ ex_window()
 	set_option_value((char_u *)"ft", 0L, (char_u *)"vim", OPT_LOCAL);
     }
 
+# ifdef FEAT_GDB
+    if (gdb_iswinput(gdb))      /* gdb window input-line */
+    {
+	add_map((char_u *)"<buffer> <C-Z> <C-Z><CR>", INSERT);
+	add_map((char_u *)"<buffer> <Tab> <C-Q><C-I><CR>", INSERT);
+	set_option_value((char_u *)"ft", 0L, (char_u *)"gdb", OPT_LOCAL);
+	set_option_value((char_u *)"fdc", 0L, NULL, OPT_LOCAL);
+
+        /* The window search-line does not have this: with a two lines history,
+	 * the window shows an empty line at top */
+        curwin->w_valid = FALSE;
+    }
+# endif
+
     /* Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin
      * sets 'textwidth' to 78). */
     curbuf->b_p_tw = 0;
@@ -6543,6 +6587,10 @@ ex_window()
 	    cmdwin_result = Ctrl_C;
 	else
 	{
+#ifdef FEAT_GDB
+            if (ccline.cmdfirstc == '@')
+                ccline.cmdfirstc = NUL;
+#endif
 	    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);
 	    ccline.cmdbufflen = ccline.cmdlen + 1;
 	    ccline.cmdpos = curwin->w_cursor.col;
diff --git a/src/feature.h b/src/feature.h
index d4b9aea..d17eede 100644
--- a/src/feature.h
+++ b/src/feature.h
@@ -1290,6 +1290,24 @@
 # endif
 #endif
 
+ /*
+ * +gdb			Gdb interface. Must be included through configure,
+ *			see Makefile and uncomment "--enable-gdb"
+ *			Not included when required features are missing
+ *			and use explicitly the following FEAT_NORMAL features:
+ *			FEAT_CMDWIN FEAT_EVAL FEAT_STL_OPT FEAT_MODIFY_FNAME
+ *			FEAT_SEARCHPATH FEAT_WINDOWS FEAT_QUICKFIX
+ */
+#ifdef FEAT_GDB
+# if !defined(FEAT_NORMAL) || !defined(HAVE_SYS_WAIT_H) || !defined(HAVE_FCNTL_H)
+#  undef FEAT_GDB
+# else
+#  ifndef FEAT_SIGNS
+#   define FEAT_SIGNS	/* include +signs */
+#  endif
+# endif
+#endif
+
 /*
  * +balloon_eval	Allow balloon expression evaluation. Used with a
  *			debugger and for tooltips.
diff --git a/src/gdb.c b/src/gdb.c
new file mode 100644
index 0000000..337b99f
--- /dev/null
+++ b/src/gdb.c
@@ -0,0 +1,2458 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *			gdb support by Xavier de Gaye
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ *
+ * $Id$
+ */
+
+#include "vim.h"
+
+#ifdef FEAT_GDB	    /* possibly undefined in feature.h */
+# include "clewn/obstack.h"
+# include "clewn/gdb.h"
+# include "clewn/misc.h"
+
+# ifndef FEAT_GUI
+#  include "pty.pro"
+# endif
+
+# ifdef HAVE_SYS_WAIT_H
+#  include <sys/wait.h>
+# endif
+
+# ifdef HAVE_FCNTL_H
+#  include <fcntl.h>
+# endif
+
+# if defined(HAVE_SYS_SELECT_H) && \
+	(!defined(HAVE_SYS_TIME_H) || defined(SYS_SELECT_WITH_SYS_TIME))
+#  include <sys/select.h>
+# endif
+
+# ifndef HAVE_SELECT
+#  ifdef HAVE_SYS_POLL_H
+#   include <sys/poll.h>
+#  else
+#   ifdef HAVE_POLL_H
+#    include <poll.h>
+#   endif
+#  endif
+# endif
+
+# ifdef HAVE_TERMIOS_H
+#  include <termios.h>
+# else
+#  include <termio.h>
+# endif
+
+/* sun's sys/ioctl.h redefines symbols from termio world */
+# if defined(HAVE_SYS_IOCTL_H) && !defined(sun)
+#  include <sys/ioctl.h>
+# endif
+
+# define SCROLLOFF	6	/* min lines around frame highlite */
+# define MAXMEM		64L	/* 'maxmem' option */
+
+/* Not allowed after ^O in INS REP mode or from the input-line window */
+# define NOT_ALLOWED_MODE (restart_edit != 0 || cmdwin_type != 0)
+
+/* storage for mtrace hooks */
+# if defined(GDB_MTRACE) && defined(HAVE_MTRACE)
+__ptr_t (*s_malloc) (size_t, const void *);
+void (*s_free) (void *, const void *);
+__ptr_t (*s_realloc) (void *, size_t, const void *);
+# endif	/* GDB_MTRACE */
+
+static int module_state = -1;	/* initial state (not OK, nor FAIL) */
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+static char_u *inputrc;		/* readline inputrc file name */
+# endif
+
+/* The gdb keyword */
+typedef struct
+{
+    int type;
+    char_u *keyword;	/* keyword */
+    char_u *tail;	/* optional tail */
+    regprog_T *regprog;	/* compiled regexp */
+} token_T;
+
+static token_T tokens[] = {
+    {CMD_DIR,	    (char_u *)"dir",	(char_u *)"ectory",	NULL},
+    {CMD_DETACH,    (char_u *)"det",	(char_u *)"ach",	NULL},
+    {CMD_SHELL,	    (char_u *)"she",	(char_u *)"ll",		NULL},
+    {CMD_STEPI,	    (char_u *)"si",	(char_u *)"",		NULL},
+    {CMD_STEPI,	    (char_u *)"stepi",	(char_u *)"",		NULL},
+    {CMD_STEPI,	    (char_u *)"ni",	(char_u *)"",		NULL},
+    {CMD_STEPI,	    (char_u *)"nexti",	(char_u *)"",		NULL},
+    {CMD_EXECF,	    (char_u *)"fil",	(char_u *)"e",		NULL},
+    {CMD_EXECF,	    (char_u *)"ex",	(char_u *)"ec-file",	NULL},
+    {CMD_EXECF,	    (char_u *)"cor",	(char_u *)"e-file",	NULL},
+    {CMD_BREAK,	    (char_u *)"b",	(char_u *)"reak",	NULL},
+    {CMD_BREAK,	    (char_u *)"tb",	(char_u *)"reak",	NULL},
+    {CMD_BREAK,	    (char_u *)"hb",	(char_u *)"reak",	NULL},
+    {CMD_BREAK,	    (char_u *)"thb",	(char_u *)"reak",	NULL},
+    {CMD_DISPLAY,   (char_u *)"disp",	(char_u *)"lay",	NULL},
+    {CMD_CREATEVAR, (char_u *)"cr",	(char_u *)"eatevar",	NULL},
+    {CMD_UP_SILENT, (char_u *)"up-",	(char_u *)"silently",	NULL},
+    {CMD_UP,	    (char_u *)"up",	(char_u *)"",		NULL},
+    {CMD_DOWN_SILENT,(char_u *)"down-",	(char_u *)"silently",	NULL},
+    {CMD_DOWN,	    (char_u *)"do",	(char_u *)"wn",		NULL},
+    {CMD_FRAME,	    (char_u *)"f",	(char_u *)"rame",	NULL},
+    {CMD_DISABLE,   (char_u *)"disab",	(char_u *)"le",		NULL},
+    {CMD_DELETE,    (char_u *)"del",	(char_u *)"ete",	NULL},
+    {CMD_SLECT_FRAME,(char_u *)"sel",	(char_u *)"ect-frame",	NULL},
+    {CMD_SYMF,	    (char_u *)"sy",	(char_u *)"mbol-file",	NULL},
+    {CMD_SYMF,	    (char_u *)"add-sy",	(char_u *)"mbol-file",	NULL},
+    {CMD_ANY,	    NULL,	NULL,		NULL}
+};
+
+/* The gdb pattern */
+typedef struct {
+    int id;		/* pattern id */
+    char_u *str;	/* string pattern */
+    regprog_T *regprog;	/* compiled regexp */
+} pattern_T;
+
+static pattern_T patterns[] = {
+    {PAT_DIR,		(char_u *)"^\\s*Source directories searched:\\s*\\(.*\\)$", NULL},
+    {PAT_CHG_ANNO,	(char_u *)"^\\s*set\\s\\+an\\%[notate]\\s\\+.*$", NULL},
+    {PAT_ADD,		(char_u *)"^0x0*\\(\\x\\+\\)\\>", NULL},
+    {PAT_PID,		(char_u *)"^\\s*at\\%[tach] \\+\\([0-9]\\+\\) *$", NULL},
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+    {PAT_SOURCE,	(char_u *)"^\\s*\\([^:]*\\):\\([^:]*\\):[^:]*:[^:]*:0x0*\\(\\x\\+\\)$", NULL},
+    {PAT_QUERY,		(char_u *)"^.*(y or n) \\=$", NULL},
+    {PAT_YES,		(char_u *)"^\\s*\\(\\<y\\%[es]\\>\\)\\s*$", NULL},
+    {PAT_SFILE,		(char_u *)"^Symbols from\\s*\"\\([^\"]\\+\\)", NULL},
+    {PAT_BP_CONT,	(char_u *)"^\\s*\\(c\\)\\>\\|^\\s*\\(cont\\)\\%[inue]\\>", NULL},
+    {PAT_ASM_FUNC,	(char_u *)"^\\(\\S\\{-1,}\\)\\%((.*)\\)* .*in section .text$", NULL},
+    {PAT_ASM_FUNC_P,	(char_u *)"^.*<\\(\\S\\{-1,}\\)\\%(+\\d\\+\\)*>$", NULL},
+    {PAT_FRAME,		(char_u *)"^#\\d\\+\\s\\+0x0*\\(\\x\\+\\)\\>", NULL},
+# endif
+# ifdef GDB_LVL2_SUPPORT
+    /* MUST add '.*' at end of each info (possibly last) breakpoint field
+     * pattern because GDB adds the hit count, in a new line, after
+     * printing the last field and within its annotation context */
+    {PAT_BP_ASM,	(char_u *)"^<\\(\\S\\+\\)+\\d\\+>.*$\\|^<\\(\\S\\+\\)>.*$", NULL},
+    {PAT_BP_SOURCE,	(char_u *)"^.\\{-}\\(\\S\\+\\):\\(\\d\\+\\).*$", NULL},
+    {PAT_DISPLAY,	(char_u *)"^\\s*disp\\%[lay]\\s*$", NULL},
+    {PAT_DISPINFO,	(char_u *)"^\\(\\d\\+\\):", NULL},
+    {PAT_CREATEVAR,	(char_u *)"^\\s*cr\\%[eatevar]\\>\\s*\\(.*\\)$", NULL},
+# endif
+# ifdef GDB_LVL3_SUPPORT
+    {PAT_CRVAR_FMT,	(char_u *)"^\\s*cr\\%[eatevar]\\>\\s*\\(/[tdxo]\\)\\{,1}\\>\\s*\\(.*\\)$", NULL},
+    {PAT_INFO_FRAME,	(char_u *)"^Stack level \\(\\d\\+\\), frame at ", NULL},
+# endif
+    {0,			NULL, NULL}
+};
+
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+/* gdb readline inputrc file content */
+static char *readline[] = {
+    "set show-all-if-ambiguous on\n",
+	"set completion-query-items 20\n",	/* max without prompting user */
+	"Control-u: unix-line-discard\n",
+	NULL
+};
+# endif
+
+/* Gdb process mgmt */
+# define GDB_STATE(i,s) (((i) != NULL) ? ((((gdb_T *)(i))->state) & (s)):FALSE)
+static void gdb_abort __ARGS((void));
+static int start_gdb_process __ARGS((gdb_T *, char_u *));
+static int module_init __ARGS((void));
+static void module_end __ARGS((void));
+static void clear_gdb_T __ARGS((gdb_T *));
+static int exec_gdb __ARGS((gdb_T *));
+
+/* Window and buffer mgmt */
+static win_T *ftowin __ARGS((char_u *));
+static buf_T *buffer_create __ARGS((char_u *, int, int, int, char_u *));
+static void cursor_atbot __ARGS((gdb_T *));
+static int line_append __ARGS((gdb_T *, char_u *));
+
+/* Utilities */
+static void histdel __ARGS((char_u *));
+
+/** Create gdb, return its handle */
+    gdb_handle_T *
+gdb_new()
+{
+    gdb_T *gdb;
+
+# if defined(GDB_MTRACE) && defined(HAVE_MTRACE)
+    mtrace();
+    mv_hooks;
+#endif
+    /* register an abort function for when allocating memory fails */
+    xatabort(gdb_abort);
+    obstack_alloc_failed_handler = gdb_abort;
+
+    gdb = (gdb_T *)xcalloc((unsigned)sizeof(gdb_T));
+    gdb->state = GS_INIT;
+    gdb->pid   = (pid_t)-1;
+
+    return (gdb_handle_T *)gdb;
+}
+
+/** Abort GDB */
+    static void
+gdb_abort()
+{
+#if defined(GDB_MTRACE) && defined(HAVE_MTRACE)
+    muntrace();
+#endif
+    fprintf(stderr, "\nvirtual memory exhausted\n");
+    mch_exit(1);
+}
+
+/** Delete gdb */
+    void
+gdb_delete(pgdb)
+    gdb_handle_T **pgdb;
+{
+    gdb_T *this;
+
+    if (pgdb == NULL || (this = (gdb_T *)*pgdb) == NULL)
+	return;
+
+    if (this->buf != NULL)	/* wipe out the buffer */
+	(void)do_bufdel(DOBUF_WIPE, (char_u *)"", 1, 0, this->buf->b_fnum, TRUE);
+
+    gdb_close(this);
+    module_end();		/* release module resources */
+    clear_gdb_T(this);
+    xfree(this);
+    *pgdb = NULL;
+# if defined(GDB_MTRACE) && defined(HAVE_MTRACE)
+    muntrace();
+# endif
+}
+
+/** Return TRUE when gdb is running */
+    int
+gdb_isrunning(gdb)
+    gdb_handle_T *gdb;
+{
+    return GDB_STATE(gdb, GS_UP);
+}
+
+/** Return gdb pty file descriptor */
+    int
+gdb_fd(gdb)
+    gdb_handle_T *gdb;
+{
+    return (gdb != NULL ? ((gdb_T *)gdb)->fd : -1);
+}
+
+/** Return gdb process id */
+    pid_t
+gdb_pid(gdb)
+    gdb_handle_T *gdb;
+{
+    return (gdb != NULL ? ((gdb_T *)gdb)->pid : (pid_t)-1);
+}
+
+/** Return TRUE when buf is the gdb buffer */
+    int
+gdb_isbuffer(gdb, buf)
+    gdb_handle_T *gdb;
+    buf_T *buf;		/* buffer to check for */
+{
+    return ((gdb != NULL && ((gdb_T *)gdb)->buf != NULL)
+	    ? ((gdb_T *)gdb)->buf == buf : FALSE);
+}
+
+/** Return TRUE when gdb output may be processed from low level functions */
+    int
+gdb_allowed(gdb)
+    gdb_handle_T *gdb;
+{
+    return (GDB_STATE(gdb, GS_UP) && GDB_STATE(gdb, GS_ALLOWED));
+}
+
+/** Return TRUE when a gdb event is pending */
+    int
+gdb_event(gdb)
+    gdb_handle_T *gdb;
+{
+    return GDB_STATE(gdb, GS_EVENT);
+}
+
+/** Return TRUE when there is a pending SIGCHLD */
+    int
+gdb_sigchld(gdb)
+    gdb_handle_T *gdb;
+{
+    return GDB_STATE(gdb, GS_SIGCHLD);
+}
+
+/** Set or unset a gdb event */
+    void
+gdb_set_event (gdb, set)
+    gdb_handle_T *gdb;
+    int set;		/* TRUE when setting event */
+{
+    if (gdb == NULL)
+	return;
+
+    ((gdb_T *)gdb)->state &= ~GS_EVENT;
+    if (set)
+	((gdb_T *)gdb)->state |= GS_EVENT;
+}
+
+/** Set or unset a SIGCHLD event */
+    void
+gdb_set_sigchld (gdb, set)
+    gdb_handle_T *gdb;
+    int set;		/* TRUE when setting SIGCHLD event */
+{
+    if (gdb == NULL)
+	return;
+
+    ((gdb_T *)gdb)->state &= ~GS_SIGCHLD;
+    if (set)
+	((gdb_T *)gdb)->state |= GS_SIGCHLD;
+}
+
+/**
+ * Entry point for safe_vgetc().
+ * Set a flag to prevent recursion and enable gdb to read its pseudo tty
+ * in the low level routines.
+ * Return safe_vgetc return value.
+ */
+    int
+gdb_safe_vgetc(gdb)
+    gdb_handle_T *gdb;
+{
+    gdb_T *this = (gdb_T *)gdb;
+    int s_a;
+    int rc;
+
+    if (this == NULL)
+	return safe_vgetc();
+
+    s_a = (this->state & GS_ALLOWED);
+
+    /* set state GS_ALLOWED TRUE when called from top level,
+     * not in visual mode and not in the input-line window */
+    if (this->recurse == 0 && cmdwin_type == 0 && !VIsual_active)
+    {
+	this->state |= GS_ALLOWED;
+	s_a = FALSE;
+    }
+    else
+	this->state &= ~GS_ALLOWED;
+
+    this->recurse++;
+    rc = safe_vgetc();	/* call it now */
+    this->recurse--;
+
+    this->state &= ~GS_ALLOWED;
+    if (s_a)
+	this->state |= GS_ALLOWED;
+    return rc;
+}
+
+/** Take note Vim is freeing a buffer */
+    void
+gdb_buffer_free(gdb, buf)
+    gdb_handle_T *gdb;
+    buf_T *buf;		/* buffer being freed */
+{
+    gdb_T *this = (gdb_T *)gdb;
+    bpinfo_T *p, **pt;
+    int i;
+
+    if (this != NULL)
+    {
+	if (this->buf == buf)
+	    this->buf = NULL;
+
+	/* variables window buffer */
+	else if (this->var_buf == buf)
+	{
+	    this->var_buf = NULL;
+
+	    /* call mode specifice var_delete */
+	    if (this->var_delete != NULL)
+		this->var_delete(this);	/* delete all variables */
+	}
+
+	/* asm buffers */
+	else
+	    for (i = 0; i < this->pool.max; i++)
+		if (this->pool.buf[i] == buf)
+		{
+		    this->pool.buf[i] = NULL;
+		    break;
+		}
+
+	/* remove in bpinfo list the records corresponding to the
+	 * signs in buf
+	 * the signs themselves are supposed to be removed by Vim
+	 * in free_buffer()*/
+	for (pt = &(this->bpinfo); *pt != NULL; )
+	{
+	    p = *pt;
+	    if (p->buf == buf)
+	    {
+		gdb_undefine_sign(p->typenr);
+		*pt = p->next;		/* unlink record */
+		xfree(p);
+	    }
+	    else
+		pt = &(p->next);
+	}
+    }
+}
+
+# define STL_GDB  "gdb "
+# define STL_SEP1 "- "
+# define STL_SEP2 " ["
+# define STL_TAIL "]"
+/** Write gdb status line label in dst */
+    void
+gdb_label(gdb, buf, dst, len)
+    gdb_handle_T *gdb;
+    buf_T *buf;		/* stl's buffer */
+    char_u *dst;	/* where to write the label */
+    size_t len;		/* label max length */
+{
+    gdb_T *this = (gdb_T *)gdb;
+    size_t cnt = 0;
+    char_u *fname;
+    size_t l;
+# define STLCPY(s) {\
+	l = (((s)!=NULL) ? STRLEN((s)):0);\
+	l = MIN(l,len-cnt-1);	\
+	STRNCPY(dst+cnt,(s),l);	\
+	cnt+=l;			\
+	}
+
+    /* a console window displaying gdb buffer */
+    if (this != NULL && this->buf == buf && (this->state & GS_UP)
+	    && dst != NULL && len > 0)
+    {
+	STLCPY(STL_GDB);
+	if (this->sfile != NULL)
+	{
+	    STLCPY(STL_SEP1);
+	    fname = gettail(this->sfile);
+	    STLCPY(fname);
+	}
+
+	STLCPY(STL_SEP2);
+	STLCPY(this->status);
+	STLCPY(STL_TAIL);
+	*(dst + cnt) = NUL;
+    }
+}
+
+/** Send a cmd to gdb */
+    void
+gdb_docmd(gdb, cmd)
+    gdb_handle_T *gdb;
+    char_u  *cmd;	/* gdb cmd */
+{
+    gdb_T *this = (gdb_T *)gdb;
+
+    if (this == NULL || NOT_ALLOWED_MODE)
+	return;
+
+    /* start gdb */
+    this->state &= ~GS_STARTED;
+    if (!(this->state & GS_UP) && start_gdb_process(this, cmd) == FAIL)
+	return;
+
+    /* process first cmd later */
+    if (this->state & GS_STARTED)
+	return;
+
+    /* pop up gdb console */
+    gdb_popup_console(this);
+
+    /* The next statement has the following purpose:
+     * When stepping by hitting continuously key 'I', the discarded command
+     * give_warning (see few lines below) may be permanently displayed losing
+     * thus all meaning: better to clear the cmd line before possibly
+     * outputing the msg. */
+    msg_clr_cmdline();
+
+    /* accept one cmd at a time, allow intr */
+    if (cmd != NULL && *cmd != NUL && *(cmd + STRLEN(cmd) - 1) == KEY_INTERUPT)
+	this->oob.state |= OS_INTR;
+    else if (this->oob.state & OS_CMD)
+    {
+	give_warning((char_u *)"GDB busy: command discarded, please retry", TRUE);
+	return;
+    }
+    else
+	this->oob.idx = -1;	/* needed when last oob was aborted with OS_QUITs */
+    this->oob.state |= OS_CMD;
+
+    /* call mode specific docmd */
+    if (this->gdb_docmd != NULL)
+	this->gdb_docmd(this, cmd);
+}
+
+/** Set the cmd to be inserted later in the input-line window */
+    void
+gdb_setwinput(gdb, cmd)
+    gdb_handle_T *gdb;
+    char_u *cmd;	/* cmd to insert */
+{
+    gdb_T *this = (gdb_T *)gdb;
+
+    if (this == NULL || NOT_ALLOWED_MODE)
+	return;
+
+    if (cmd == NULL)
+	cmd = (char_u *)"";
+
+    if (STRCHR(cmd, (int)NL) != NULL)	/* assert no NL in cmd */
+	return;
+
+    xfree(this->winput_cmd);
+    this->winput_cmd = vim_strsave_escaped(cmd, (char_u *)"\"");
+}
+
+/** Return TRUE if we are opening the gdb input-line window */
+    int
+gdb_iswinput(gdb)
+    gdb_handle_T *gdb;
+{
+    return (gdb != NULL ? ((gdb_T *)gdb)->winput_cmd != NULL : FALSE);
+}
+
+/** Launch the input-line window */
+    void
+gdb_winput(gdb)
+    gdb_handle_T *gdb;
+{
+    gdb_T *this = (gdb_T *)gdb;
+    int s_silent = cmd_silent;
+    char_u *cedit = NULL;
+    char_u *cmd = NULL;
+    char_u *res = NULL;
+    char_u key[2] = {NUL, NUL};
+    char_u *trim;
+    char_u *p;
+    char_u *q = NULL;		/* initialized to please the compiler */
+    char_u *r;
+
+    if (this == NULL || NOT_ALLOWED_MODE)
+	return;
+
+    if (this->winput_cmd == NULL || !stuff_empty() || typebuf.tb_len != 0)
+	goto fin;
+
+    /* pop up gdb console */
+    if (this->state & GS_UP)
+	gdb_popup_console(this);
+
+    /* insert in typebuf: <C-F> . "a" . winput_cmd */
+    /* 'a' start insert mode */
+    p = NULL;
+    key[0] = Ctrl_F;
+    gdb_cat(&p, key);
+    gdb_cat(&p, (char_u *)"a");
+    gdb_cat(&p, this->winput_cmd);
+
+    if (ins_typebuf(p, REMAP_NONE, 0, TRUE, TRUE) == FAIL)
+    {
+	xfree(p);
+	goto fin;
+    }
+    xfree(p);
+
+    /* set cedit */
+    (void)get_option_value((char_u *)"cedit", NULL, &cedit, OPT_GLOBAL);
+    set_option_value((char_u *)"cedit", 0L, key, OPT_GLOBAL);
+
+    /* Launch the input-line window */
+    /* careful: must free cmd with vim_free */
+    cmd_silent = FALSE;
+    cmd = getcmdline_prompt((int)'@', NULL, 0, EXPAND_NOTHING, NULL);
+    cmd_silent = s_silent;
+    msg_didout = FALSE;
+
+    /* restore cedit */
+    if (cedit != NULL)
+    {
+	set_option_value((char_u *)"cedit", 0L, cedit, OPT_GLOBAL);
+	xfree(cedit);
+    }
+    cursor_atbot(this);
+
+    /* Do not start gdb when interrupt */
+    if (!(this->state & GS_UP)
+	    && (cmd == NULL || STRCHR(cmd, KEY_INTERUPT) != NULL))
+    {
+	histdel(cmd);
+	goto fin;
+    }
+
+    /* User typed ^C^C: send an interrupt */
+    if (cmd == NULL)
+    {
+	key[0] = KEY_INTERUPT;
+	gdb_docmd(gdb, key);
+    }
+    else	/* Cleanup history */
+    {
+	/* p first word, q first white after last word */
+	trim = (char_u *)clewn_strsave((char *)cmd);
+	r = p = skipwhite(trim);
+	do {
+	    q = skiptowhite(r);
+	    r = skipwhite(q);
+	} while (*r != NUL);
+
+	if ((res = STRCHR(cmd, '\t')) != NULL)
+	{
+	    histdel(cmd);
+	    *(res + 1) = NUL;	/* trim after <Tab> */
+	}
+	else if ((res = STRCHR(cmd, KEY_INTERUPT)) != NULL)
+	{
+	    histdel(cmd);
+	    *(res + 1) = NUL;	/* trim after ^Z */
+	}
+	/* trim surrounding spaces for syntax highliting */
+	else if (trim != NULL && (p != trim || *q != NUL))
+	{
+	    histdel(cmd);
+	    if (*q != NUL)
+		*q = NUL;
+	    if (*p != NUL)
+		add_to_history(HIST_INPUT, p, FALSE, NUL);
+	}
+	xfree(trim);
+
+	FREE(this->winput_cmd);
+
+	/* send cmd */
+	gdb_docmd(gdb, cmd);
+
+	vim_free(cmd);
+	return;
+    }
+fin:
+    vim_free(cmd);
+    FREE(this->winput_cmd);
+}
+
+/**
+ * Invoke parse_output and compute time left to wait for a character in
+ * the caller, mch_inchar.
+ * Return time left or -1 when mch_inchar must trigger the input-line window.
+ */
+    long
+gdb_process_output(gdb, wtime, start)
+    gdb_handle_T *gdb;
+    long wtime;		/* time left */
+    void *start;	/* start time in mch_inchar */
+{
+    gdb_T *this = (gdb_T *)gdb;
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+    struct timeval  * pstart = (struct timeval *)start;
+    struct timeval  tv;
+# endif
+    int rc;
+
+    if (this != NULL && (this->state & GS_ALLOWED))
+    {
+	if (this->parse_output == NULL)
+	    return (wtime > 0 ? wtime : 0L);
+
+	/* call mode specific parser */
+	this->state &= ~GS_ALLOWED;	/* prevent recursion */
+	rc = this->parse_output(this);
+	this->state |= GS_ALLOWED;
+
+	this->state &= ~GS_EVENT;
+
+	if (rc)
+	    return -1L;
+
+	if (wtime > 0)
+	{
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+	    /* compute new remaining time */
+	    if (pstart != NULL)
+	    {
+		gettimeofday(&tv, NULL);
+		wtime -= (tv.tv_sec - pstart->tv_sec) * 1000L
+				+ (tv.tv_usec - pstart->tv_usec) / 1000L;
+		pstart->tv_sec = tv.tv_sec;	/* reset start time */
+		pstart->tv_usec = tv.tv_usec;
+	    }
+	    else
+# endif
+	    {
+		/* estimated gdb processing is 10 msecs */
+		wtime -= 10L;
+	    }
+	}
+    }
+    return (wtime > 0 ? wtime : 0L);
+}
+
+/* Start a gdb process; return OK when succcess, FAIL otherwise */
+    static int
+start_gdb_process(this, cmd)
+    gdb_T *this;
+    char_u *cmd;	/* the first gdb cmd */
+{
+    char_u *res = NULL;
+    char_u *p;
+    int i;
+
+    clear_gdb_T(this);
+
+    if (module_init() == OK && exec_gdb(this) == OK)
+    {
+	/* save first non empty cmd */
+	if (cmd != NULL)
+	{
+	    p = skipwhite(cmd);
+	    if (*p != NUL)
+		this->firstcmd = (char_u *)clewn_strsave((char *)cmd);
+	}
+
+	/* create variables window buffer */
+	if (p_gvar != NULL && *p_gvar != NUL)
+	    this->var_buf = buffer_create(p_gvar, TRUE, TRUE, TRUE, (char_u *)"gdbvar");
+
+	/* create pool of asm buffers */
+	this->pool.max = MIN(ABS(p_asm), ASM_MAX_BUFF);
+	this->pool.idx = 0;
+	for (i = 0; i < this->pool.max; i++)
+	{
+	    gdb_cat(&res, (char_u *)ASM_BUF_NAME);
+	    gdb_cat(&res, gdb_itoa(i + 1));
+
+	    this->pool.buf[i] = buffer_create(res, FALSE, FALSE, FALSE, NULL);
+	    this->pool.age[i] = ASM_OLD;
+	    FREE(res);
+	}
+	this->pool.last = i + 1;
+	cursor_atbot(this);
+
+	this->directories = (char_u *)clewn_strsave(",,");  /* path: current directory */
+	return OK;
+    }
+    return FAIL;
+}
+
+/*
+ * Initialize this module: set inputrc file, define signs, compile regexp.
+ * Return OK when succcess, FAIL otherwise.
+ */
+    static int
+module_init()
+{
+    char_u *s_cpo = p_cpo;
+    pattern_T *pat;
+    token_T *tok;
+    exarg_T eap;
+    char_u *pattern;
+    int len;
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+    char **p;
+    int fd;
+# endif
+
+    if (module_state == -1)
+    {
+	module_state = FAIL;	/* do it only once */
+
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	/* Set gdb readline inputrc file contents
+	 * careful: must free inputrc with vim_free
+	 * We don't know yet if we are going to use GDB/MI, so we need to
+	 * setup inputrc just in case, even though it might never be used */
+	if ((inputrc = vim_tempname((int)'A')) != NULL
+		&& (fd = mch_open((char *)inputrc, O_CREAT | O_RDWR | O_EXTRA, 0644)) >= 0)
+	{
+	    for (p = readline; *p; p++)
+		write(fd, *p, strlen(*p));
+	    close(fd);
+	    vim_setenv((char_u *)"INPUTRC", inputrc);
+	}
+# endif
+
+	/* define breakpoint and frame signs */
+	do_highlight((char_u *)"gdb_bp term=bold ctermbg=Blue ctermfg=Black guibg=Blue guifg=Black", 0, 0);
+	do_highlight((char_u *)"gdb_dbp term=bold ctermbg=Green ctermfg=Black guibg=Green guifg=Black", 0, 0);
+	do_highlight((char_u *)"gdb_fr term=bold ctermbg=DarkYellow ctermfg=Black guibg=DarkYellow guifg=Black", 0, 0);
+
+	/* We use for frame and phantom sign type numbers the same
+	 * value as their sign numbers. They are respectively FRAME_SIGN
+	 * and PHANTOM_SIGN */
+	eap.arg = (char_u *)clewn_strsave(
+		"define 1 linehl=gdb_fr text==> texthl=Search");
+	ex_sign(&eap);
+	xfree(eap.arg);
+
+	eap.arg = (char_u *)clewn_strsave(
+		"define 2 linehl=Normal text=.. texthl=NonText");
+	ex_sign(&eap);
+	xfree(eap.arg);
+
+	/* make sure no sign in use */
+	buf_delete_all_signs();
+
+	/* Compile patterns */
+	p_cpo = (char_u *)"";   /* so that 'l' flag doesn't work */
+	for (pat = patterns; pat->str != NULL; pat++)
+	    if ((pat->regprog = vim_regcomp(pat->str, TRUE)) == NULL)
+		goto fin;
+
+	/* Compile tokens */
+	for (tok = tokens; tok->keyword != NULL; tok++)
+	{
+	    len = (tok->tail != NULL ? STRLEN(tok->tail) : 0);
+
+	    /* pattern: '^\s*\(\<token\%[option]\>\).*$' */
+	    pattern = NULL;
+	    gdb_cat(&pattern, (char_u *)"^\\s*\\(\\<");
+	    gdb_cat(&pattern, tok->keyword);
+
+	    if (len != 0)
+	    {
+		gdb_cat(&pattern, (char_u *)"\\%[");
+		gdb_cat(&pattern, tok->tail);
+		gdb_cat(&pattern, (char_u *)"]");
+	    }
+
+	    gdb_cat(&pattern, (char_u *)"\\>\\).*$");
+
+	    if ((tok->regprog = vim_regcomp(pattern, TRUE)) == NULL)
+	    {
+		xfree(pattern);
+		goto fin;
+	    }
+	    xfree(pattern);
+	}
+
+	module_state = OK;
+    }
+fin:
+    p_cpo = s_cpo;
+    return module_state;
+}
+
+/* Release module resources */
+    static void
+module_end()
+{
+    pattern_T *pat;
+    token_T *tok;
+    exarg_T eap;
+
+    module_state = -1;
+
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+    if (inputrc != NULL)
+    {
+	mch_remove(inputrc);
+	vim_free(inputrc);
+	inputrc = NULL;
+    }
+# endif
+
+    /* remove signs */
+    do_highlight((char_u *)"clear gdb_bp", 0, 0);
+    do_highlight((char_u *)"clear gdb_dbp", 0, 0);
+    do_highlight((char_u *)"clear gdb_fr", 0, 0);
+
+    /* make sure no sign in use */
+    buf_delete_all_signs();
+
+    emsg_skip++;
+    eap.arg = (char_u *)clewn_strsave("undefine 1");
+    ex_sign(&eap);
+    xfree(eap.arg);
+
+    eap.arg = (char_u *)clewn_strsave("undefine 2");
+    ex_sign(&eap);
+    xfree(eap.arg);
+    emsg_skip--;
+
+    /* patterns an tokens */
+    for (pat = patterns; pat->str != NULL; pat++)
+	if (pat->regprog != NULL)
+	    FREE(pat->regprog);
+
+    for (tok = tokens; tok->keyword != NULL; tok++)
+	if (tok->regprog != NULL)
+	    FREE(tok->regprog);
+}
+
+/* Initialize a gdb_T structure */
+    static void
+clear_gdb_T(this)
+    gdb_T *this;
+{
+    if (this != NULL)
+    {
+	this->pid = (pid_t)-1;
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	this->height = 0;
+#endif
+	this->state = GS_INIT;
+	FREE(this->status);
+	this->recurse = 0;
+
+	this->cmd_type = CMD_ANY;
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	this->cli_cmd.state = CS_START;
+	this->cli_cmd.cnt = 0;
+	FREE(this->cli_cmd.gdb);
+	FREE(this->cli_cmd.readline);
+	FREE(this->cli_cmd.echoed);
+#endif
+
+	FREE(this->firstcmd);
+	FREE(this->winput_cmd);
+	FREE(this->directories);
+	FREE(this->sfile);
+
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	this->note = ANO_NONE;
+	this->annoted = FALSE;
+	this->newline = FALSE;
+	FREE(this->annotation);
+#endif
+	FREE(this->line);
+	FREE(this->pc);
+	FREE(this->frame_pc);
+	FREE(this->oob_result);
+	FREE(this->asm_add);
+	FREE(this->asm_func);
+
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	this->bp_state = 0;
+	gdb_free_bplist(&(this->tmplist));
+#endif
+	FREE(this->record);
+	this->cont = FALSE;
+	gdb_free_bplist(&(this->bpinfo));
+	this->frame_curlvl = -1;
+	this->frame_lnum = (linenr_T) -1;
+	FREE(this->frame_fname);
+
+
+	this->fr_buf = NULL;
+
+	this->oob.state = 0;
+	this->oob.idx = -1;
+
+	this->pool.hilite = FALSE;
+
+	/* free mode specific data within gdb_T */
+	if (this->clear_gdb_T != NULL)
+	    this->clear_gdb_T(this);
+
+	this->oobfunc = NULL;
+	this->parse_output = NULL;
+	this->gdb_docmd = NULL;
+	this->var_delete = NULL;
+	this->clear_gdb_T = NULL;
+    }
+}
+
+/* Spawn a gdb process; return OK when sucess, FAIL otherwise */
+    static int
+exec_gdb(this)
+    gdb_T *this;
+{
+    char_u *err = NULL;
+    int fd = -1;	/* slave pty file descriptor */
+    char *tty;		/* pty name */
+    buf_T *buf;
+# ifdef HAVE_TERMIOS_H
+    struct termios tio;
+# else
+    struct termio tio;
+# endif
+
+    /* process already running */
+    if (this->pid != (pid_t)-1 && waitpid(this->pid, NULL, WNOHANG) == 0)
+	return OK;
+
+    /* Open pty */
+    if ((this->fd = OpenPTY(&tty)) < 0
+	    || (fd = open(tty, O_RDWR|O_NOCTTY|O_EXTRA, 0)) < 0
+	    || SetupSlavePTY(fd) == -1)
+    {
+	err = (char_u *)"Cannot open gdb pty";
+	goto err;
+    }
+
+    /* Set terminal attributes */
+# ifdef HAVE_TERMIOS_H
+    if (tcgetattr(fd, &tio) == 0)
+# else
+    if (ioctl(fd, TCGETA, &tio) >= 0)
+# endif
+    {
+	tio.c_oflag &= ~ONLCR;		/* don't map NL to CR-NL on output */
+	tio.c_cc[VINTR] = KEY_INTERUPT;
+# ifdef HAVE_TERMIOS_H
+	if (tcsetattr(fd, TCSAFLUSH, &tio) != 0)
+# else
+	if (ioctl(fd, TCSETA, &tio) < 0)
+# endif
+	{
+	    err = (char_u *)"Cannot set gdb pty";
+	    goto err;
+	}
+    }
+    else
+    {
+	err = (char_u *)"Cannot get gdb pty";
+	goto err;
+    }
+
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+#  if defined(TIOCGWINSZ) && defined(TIOCSWINSZ)
+	{
+	    struct winsize win;
+
+	    /* set tty height */
+	    if (ioctl(fd, TIOCGWINSZ, &win) >= 0)
+	    {
+		win.ws_row = LPP_LINES;
+		if (ioctl(fd, TIOCSWINSZ, &win) >= 0)
+		    this->height = LPP_LINES;
+	    }
+	}
+#  endif
+# endif
+
+    /* Fork */
+    if ((this->pid = fork()) == (pid_t)-1)
+    {
+	err = (char_u *)"Cannot fork gdb";
+	goto err;
+    }
+/* The child */
+    else if (this->pid == (pid_t)0)
+    {
+	/* Grab control of terminal (from `The GNU C Library' (glibc-2.3.1)) */
+	setsid();
+# ifdef TIOCSCTTY
+	if (ioctl(fd, TIOCSCTTY, (char *)NULL) == -1)
+	    _exit(1);
+# else
+	{ int newfd;
+	char *fdname = ttyname(fd);
+
+	/* This might work (it does on Linux) */
+	if (fdname)
+	{
+	    if (fd != 0)
+		close (0);
+	    if (fd != 1)
+		close (1);
+	    if (fd != 2)
+		close (2);
+	    newfd = open(fdname, O_RDWR);
+	    close(newfd);
+	}
+	}
+# endif
+
+	close(0); dup(fd);
+	close(1); dup(fd);
+	close(2); dup(fd);
+
+	if (fd > 2)
+	    close(fd);
+
+	close(this->fd);
+
+	/* close all swap files: on Cygwin, Windows fail to unlink the swap
+	 * files while there is still an open file descriptor held by
+	 * another (child) process */
+	for (buf = firstbuf; buf != NULL; buf = buf->b_next)
+	    if (buf->b_ml.ml_mfp != NULL
+		    && buf->b_ml.ml_mfp->mf_fd >= 0)
+		close(buf->b_ml.ml_mfp->mf_fd);
+
+# ifdef GDB_MI_SUPPORT
+	if (p_gdbmi)
+	{
+	    /* MI mi2 is available starting with GDB 6.0 */
+	    execlp(p_gdp, p_gdp, "--interpreter=mi2", NULL);
+	    _exit(EXIT_FAILURE);
+	}
+# endif
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	clewn_exec((char *)p_gdp);
+# endif /* defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT) */
+
+	_exit(EXIT_FAILURE);
+    }
+/* The parent */
+    else
+    {
+	close(fd);
+	this->state |= GS_UP;
+	this->state |= GS_STARTED;
+
+# ifdef GDB_MI_SUPPORT
+	if (p_gdbmi)
+	{
+	    if (gdb_setup_mi(this) != OK)
+	    {
+		gdb_cat(&err, (char_u *)"Cannot start GDB program \"");
+		gdb_cat(&err, p_gdp);
+		gdb_cat(&err, (char_u *)"\" (MI)");
+		if (err != NULL)
+		{
+		    EMSG(_(err));
+		    xfree(err);
+		}
+		this->state = GS_INIT;
+		return FAIL;
+	    }
+	    else
+		return OK;
+	}
+# endif
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	if (gdb_setup_cli(this) != OK)
+	{
+	    this->state = GS_INIT;
+	    return FAIL;
+	}
+	else
+	    return OK;
+# endif
+
+	this->state = GS_INIT;
+	return FAIL;
+    }
+err:
+    if (this->fd >= 0)
+	close(this->fd);
+    if (fd >= 0)
+	close(fd);
+    if (err != NULL)
+	EMSG(_(err));
+    return FAIL;
+}
+
+# define CG_QUIT "quit\n"
+# define CG_YES  "yes\n"
+# define CG_TERM "Terminated\n\n"
+# define CG_SEP  "########################################################################\n"
+# define CG_POLL 100
+/* Close gdb process */
+    void
+gdb_close(this)
+    gdb_T *this;
+{
+    pid_t pid;
+    int i;
+    int rc;
+
+    if (this->state & GS_CLOSING)	/* prevent recursive calls */
+	return;
+    this->state |= GS_CLOSING;
+
+    this->syntax = TRUE;		/* force syntax highlite */
+    gdb_write_buf(this, (char_u *)CG_TERM, TRUE);
+    gdb_write_buf(this, (char_u *)CG_SEP, TRUE);
+    this->syntax = FALSE;
+
+    if (this->buf != NULL)
+	close_windows(this->buf, FALSE);
+
+    buf_delete_all_signs();
+
+    /* wipe out variables window buffer */
+    if (this->var_buf != NULL)
+	(void)do_bufdel(DOBUF_WIPE, (char_u *)"", 1, 0, this->var_buf->b_fnum, TRUE);
+
+    /* wipe out asm buffers */
+    for (i = 0; i < this->pool.max; i++)
+	if (this->pool.buf[i] != NULL)
+	    (void)do_bufdel(DOBUF_WIPE, (char_u *)"", 1, 0, this->pool.buf[i]->b_fnum, TRUE);
+
+    /* free breakpoints table */
+    gdb_free_bplist(&(this->bpinfo));
+
+    /*  a) attempt to gracefully terminate gdb process
+     *  b) if this fails, SIGTERM it
+     *  c) if this fails, too bad, just return */
+    if (this->pid != (pid_t)-1)
+    {
+	pid = waitpid(this->pid, NULL, WNOHANG);
+
+	if ((pid == (pid_t)-1 && errno == ECHILD) || pid == this->pid)
+	    close(this->fd);
+	else	/* still running */
+	{
+	    char c     = KEY_INTERUPT;
+	    int killed = FALSE;
+	    char_u buf[MAX_BUFFSIZE];
+	    int t;
+
+	    /* a) write an interrupt followed by a 'quit' cmd */
+	    write(this->fd, &c, 1);
+	    if (gdb_read(this, buf, MAX_BUFFSIZE, 1000) >= 0)
+	    {
+		write(this->fd, CG_QUIT, strlen(CG_QUIT));
+		while ((rc = gdb_read(this, buf, MAX_BUFFSIZE, 100)) > 0)
+		    ;
+
+		if (rc != -1)
+		    write(this->fd, CG_YES, strlen(CG_YES));
+	    }
+	    close(this->fd);
+
+	    /* make sure gdb is terminated: poll for waitpid() */
+	    for (t = 0; !killed; t += CG_POLL)
+	    {
+		/* 1 second elapsed since start of polling for waitpid */
+		if (t >= 1000 )
+		{
+# ifdef SIGTERM
+		    /* b) kill it now */
+		    kill(this->pid, SIGTERM);
+# endif
+		    killed = TRUE;
+		}
+
+		mch_delay(CG_POLL, TRUE);
+		pid = waitpid(this->pid, NULL, WNOHANG);
+		if ((pid == (pid_t)-1 && errno == ECHILD) || pid == this->pid)
+		    break;
+	    }
+	}
+	MSG_ATTR(_("GDB terminated"), hl_attr(HLF_E));
+    }
+
+    gdb_redraw(curbuf);	/* force redrawing */
+    this->state = GS_INIT;
+    this->pid = (pid_t)-1;
+}
+
+/* Highlite asm_add line; return TRUE when asm_add found in asm buffer */
+    int
+gdb_as_frset(this, obs)
+    gdb_T *this;
+    struct obstack *obs;
+{
+    char_u *ptrn = NULL;
+    int first = this->pool.idx;
+    pos_T pos;
+    win_T *win;
+    int i;
+
+    if (this->asm_func == NULL)
+	return FALSE;
+
+    /* age asm buffers */
+    for (i = 0; i < this->pool.max; i++)
+	if (this->pool.age[i] < ASM_OLD)
+	    this->pool.age[i]++;
+
+    if (this->asm_add != NULL)
+    {
+	obstack_strcat(obs, "^\\s*0x0*");
+	obstack_strcat0(obs, this->asm_add);
+	ptrn = (char_u *)obstack_finish(obs);
+    }
+
+    if (ptrn != NULL)
+    {
+	/* Search all asm buffers whose name start with this->asm_func
+	 * for ptrn.
+	 * Start with the current one. */
+	i = first;
+	do
+	{
+	    pos.lnum = 1;
+	    pos.col = 0;
+
+	    if (this->pool.buf[i] != NULL
+		    && STRSTR(this->pool.buf[i]->b_fname, this->asm_func) != NULL
+		    && !(this->pool.buf[i]->b_ml.ml_flags & ML_EMPTY)
+		    && searchit(NULL, this->pool.buf[i], &pos,
+			FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+	    {
+		this->pool.idx = i;
+		this->pool.age[i] = 0;
+		this->pool.lnum = pos.lnum;
+
+		if (this->pool.hilite)
+		    gdb_fr_set(this, NULL, NULL, obs);
+		else if ((win = gdb_btowin(this->pool.buf[i])) != NULL)
+		    gdb_set_cursor(win, pos.lnum);
+
+		FREE(this->asm_add);
+		return TRUE;
+	    }
+	} while ((i = ++i % this->pool.max) != first);
+
+    }
+    return FALSE;
+}
+
+/*
+ * Highlight line within frame
+ * Return -1 when failing to load the buffer, 0 otherwise
+ */
+    int
+gdb_fr_set(this, file, line, obs)
+    gdb_T *this;
+    char_u *file;
+    linenr_T *line;
+    struct obstack *obs;
+{
+    win_T *oldwin = curwin;
+    buf_T *buf = NULL;
+    linenr_T lnum;
+
+    /* Do not set frame hilite when this breakpoint has a 'commands'
+     * with a 'continue' statement */
+    if (this->cont)
+    {
+	this->cont = FALSE;
+	return 0;
+    }
+
+    if (line == NULL)		/* in asm window */
+    {
+	buf = this->pool.buf[this->pool.idx];
+	lnum = this->pool.lnum;
+    }
+    else			/* in source file */
+	lnum = *line;
+
+    if (buf != NULL || file != NULL)
+    {
+	if (gdb_edit_file(this, buf, file, lnum, obs) != NULL)
+	{
+	    /* MUST redraw the screen before calling update_debug_sign():
+	     *	update_debug_sign() invokes win_update()
+	     *	the screen might have been scrolled when Vim ask the
+	     *	user to confirm changes made to the previous buffer */
+	    gdb_redraw(curwin->w_buffer);
+
+	    gdb_fr_lite(this, curwin->w_buffer, lnum, obs);
+	}
+	else {
+	    win_goto(oldwin);
+	    return -1;
+	}
+    }
+    return 0;
+}
+
+/* Highlite frame */
+    void
+gdb_fr_lite(this, buf, lnum, obs)
+    gdb_T *this;
+    buf_T *buf;		/* where to highlite */
+    linenr_T lnum;	/* line number */
+    struct obstack *obs;
+{
+    buf_T *disped = NULL;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    if (buf == NULL || lnum <= 0)
+	return;
+
+    /*
+     * Remove previous frame sign:
+     * GDB sends ANO_FRAME_INVALID annotations whenever stepping, running, etc...
+     * and these annotations invoke gdb_fr_unlite() that turn off the previous frame sign.
+     * But when moving along the stack frame with GDB 'up', 'down', 'frame' commands,
+     * we don't get annotations and must turn off the previous frame sign.
+     */
+    if (this->fr_buf != NULL)
+	disped = gdb_unlite(FRAME_SIGN);
+
+    /* add new frame highlite */
+    buf_addsign(buf, FRAME_SIGN, lnum, FRAME_SIGN);
+    update_debug_sign(buf, lnum);
+
+    /* remove phantom highlite */
+    disped = gdb_unlite(PHANTOM_SIGN);
+
+    this->fr_buf = buf;
+    if (gdb_btowin(buf) != NULL)
+	disped = buf;
+
+    gdb_redraw(disped);	/* only when displayed */
+}
+
+/* Unlite frame */
+    void
+gdb_fr_unlite(this)
+    gdb_T *this;
+{
+    buf_T *disped = NULL;
+    buf_T *buf = this->fr_buf;
+    linenr_T lnum;
+
+    if (buf == NULL)
+	return;
+    this->fr_buf = NULL;
+
+    /* To avoid screen blinks: replace with phantom sign */
+    if (gdb_btowin(buf) != NULL && (lnum = BUFLASTL(buf)) > 0)
+    {
+	buf_addsign(buf, PHANTOM_SIGN, lnum, PHANTOM_SIGN);
+	update_debug_sign(buf, lnum);
+    }
+
+    disped = gdb_unlite(FRAME_SIGN);
+    gdb_redraw(disped);	/* only when displayed */
+}
+
+/*
+ * Unlite a sign.
+ * Return last displayed buffer that contained this sign.
+ */
+    buf_T *
+gdb_unlite(id)
+    int id;		/* sign id */
+{
+    buf_T *disped = NULL;
+    buf_T *buf;
+    linenr_T lnum;
+
+    for (buf = firstbuf; buf != NULL; buf = buf->b_next)
+	if ((lnum = buf_delsign(buf, id)) != 0)
+	{
+	    update_debug_sign(buf, lnum);
+	    if (gdb_btowin(buf) != NULL)
+		disped = buf;
+	}
+    return disped;
+}
+
+/*
+ * Define a breakpoint sign. There is one sign type per breakpoint
+ * sign in order to have breakpoints numbers as the sign text.
+ * Returns sign type number or -1 if error.
+ */
+    int
+gdb_define_sign(id, enabled)
+    int id;		/* breakpoint number */
+    int enabled;	/* TRUE when breakpoint is enabled */
+{
+    exarg_T eap;
+    char_u text[NUMBUFLEN];
+    int r;
+
+    if (id <= 0)
+	return -1;
+
+    /* the sign text is two chars max */
+    if (id < 100)
+	STRCPY(text, gdb_itoa(id));
+    else
+    {
+	if ((r = id % 100) < 10)
+	{
+	    text[0] = '0';
+	    STRCPY(text + 1, gdb_itoa(r));
+	}
+	else
+	    STRCPY(text, gdb_itoa(r));
+    }
+
+    /* With id = 1 and enabled TRUE, build the following:
+     * "define 3 linehl=gdb_bp text=1 texthl=LineNr" */
+    eap.arg = NULL;
+    gdb_cat(&(eap.arg), (char_u *)"define ");
+    gdb_cat(&(eap.arg), gdb_itoa(BP_SIGN_ID(id)));
+    gdb_cat(&(eap.arg), (char_u *)" linehl=");
+
+    if (enabled)
+	gdb_cat(&(eap.arg), (char_u *)"gdb_bp");
+    else
+	gdb_cat(&(eap.arg), (char_u *)"gdb_dbp");
+
+    gdb_cat(&(eap.arg), (char_u *)" text=");
+    gdb_cat(&(eap.arg), text);
+    gdb_cat(&(eap.arg), (char_u *)" texthl=LineNr");
+
+    ex_sign(&eap);
+    xfree(eap.arg);
+    return BP_SIGN_ID(id);
+}
+
+/* Undefine a breakpoint sign */
+    void
+gdb_undefine_sign(typenr)
+    int typenr;		/* sign type number to undefine */
+{
+    exarg_T eap;
+
+    if (typenr <= 0)
+	return;
+
+    emsg_skip++;
+    eap.arg = NULL;
+    gdb_cat(&(eap.arg), (char_u *)"undefine ");
+    gdb_cat(&(eap.arg), gdb_itoa(typenr));
+    ex_sign(&eap);
+    xfree(eap.arg);
+    emsg_skip--;
+}
+
+/** Return the (first) console window where is displayed gdb */
+    win_T *
+gdb_window(gdb)
+    gdb_handle_T *gdb;
+{
+    return (gdb != NULL ? gdb_btowin(((gdb_T *)gdb)->buf): NULL);
+}
+
+/* Return (first) window where buf is displayed */
+    win_T *
+gdb_btowin(buf)
+    buf_T *buf;
+{
+    win_T *win;
+
+    if (buf != NULL)
+	for (win = firstwin; win != NULL; win = win->w_next)
+	    if (win->w_buffer == buf)
+		return win;
+    return NULL;
+}
+
+/* Return (first) window where file fname is displayed */
+    static win_T *
+ftowin(fname)
+    char_u *fname;
+{
+    buf_T *buf = NULL;
+    char_u *name;
+
+    /* first make the name into a full path name
+     * force expansion, get rid of symbolic links */
+    if (fname != NULL && (name = FullName_save(fname, TRUE)) != NULL)
+    {
+	buf = buflist_findname(name);
+	xfree(name);
+    }
+    return gdb_btowin(buf);
+}
+
+/* Pop up gdb console, load the buffer when first time */
+    void
+gdb_popup_console(this)
+    gdb_T *this;
+{
+    win_T *oldwin = curwin;
+    char_u *name  = NULL;
+    long s_mm     = p_mm;
+    long splitbelow;
+    long splitright;
+    int flags;
+
+    /* already displayed */
+    if (this->buf != NULL && gdb_btowin(this->buf) != NULL)
+	return;
+
+    /* get a unique name */
+    if (this->buf == NULL &&
+	    (! (this->state & GS_UP)
+	     || (name = vim_tempname((int)'A')) == NULL))
+	return;
+
+    /* get splitbelow and splitright options values */
+    (void) get_option_value((char_u *)"sb", &splitbelow, NULL, OPT_LOCAL);
+    (void) get_option_value((char_u *)"spr", &splitright, NULL, OPT_LOCAL);
+
+    if (splitbelow) {
+	if (splitright)
+	    flags = WSP_BOT;		    /* bottom */
+	else
+	    flags = WSP_VERT | WSP_TOP;	    /* left */
+    }
+    else {
+	if (splitright)
+	    flags = WSP_VERT | WSP_BOT;	    /* right */
+	else
+	    flags = WSP_TOP;		    /* the default: top */
+    }
+
+    /* create new window */
+    if (win_split(p_pvh > 0 ? p_pvh : 0, flags) == FAIL)
+    {
+	vim_free(name);	    /* free name with vim_free */
+	return;
+    }
+
+    if (this->buf == NULL)
+    {
+	p_mm = MAXMEM;	/* buffer max virtual memory */
+	(void)do_ecmd(0, name, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);
+	p_mm = s_mm;
+
+	vim_free(name);			/* free name with vim_free */
+	msg_clr_cmdline();
+	curwin->w_alt_fnum = 0;		/* no alternate */
+	this->buf = curbuf;
+
+	/* set buffer local options
+	 * wrap, linebreak, nomodifiable, nolist
+	 * filetype=gdbvim - bufhidden=hide - buftype=nowrite */
+	set_option_value((char_u *)"wrap", 1L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"lbr", 1L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"ma", 0L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"list", 0L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"syn", 0L, (char_u *)"gdbvim", OPT_LOCAL);
+	set_option_value((char_u *)"bh", 0L, (char_u *)"hide", OPT_LOCAL);
+	set_option_value((char_u *)"bt", 0L, (char_u *)"nowrite", OPT_LOCAL);
+	set_option_value((char_u *)"bl", 0L, NULL, OPT_LOCAL);
+    }
+    else if (this->buf != curbuf)
+    {
+	set_curbuf(this->buf, DOBUF_GOTO);
+
+	/* nobuflisted must be set each time it's displayed */
+	set_option_value((char_u *)"bl", 0L, NULL, OPT_LOCAL);
+    }
+
+    /* return to previous window */
+    if (win_valid(oldwin))
+    {
+	prevwin = oldwin;
+	win_goto(oldwin);
+    }
+}
+
+/* Create an assembly buffer */
+    static buf_T *
+buffer_create(name, wrap, modifiable, listed, syntax)
+    char_u *name;	/* buffer name */
+    int wrap;		/* TRUE when option 'wrap' is set */
+    int modifiable;	/* TRUE when option 'modifiable' is set */
+    int listed;		/* TRUE when option 'listed' is set */
+    char_u *syntax;	/* buffer syntax */
+{
+    win_T *oldwin = curwin;
+    buf_T *buf = NULL;
+    win_T *wp;
+    garray_T sizes;
+
+    /* save window sizes */
+    win_size_save(&sizes);
+
+# ifdef FEAT_AUTOCMD
+    ++autocmd_busy;
+# endif
+    /* create a tmp window */
+    if (win_split(0, WSP_BOT) == OK)
+    {
+	/* create the asm buffer empty */
+	(void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);
+	gdb_as_setname(name);
+# ifdef FEAT_AUTOCMD
+	/* allow autocommands for loading syntax */
+	--autocmd_busy;
+# endif
+	set_option_value((char_u *)"wrap", (long)wrap, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"ma", (long)modifiable, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"bl", (long)listed, NULL, OPT_LOCAL);
+
+	if (syntax != NULL)
+	    set_option_value((char_u *)"syn", 0L, syntax, OPT_LOCAL);
+
+	set_option_value((char_u *)"bt", 0L, (char_u *)"nofile", OPT_LOCAL);
+	set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"list", 0L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"bh", 0L, (char_u *)"hide", OPT_LOCAL);
+# ifdef FEAT_AUTOCMD
+	++autocmd_busy;
+# endif
+	if (curwin != oldwin)
+	{
+	    buf = curbuf;
+	    wp = curwin;
+	    win_goto(oldwin);
+	    win_close(wp, FALSE);
+	}
+    }
+# ifdef FEAT_AUTOCMD
+    --autocmd_busy;
+# endif
+    win_size_restore(&sizes);
+    ga_clear(&sizes);
+    return buf;
+}
+
+/* Set a unique buffer name */
+    void
+gdb_as_setname(name)
+    char_u *name;	/* buffer name */
+{
+    char_u *res = NULL;
+    int s_t = p_title;
+    int s_i = p_icon;
+    int i = 0;
+    char_u *buf;
+
+    p_title = p_icon = FALSE;
+    do
+    {
+	buf = gdb_itoa(i);
+	if (i == 0)
+	    *buf = NUL;
+	i++;
+
+	FREE(res);
+	gdb_cat(&res, name);
+	gdb_cat(&res, buf);
+    } while (setfname(curbuf, res, NULL, FALSE) == FAIL);
+
+    xfree(res);
+    p_title = s_t;
+    p_icon  = s_i;
+}
+
+/*
+ * Clear an asm buffer of its content and signs.
+ * Rename it to an asm generic name.
+ */
+    void
+gdb_clear_asmbuf(this, buf)
+    gdb_T *this;
+    buf_T *buf;		/* asm buffer to clear */
+{
+    buf_T *oldbuf = curbuf;
+    char_u *res   = NULL;
+    bpinfo_T *p, **pt;
+    linenr_T lnum;
+
+    if (buf == NULL)
+	return;
+
+    curbuf = buf;
+
+    /* rename buffer if its name is not a generic name */
+    if ((buf->b_sfname == NULL || STRSTR(buf->b_sfname, ASM_BUF_NAME) != buf->b_sfname))
+    {
+	gdb_cat(&res, (char_u *)ASM_BUF_NAME);
+	gdb_cat(&res, gdb_itoa(this->pool.last++));
+	gdb_as_setname(res);
+	FREE(res);
+    }
+
+    lnum = BUFLASTL(buf);
+    while (lnum-- > 0)	/* clear buffer */
+	ml_delete(buf->b_ml.ml_line_count, FALSE);
+    curbuf = oldbuf;
+
+    /* remove all the buffer signs:
+     *	in buf
+     *	their corresponding bpinfo record
+     *	their corresponding sign type */
+    for (pt = &(this->bpinfo); *pt != NULL; )
+    {
+	p = *pt;
+	if (p->buf == buf)
+	{
+	    buf_delsign(buf, BP_SIGN_ID(p->id));
+	    gdb_undefine_sign(p->typenr);
+	    *pt = p->next;		/* unlink record */
+	    xfree(p);
+	}
+	else
+	    pt = &(p->next);
+    }
+
+    /* remove frame sign if present */
+    if (this->fr_buf == buf)
+    {
+	gdb_unlite(FRAME_SIGN);
+	this->fr_buf = NULL;
+    }
+}
+
+/* Put back gdb console's last line at bottom. */
+/* needed after win_close messes up gdb topline when 'equalalways' on */
+    static void
+cursor_atbot(this)
+    gdb_T *this;
+{
+    win_T *oldwin = curwin;
+    win_T *win;
+
+    if ((win = gdb_btowin(this->buf)) != NULL)
+    {
+	curwin = win;
+	curbuf = curwin->w_buffer;
+	scroll_cursor_bot(0, TRUE);
+	redraw_later(VALID);
+	curwin = oldwin;
+	curbuf = curwin->w_buffer;
+    }
+}
+
+/* Append line to gdb buffer */
+    static int
+line_append(this, line)
+    gdb_T *this;
+    char_u *line;	/* line to append */
+{
+    linenr_T lnum = BUFLASTL(this->buf);
+    char_u *res = NULL;
+    win_T *win;
+    int rc;
+
+# define LN_PREFIX   "  "
+    /* disable syntax highliting by prefixing with LN_PREFIX */
+    if (! this->syntax)
+    {
+	gdb_cat(&res, (char_u *)LN_PREFIX);
+	gdb_cat(&res, line);
+	if ((line = res) == NULL)
+	    return FAIL;
+    }
+
+    /* first line ever: remove empty line after the one just inserted */
+    if ((rc = ml_append(lnum, line, 0, 0)) == OK && lnum == 0)
+	ml_delete(this->buf->b_ml.ml_line_count, FALSE);
+
+    if ((win = gdb_btowin(this->buf)) != NULL)
+	redraw_win_later(win, NOT_VALID);
+
+    xfree(res);
+    return rc;
+}
+
+/* Append to/Replace last line in gdb buffer */
+    void
+gdb_write_buf(this, chunk, add)
+    gdb_T *this;
+    char_u *chunk;	/* a chunk may contain one, many or no NL */
+    int add;		/* TRUE when chunk is added */
+{
+    win_T *oldwin = curwin;
+    win_T *win;
+    char_u *start;
+    char_u *ptr;
+    int cnt;		    /* number of lines appended */
+
+    if (chunk == NULL || this->buf == NULL)
+	return;
+
+    /* make a copy */
+    chunk = (char_u *)clewn_strsave((char *)chunk);
+
+    /* set curbuf to buf */
+    curbuf = this->buf;
+
+    /* delete last line */
+    if (!add)
+	ml_delete(this->buf->b_ml.ml_line_count, FALSE);
+
+    /* append to buffer line after line */
+    cnt = 0;
+    for (ptr = start = chunk; *ptr != NUL; ptr++)
+    {
+	if (*ptr == NL)
+	{
+	    *ptr = NUL;
+	    line_append(this, start);
+	    start = ptr + 1;
+	    cnt++;
+	}
+    }
+
+    /* handle an empty line or last non NL terminated stuff */
+    if (start == chunk || *start != NUL)
+    {
+	line_append(this, start);
+	cnt++;
+    }
+
+    changed_lines(this->buf->b_ml.ml_line_count - cnt, 0,
+	    this->buf->b_ml.ml_line_count, cnt);
+
+    /* window displayed */
+    if ((win = gdb_btowin(this->buf)) != NULL)
+    {
+	/* update top line */
+	curwin = win;
+	curwin->w_cursor.lnum = this->buf->b_ml.ml_line_count;
+	update_topline();
+
+	/* status line changed */
+	curwin->w_redr_status = TRUE;
+    }
+
+    curwin = oldwin;
+    curbuf = curwin->w_buffer;
+    xfree(chunk);
+}
+
+/*
+ * Edit a file in a non-console window.
+ * Use buf if non NULL, otherwise fname using gdb source path to find the file.
+ * Return NULL if error, curwin otherwise.
+ */
+    win_T *
+gdb_edit_file(this, buf, fname, lnum, obs)
+    gdb_T *this;
+    buf_T *buf;		/* asm buffer to load */
+    char_u *fname;	/* file name */
+    linenr_T lnum;	/* line number */
+    struct obstack *obs;
+{
+#ifdef GDB_LVL3_SUPPORT
+    char_u * source_cur = this->lvl3.source_cur;    /* GDB current source */
+    char_u * source_list = this->lvl3.source_list;  /* GDB source list */
+#else
+    char_u * source_cur = NULL;
+    char_u * source_list = NULL;
+#endif
+    char_u *fpn;
+    win_T *win;
+    int i;
+
+    if (obs) {}	    /* keep comiler happy */
+
+    if (buf == NULL && (fname == NULL || *fname == NUL))
+	return NULL;
+
+#ifdef FEAT_GUI
+    need_mouse_correct = TRUE;
+#endif
+
+    /* found a window where source is already displayed */
+    if ((win = gdb_btowin(buf)) != NULL || (win = ftowin(fname)) != NULL)
+    {
+	gdb_set_cursor(win, lnum);
+	win_goto(win);
+	return win;
+    }
+    win = NULL;
+
+    /* use a non-console window */
+    if (curbuf == this->buf)
+	for (win = firstwin; win != NULL; win = win->w_next)
+	    if (win->w_buffer != this->buf)
+	    {
+		win_goto(win);
+		break;
+	    }
+
+    if (win == NULL)
+	win = curwin;
+
+    if (buf == NULL)
+    {
+	/* get the first existing full path name in GDB source directories
+	 * matching this name */
+	if ((fpn = (char_u *)get_fullpath((char *)fname, (char *)this->directories,
+			(char *)source_cur, (char *)source_list, obs)) == NULL)
+	{
+	    return NULL;
+	}
+
+	(void)do_ecmd(0, fpn, NULL, NULL, lnum,
+		      (P_HID(curbuf) ? ECMD_HIDE : 0) + ECMD_OLDBUF, curwin);
+    }
+    else if (buf != curbuf)
+	set_curbuf(buf, DOBUF_GOTO);
+
+    /* asm buffers are not listed */
+    if (buf != NULL && buf == curbuf)
+	for (i = 0; i < this->pool.max; i++)
+	    if (this->pool.buf[i] == buf)
+	    {
+		set_option_value((char_u *)"bl", 0L, NULL, OPT_LOCAL);
+		break;
+	    }
+
+    if (win_valid(win))
+    {
+	gdb_set_cursor(win, lnum);
+	prevwin = win;
+	return win;
+    }
+
+    return NULL;
+}
+
+/* Set cursor to lnum with at least SCROLLOFF lines around it */
+    void
+gdb_set_cursor(win, lnum)
+    win_T *win;
+    linenr_T lnum;
+{
+    win_T *oldwin = curwin;
+    long s_so = p_so;
+
+    if (win != NULL)
+    {
+	curwin = win;
+	curbuf = curwin->w_buffer;
+
+	curwin->w_cursor.lnum = lnum;
+	curwin->w_cursor.col = 0;
+	check_cursor();
+
+	if (p_so < SCROLLOFF )
+	    p_so = SCROLLOFF;
+	update_topline();
+
+	win->w_redr_status = TRUE;
+
+	p_so = s_so;
+	curwin = oldwin;
+	curbuf = curwin->w_buffer;
+    }
+}
+
+/* Display a cmd line busy msg */
+    void
+gdb_msg_busy(str)
+    char_u *str;
+{
+    static char *prop[] = { "/", "-", "\\", "|" };
+    static char busy[IOSIZE];
+    static int cnt;
+
+    /* set busy string */
+    if (str != NULL)
+    {
+	STRNCPY(busy, str, IOSIZE - 1);
+	busy[IOSIZE - 1] = NUL;
+    }
+    else
+    {
+	msg_scroll = FALSE;
+	msg_start();
+	msg_outtrans((char_u *)busy);
+	msg_puts((char_u *)" [");
+	msg_puts((char_u *)prop[(++cnt % 4)]);
+	msg_puts((char_u *)"]");
+	msg_clr_eos();
+	out_flush();
+    }
+}
+
+/* Set status and and mark stl dirty */
+    void
+gdb_status(this, status, obs)
+    gdb_T *this;
+    char_u *status;	/* gdb status */
+    struct obstack *obs;
+{
+    win_T *win;
+
+    if (obs) {}	    /* keep comiler happy */
+
+    xfree(this->status);
+    this->status = (char_u *)clewn_strsave((char *)status);
+    if ((win = gdb_btowin(this->buf)) != NULL)
+	win->w_redr_status = TRUE;
+}
+
+/* Update screen when buf is displayed */
+/* needed only from low level functions, not elsewhere */
+    void
+gdb_redraw(buf)
+    buf_T *buf;
+{
+    int s_r = RedrawingDisabled;
+    int s_lz = p_lz;
+    win_T *win;
+
+    if (buf == NULL)
+	return;
+
+    for (win = firstwin; win != NULL; win = win->w_next)
+	if (win->w_buffer == buf)
+	{
+	    RedrawingDisabled = 0;
+	    p_lz = FALSE;
+	    update_screen(0);
+	    RedrawingDisabled = s_r;
+	    p_lz = s_lz;
+
+	    /* reset cursor */
+	    cursor_on();
+	    setcursor();
+	    out_flush();
+	    break;
+	}
+}
+
+/* Do the OOB_COMPLETE part of an oob cmd and send the next one */
+    void
+gdb_oob_send(this, obs)
+    gdb_T *this;
+    struct obstack *obs;
+{
+    int keep    = FALSE;    /* when TRUE, do not switch to next oob function */
+    char *res   = NULL;
+    int *pi     = &(this->oob.idx);
+    int s_a     = (this->state & GS_ALLOWED);
+
+    /* prevent recursive calls to parse_output() since breakpoint
+     * or frame highlighting may cause Vim to query the user when
+     * changes have been made in the previous buffer */
+    this->state &= ~GS_ALLOWED;
+
+    if (this->oobfunc == NULL)
+	return;
+
+    if (*pi == -1)
+    {
+	this->oob.state &= ~OS_INTR;
+	if (this->oob.state & OS_QUIT)
+	    goto quit;
+    }
+
+    if (*pi >= 0 && (this->oobfunc)[*pi].oob != NULL) /* assert != NULL */
+    {
+	if ((this->oobfunc)[*pi].oob(this, OOB_COMPLETE, NULL, obs) != NULL)
+	    keep = TRUE;
+
+	if (this->oob.state & OS_QUIT)
+	    goto quit;
+    }
+
+    if (! keep)
+	++(*pi);
+
+    while ((this->oobfunc)[*pi].oob != NULL && !(this->oob.state & OS_INTR))
+    {
+	if ((res = (this->oobfunc)[*pi].oob(this, OOB_CMD, NULL, obs)) != NULL)
+	{
+	    this->oob.cnt = 0;
+
+	    /* send the command to GDB */
+	    write(this->fd, res, strlen(res));
+
+	    this->state &= ~GS_ALLOWED;
+	    if (s_a)
+		this->state |= GS_ALLOWED;
+	    return;
+	}
+
+	++(*pi);
+    }
+
+    *pi = -1;
+quit:
+    this->oob.state &= ~OS_CMD;
+    this->oob.state &= ~OS_QUIT;
+
+    this->state &= ~GS_ALLOWED;
+    if (s_a)
+	this->state |= GS_ALLOWED;
+}
+
+/* Receive out of band response to idx cmd */
+    void
+gdb_oob_receive(this, chunk, obs)
+    gdb_T *this;
+    char_u *chunk;	/* response (possibly incomplete) */
+    struct obstack *obs;
+{
+    char_u *res = NULL;
+    int s_a = (this->state & GS_ALLOWED);
+
+    /* prevent recursive calls to parse_output() since breakpoint
+     * or frame highlighting may cause Vim to query the user when
+     * changes have been made in the previous buffer */
+    this->state &= ~GS_ALLOWED;
+
+    if (this->oobfunc == NULL)
+	return;
+
+    if(IS_OOBACTIVE(this))
+    {
+	/* silently discard when interrupted */
+	if (!(this->oob.state & OS_INTR) && chunk != NULL)
+	{
+	    if (this->parser != PS_PREPROMPT && this->parser != PS_PROMPT
+		&& (this->oobfunc)[this->oob.idx].oob != NULL) /* assert != NULL */
+	    {
+		this->oob.cnt++;
+		(void)(this->oobfunc)[this->oob.idx].oob(this, OOB_COLLECT, chunk, obs);
+
+		this->state &= ~GS_ALLOWED;
+		if (s_a)
+		    this->state |= GS_ALLOWED;
+		return;
+	    }
+	}
+
+	/* keep the last prompt */
+	if (this->parser == PS_PREPROMPT)
+	{
+	    gdb_cat(&res, this->line);
+	    gdb_cat(&res, chunk);
+	    xfree(this->line);
+	    this->line = res;
+	}
+    }
+
+    this->state &= ~GS_ALLOWED;
+    if (s_a)
+	this->state |= GS_ALLOWED;
+}
+
+/*
+ * Fill up buff with a NUL terminated string of max size - 1 bytes from gdb.
+ * Return bytes read count, -1 if error or zero for nothing to read.
+ */
+    int
+gdb_read(this, buff, size, wtime)
+    gdb_T *this;
+    char_u *buff;	/* where to write */
+    int size;		/* buff size */
+    int wtime;		/* msecs time out, -1 wait forever */
+{
+    int len;
+    int rc;
+# ifndef HAVE_SELECT
+    struct pollfd fds;
+
+    fds.fd = this->fd;
+    fds.events = POLLIN;
+# else
+    struct timeval tv;
+    struct timeval start_tv;
+    fd_set rfds;
+
+    FD_ZERO(&rfds);
+    FD_SET(this->fd, &rfds);
+
+#  ifdef HAVE_GETTIMEOFDAY
+    if (wtime >= 0)
+	gettimeofday(&start_tv, NULL);
+#  endif
+# endif
+
+    if (size <= 0 || buff == NULL || !(this->state & GS_UP))
+	return -1;
+
+    /* make sure there is some data to read */
+    while (1)
+    {
+	if (this->state & GS_SIGCHLD)
+	    goto close;
+
+# ifndef HAVE_SELECT
+	if ((rc = poll(&fds, 1, wtime)) > 0)
+# else
+	if (wtime >= 0)
+	{
+	    tv.tv_sec = wtime / 1000;
+	    tv.tv_usec = (wtime % 1000) * (1000000/1000);
+	}
+
+	if ((rc = select(this->fd + 1, &rfds, NULL, NULL, (wtime >= 0) ? &tv : NULL)) > 0)
+# endif
+	    break;
+
+	if (rc == -1 && errno == EINTR)
+	{
+	    if (wtime >= 0)
+	    {
+		/* compute remaining wait time */
+# if ! defined(HAVE_SELECT) || ! defined(HAVE_GETTIMEOFDAY)
+		/* guess: interrupted halfway, gdb processing 10 msecs */
+		wtime = wtime / 2 - 10L;
+# else
+		gettimeofday(&tv, NULL);
+		wtime -= (tv.tv_sec - start_tv.tv_sec) * 1000L
+				+ (tv.tv_usec - start_tv.tv_usec) / 1000L;
+# endif
+		if (wtime < 0)
+		    return 0;
+	    }
+	}
+	else if (rc == 0)
+	    return 0;
+	else
+	    goto close;
+    }
+
+    /* read the data */
+    if ((len = read(this->fd, (char *)buff, size - 1)) < 0)
+	goto close;
+
+    buff[len] = NUL;
+    return len;
+close:
+    gdb_close(this);
+    return -1;
+}
+
+/* Free a bpinfo_T list and set address referenced by plist to NULL */
+    void
+gdb_free_bplist (plist)
+    bpinfo_T ** plist;
+{
+    bpinfo_T *p, *next;
+
+    if (plist == NULL)
+	return;
+
+    for (p = *plist; p != NULL; p = next)
+    {
+	gdb_undefine_sign(p->typenr);
+	next = p->next;
+	xfree(p);
+    }
+
+    *plist = NULL;
+}
+
+/* Remove str from input history */
+    static void
+histdel(str)
+    char_u *str;	/* string to remove */
+{
+    char_u *pat;
+    char_u *res;
+
+    if (str != NULL && (res = vim_strsave_escaped(str, (char_u *)"\\")) != NULL)
+    {
+	/* nomagic: only the backslash has a special meaning */
+	pat = NULL;
+	gdb_cat(&pat, (char_u *)"\\V\\^");
+	gdb_cat(&pat, res);
+	gdb_cat(&pat, (char_u *)"\\$");
+
+	(void)del_history_entry(HIST_INPUT, pat);
+	xfree(pat);
+
+	xfree(res);
+    }
+}
+
+/* Get the GDB command type */
+    void
+gdb_cmd_type(this, cmd)
+    gdb_T *this;
+    char_u *cmd;
+{
+    regmatch_T regmatch;
+    token_T *tok;
+
+    regmatch.rm_ic = FALSE;	/* always match case */
+    this->cmd_type = CMD_ANY;
+    for (tok = tokens; tok->keyword != NULL; tok++)
+	if ((regmatch.regprog = tok->regprog) != NULL
+		&& vim_regexec(&regmatch, cmd, (colnr_T)0))
+	{
+	    this->cmd_type = tok->type;
+	    break;
+	}
+}
+
+/*
+ * Append src to string pointed to by pdest or copy src to a new allocated
+ * string when *pdest is NULL.
+ * *pdest is reallocated to make room for src.
+ * Append an empty string when src is NULL.
+ */
+    void
+gdb_cat(pdest, src)
+    char_u **pdest;	/* string address to append to */
+    char_u *src;	/* string to append */
+{
+    int ldest = (*pdest != NULL ? STRLEN(*pdest) : 0);
+    int lsrc  = (src != NULL ? STRLEN(src) : 0);
+    char_u *res;
+
+    if (lsrc != 0 || *pdest == NULL)
+    {
+	res = (char_u *)xmalloc(ldest + lsrc + 1);
+
+	if (ldest == 0)
+	{
+	    if (lsrc != 0)
+		STRCPY(res, src);
+	    else
+		STRCPY(res, "");
+	}
+	else
+	{
+	    STRCPY(res, *pdest);
+	    STRCAT(res, src);	/* assert src != NULL */
+	}
+
+	xfree(*pdest);
+	*pdest = res;
+    }
+}
+
+/*
+ * Return an allocated string that is the sub-match indexed by subid ([0-9])
+ * using compiled pattern id.
+ * Return NULL if str does not match (or no such sub-match in pattern).
+ */
+    char_u *
+gdb_regexec(str, id, subid, obs)
+    char_u *str;	/* string to match against */
+    int id;		/* pattern id */
+    int subid;		/* sub-match index */
+    struct obstack *obs;/* obstack to use for allocating memory */
+{
+    pattern_T *pat;
+    regmatch_T regmatch;
+
+    if (str == NULL || *str == NUL || subid < 0 || subid > 9)
+	return NULL;
+
+    for (pat = patterns; pat->str != NULL; pat++)
+	if (pat->id == id)
+	{
+	    regmatch.rm_ic = FALSE;	/* always match case */
+	    if ((regmatch.regprog = pat->regprog) != NULL
+		    && vim_regexec(&regmatch, str, (colnr_T)0)
+		    && regmatch.startp[subid] != NULL)
+	    {
+		if (obs != NULL)
+		    return (char_u *)obstack_copy0(obs, regmatch.startp[subid],
+			    (int)(regmatch.endp[subid] - regmatch.startp[subid]));
+		else
+		    return (char_u *)clewn_strnsave((char *)regmatch.startp[subid],
+			    (int)(regmatch.endp[subid] - regmatch.startp[subid]));
+	    }
+	    break;
+	}
+    return NULL;
+}
+
+/* Return an integer as a string */
+    char_u *
+gdb_itoa(i)
+    int i;		/* integer to stringify */
+{
+    static char buf[NUMBUFLEN];
+
+    sprintf(buf, "%ld", (long)i);
+    return (char_u *)buf;
+}
+#endif /* FEAT_GDB */
+
diff --git a/src/globals.h b/src/globals.h
index feb1dd4..4ddc189 100644
--- a/src/globals.h
+++ b/src/globals.h
@@ -1228,6 +1228,10 @@ EXTERN int bevalServers INIT(= 0);
 extern cursorentry_T shape_table[SHAPE_IDX_COUNT];
 #endif
 
+#ifdef FEAT_GDB
+EXTERN gdb_handle_T *gdb INIT(= NULL);	/* gdb opaque handle */
+#endif
+
 #ifdef FEAT_PRINTER
 /*
  * Printer stuff shared between hardcopy.c and machine-specific printing code.
diff --git a/src/gui.c b/src/gui.c
index b667ba3..df9357a 100644
--- a/src/gui.c
+++ b/src/gui.c
@@ -1464,8 +1464,11 @@ again:
     /* Flush pending output before redrawing */
     out_flush();
 
-    gui.num_cols = (pixel_width - gui_get_base_width()) / gui.char_width;
-    gui.num_rows = (pixel_height - gui_get_base_height()) / gui.char_height;
+    /* gui.num_cols = (pixel_width - gui_get_base_width()) / gui.char_width; */
+    /* gui.num_rows = (pixel_height - gui_get_base_height()) / gui.char_height; */
+    gui.num_cols = ((pixel_width - gui_get_base_width()) / (float)gui.char_width) + 0.5;
+    gui.num_rows = ((pixel_height - gui_get_base_height()) / (float)gui.char_height) + 0.5;
+
 
     gui_position_components(pixel_width);
 
@@ -2864,6 +2867,10 @@ gui_wait_for_chars(wtime)
 {
     int	    retval;
 
+#if defined(FEAT_GDB) && defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+    struct timeval  start_tv;
+    gettimeofday(&start_tv, NULL);
+#endif
 #ifdef FEAT_MENU
     /*
      * If we're going to wait a bit, update the menus and mouse shape for the
@@ -2887,7 +2894,35 @@ gui_wait_for_chars(wtime)
 	/* Blink when waiting for a character.	Probably only does something
 	 * for showmatch() */
 	gui_mch_start_blink();
+
+#ifdef FEAT_GDB
+	while ((retval = gui_mch_wait_for_chars(wtime)) == FAIL)
+	{
+	    if (gdb_event(gdb) && gdb_allowed(gdb))
+	    {
+		gui_mch_stop_blink();	// cursor off while drawing status line
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		if ((wtime = gdb_process_output(gdb, wtime, (void *)&start_tv)) < 0)
+# else
+		/* guess we got interrupted halfway */
+		wtime = wtime / 2;
+
+		if ((wtime = gdb_process_output(gdb, wtime, NULL)) < 0)
+# endif
+		{
+		    return 0;    /* launch input-line window */
+		}
+		gui_mch_start_blink();
+
+		if (wtime == 0L)
+		    break;
+	    }
+	    else
+		break;
+	}
+#else
 	retval = gui_mch_wait_for_chars(wtime);
+#endif
 	gui_mch_stop_blink();
 	return retval;
     }
@@ -2903,7 +2938,27 @@ gui_wait_for_chars(wtime)
      * 'updatetime' and if nothing is typed within that time put the
      * K_CURSORHOLD key in the input buffer.
      */
+# ifdef FEAT_GDB
+    for (;;)
+    {
+	retval = gui_mch_wait_for_chars(p_ut);
+	if (retval == FAIL && gdb_event(gdb) && gdb_allowed(gdb))
+	{
+	    gui_mch_stop_blink();	// cursor off while drawing status line
+	    if (gdb_process_output(gdb, -1L, NULL) < 0)
+	    {
+		return 0;    /* launch input-line window */
+	    }
+	    gui_mch_start_blink();
+	}
+	else
+	    break;
+    }
+
+    if (retval == OK)
+# else
     if (gui_mch_wait_for_chars(p_ut) == OK)
+# endif
 	retval = OK;
 #ifdef FEAT_AUTOCMD
     else if (trigger_cursorhold())
@@ -2924,7 +2979,25 @@ gui_wait_for_chars(wtime)
     {
 	/* Blocking wait. */
 	before_blocking();
+#ifdef FEAT_GDB
+	for (;;)
+	{
+	    retval = gui_mch_wait_for_chars(-1L);
+	    if (retval == FAIL && gdb_event(gdb) && gdb_allowed(gdb))
+	    {
+		gui_mch_stop_blink();	// cursor off while drawing status line
+		if (gdb_process_output(gdb, -1L, NULL) < 0)
+		{
+		    return 0;    /* launch input-line window */
+		}
+		gui_mch_start_blink();
+	    }
+	    else
+		break;
+	}
+#else
 	retval = gui_mch_wait_for_chars(-1L);
+#endif
     }
 
     gui_mch_stop_blink();
diff --git a/src/gui_gtk_x11.c b/src/gui_gtk_x11.c
index 05295bf..ec92be4 100644
--- a/src/gui_gtk_x11.c
+++ b/src/gui_gtk_x11.c
@@ -5371,7 +5371,13 @@ gui_mch_draw_part_cursor(int w, int h, guicolor_T color)
 gui_mch_update(void)
 {
     while (g_main_context_pending(NULL) && !vim_is_input_buf_full())
+    {
+#ifdef FEAT_GDB
+	if (gdb_event(gdb))	/* got a gdb event */
+	    return;
+#endif
 	g_main_context_iteration(NULL, TRUE);
+    }
 }
 
     static gint
@@ -5401,6 +5407,24 @@ sniff_request_cb(
 }
 #endif
 
+#ifdef FEAT_GDB
+/*
+ * Callback function, used when data is available on the gdb file descriptor.
+ */
+/* ARGSUSED */
+    static void
+gdb_request_cb(
+    gpointer	data,
+    gint	source_fd,
+    GdkInputCondition condition)
+{
+    gdb_set_event(gdb, TRUE);
+
+    if (gtk_main_level() > 0)
+	gtk_main_quit();
+}
+#endif
+
 /*
  * GUI input routine called by gui_wait_for_chars().  Waits for a character
  * from the keyboard.
@@ -5421,6 +5445,11 @@ gui_mch_wait_for_chars(long wtime)
     static gint	sniff_input_id = 0;
 #endif
 
+#ifdef FEAT_GDB
+    static int gdb_on        = 0;
+    static gint gdb_input_id = 0;
+#endif
+
 #ifdef FEAT_SNIFF
     if (sniff_on && !want_sniff_request)
     {
@@ -5437,6 +5466,25 @@ gui_mch_wait_for_chars(long wtime)
     }
 #endif
 
+#ifdef FEAT_GDB
+    /* Remove call back for previous gdb connection */
+    if (! gdb_allowed(gdb) && gdb_on)
+    {
+	if (gdb_input_id)
+	    gdk_input_remove(gdb_input_id);
+	gdb_on = 0;
+    }
+
+    /* A new gdb connection */
+    if (gdb_allowed(gdb) && !gdb_on)
+    {
+	/* Add gdb file descriptor to watch for available data in main loop. */
+	gdb_input_id = gdk_input_add(gdb_fd(gdb),
+			       GDK_INPUT_READ, gdb_request_cb, NULL);
+	gdb_on = 1;
+    }
+#endif
+
     timed_out = FALSE;
 
     /* this timeout makes sure that we will return if no characters arrived in
@@ -5481,6 +5529,15 @@ gui_mch_wait_for_chars(long wtime)
 		gtk_timeout_remove(timer);
 	    return OK;
 	}
+
+#ifdef FEAT_GDB
+	if (wtime != 0L && gdb_allowed(gdb) && gdb_event(gdb))
+	{
+	    if (timer != 0 && !timed_out)
+		gtk_timeout_remove(timer);
+	    return FAIL;
+	}
+#endif
     } while (wtime < 0 || !timed_out);
 
     /*
diff --git a/src/gui_x11.c b/src/gui_x11.c
index ed71b26..8222736 100644
--- a/src/gui_x11.c
+++ b/src/gui_x11.c
@@ -148,6 +148,9 @@ static void gui_x11_mouse_cb __ARGS((Widget w, XtPointer data, XEvent *event, Bo
 #ifdef FEAT_SNIFF
 static void gui_x11_sniff_request_cb __ARGS((XtPointer closure, int *source, XtInputId *id));
 #endif
+#ifdef FEAT_GDB
+static void gdb_request_cb __ARGS((XtPointer closure, int *source, XtInputId *id));
+#endif
 static void gui_x11_check_copy_area __ARGS((void));
 #ifdef FEAT_CLIENTSERVER
 static void gui_x11_send_event_handler __ARGS((Widget, XtPointer, XEvent *, Boolean *));
@@ -1172,6 +1175,21 @@ gui_x11_sniff_request_cb(closure, source, id)
 }
 #endif
 
+#ifdef FEAT_GDB
+/*
+ * Callback function, used when data is available on the gdb file descriptor.
+ */
+/* ARGSUSED */
+    static void
+gdb_request_cb (closure, source, id)
+    XtPointer	closure;
+    int		*source;
+    XtInputId	*id;
+{
+    gdb_set_event(gdb, TRUE);
+}
+#endif
+
 /*
  * End of call-back routines
  */
@@ -2825,7 +2843,13 @@ gui_mch_update()
 	desired = (XtIMAll);
     while ((mask = XtAppPending(app_context)) && (mask & desired)
 	    && !vim_is_input_buf_full())
+    {
+#ifdef FEAT_GDB
+	if (gdb_event(gdb))	/* got a gdb event */
+	    return;
+#endif
 	XtAppProcessEvent(app_context, desired);
+    }
 }
 
 /*
@@ -2855,6 +2879,11 @@ gui_mch_wait_for_chars(wtime)
     static XtInputId sniff_input_id = 0;
 #endif
 
+#ifdef FEAT_GDB
+    static int gdb_on = 0;
+    static XtInputId gdb_input_id = 0;
+#endif
+
     timed_out = FALSE;
 
 #ifdef FEAT_SNIFF
@@ -2872,6 +2901,25 @@ gui_mch_wait_for_chars(wtime)
     }
 #endif
 
+#ifdef FEAT_GDB
+    /* Remove call back for previous gdb connection */
+    if (! gdb_allowed(gdb) && gdb_on)
+    {
+	if (gdb_input_id)
+	    XtRemoveInput(gdb_input_id);
+	gdb_on = 0;
+    }
+
+    /* A new gdb connection */
+    if (gdb_allowed(gdb) && !gdb_on)
+    {
+	/* Add gdb file descriptor to watch for available data in main loop. */
+	gdb_input_id = XtAppAddInput(app_context, gdb_fd(gdb),
+		     (XtPointer)XtInputReadMask, gdb_request_cb, 0);
+	gdb_on = 1;
+    }
+#endif
+
     if (wtime > 0)
 	timer = XtAppAddTimeOut(app_context, (long_u)wtime, gui_x11_timer_cb,
 								  &timed_out);
@@ -2916,6 +2964,15 @@ gui_mch_wait_for_chars(wtime)
 		XtRemoveTimeOut(timer);
 	    return OK;
 	}
+
+#ifdef FEAT_GDB
+	if (wtime != 0L && gdb_allowed(gdb) && gdb_event(gdb))
+	{
+	    if (timer != (XtIntervalId)0 && !timed_out)
+		XtRemoveTimeOut(timer);
+	    return FAIL;
+	}
+#endif
     }
     return FAIL;
 }
diff --git a/src/main.c b/src/main.c
index 884a308..0b2fdc6 100644
--- a/src/main.c
+++ b/src/main.c
@@ -203,6 +203,10 @@ main
     vim_tcl_init(params.argv[0]);
 #endif
 
+#ifdef FEAT_GDB
+    gdb = gdb_new();
+#endif
+
 #ifdef MEM_PROFILE
     atexit(vim_mem_profile_dump);
 #endif
@@ -1432,6 +1436,11 @@ getout(exitval)
     }
 #endif
 
+#ifdef FEAT_GDB
+    /* Before viminfo stuff to wipeout gdb buffer and remove from list */
+    gdb_delete(&gdb);
+#endif
+
 #ifdef FEAT_VIMINFO
     if (*p_viminfo != NUL)
 	/* Write out the registers, history, marks etc, to the viminfo file */
diff --git a/src/normal.c b/src/normal.c
index 80ada68..39708e9 100644
--- a/src/normal.c
+++ b/src/normal.c
@@ -660,9 +660,23 @@ normal_cmd(oap, toplevel)
 	set_vcount_ca(&ca, &set_prevcount);
 #endif
 
+#if defined(FEAT_GDB) && defined(FEAT_CMDWIN)
+    /* Launch the input-line window */
+    if (cmdwin_type == 0 && gdb_iswinput(gdb))
+    {
+	gdb_winput(gdb);
+	goto normal_end;
+    }
+#endif
+
     /*
      * Get the command character from the user.
      */
+#ifdef FEAT_GDB
+    if (toplevel)
+        c = gdb_safe_vgetc(gdb);
+    else
+#endif
     c = safe_vgetc();
     LANGMAP_ADJUST(c, TRUE);
 
@@ -746,6 +760,11 @@ getcount:
 		++allow_keys;		/* no mapping for nchar, but keys */
 	    }
 	    ++no_zero_mapping;		/* don't map zero here */
+#ifdef FEAT_GDB
+            if (toplevel)
+                c = gdb_safe_vgetc(gdb);
+            else
+#endif
 	    c = plain_vgetc();
 	    LANGMAP_ADJUST(c, TRUE);
 	    --no_zero_mapping;
@@ -769,6 +788,11 @@ getcount:
 	    ca.count0 = 0;
 	    ++no_mapping;
 	    ++allow_keys;		/* no mapping for nchar, but keys */
+#ifdef FEAT_GDB
+            if (toplevel)
+                c = gdb_safe_vgetc(gdb);
+            else
+#endif
 	    c = plain_vgetc();		/* get next character */
 	    LANGMAP_ADJUST(c, TRUE);
 	    --no_mapping;
@@ -957,6 +981,11 @@ getcount:
 	     * For 'g' get the next character now, so that we can check for
 	     * "gr", "g'" and "g`".
 	     */
+#ifdef FEAT_GDB
+            if (toplevel)
+                ca.nchar = gdb_safe_vgetc(gdb);
+            else
+#endif
 	    ca.nchar = plain_vgetc();
 	    LANGMAP_ADJUST(ca.nchar, TRUE);
 #ifdef FEAT_CMDL_INFO
@@ -1015,6 +1044,12 @@ getcount:
 		im_set_active(TRUE);
 #endif
 
+#ifdef FEAT_GDB
+            if (toplevel)
+                *cp = gdb_safe_vgetc(gdb);
+            else
+#endif
+
 	    *cp = plain_vgetc();
 
 	    if (langmap_active)
@@ -1122,6 +1157,11 @@ getcount:
 	    while (enc_utf8 && lang && (c = vpeekc()) > 0
 				 && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))
 	    {
+#ifdef FEAT_GDB
+                if (toplevel)
+                    c = gdb_safe_vgetc(gdb);
+                else
+#endif
 		c = plain_vgetc();
 		if (!utf_iscomposing(c))
 		{
@@ -9054,6 +9094,10 @@ nv_esc(cap)
 		&& cap->opcount == 0
 		&& cap->count0 == 0
 		&& cap->oap->regname == 0
+#ifdef FEAT_GDB
+		/* don't beep when opening gdb input-line window */
+		&& !gdb_iswinput(gdb)
+#endif
 		&& !p_im);
 
     if (cap->arg)		/* TRUE for CTRL-C */
diff --git a/src/option.c b/src/option.c
index bf65556..325b1cd 100644
--- a/src/option.c
+++ b/src/option.c
@@ -540,6 +540,12 @@ static struct vimoption
 			    {(char_u *)0L, (char_u *)0L}
 #endif
 			    SCRIPTID_INIT},
+#ifdef FEAT_GDB
+    {"asm",	    NULL,   P_NUM|P_VI_DEF,
+			    (char_u *)&p_asm, PV_NONE,
+			    {(char_u *)10L, (char_u *)0L}},
+#endif
+
 #ifdef FEAT_AUTOCHDIR
     {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_acd, PV_NONE,
@@ -1230,6 +1236,14 @@ static struct vimoption
 			    {(char_u *)FALSE, (char_u *)0L}
 #endif
 			    SCRIPTID_INIT},
+#ifdef FEAT_GDB
+    {"gdbvariables", "gdbvar",P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
+			    (char_u *)&p_gvar, PV_NONE,
+			    {(char_u *)"gdb-variables", (char_u *)0L} },
+    {"gdbprg",	    "gdp",  P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
+			    (char_u *)&p_gdp, PV_NONE,
+			    {(char_u *)"gdb", (char_u *)0L} },
+#endif
     {"gdefault",    "gd",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_gd, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
diff --git a/src/option.h b/src/option.h
index 167b562..f7e90f2 100644
--- a/src/option.h
+++ b/src/option.h
@@ -572,6 +572,11 @@ EXTERN char_u	*p_isi;		/* 'isident' */
 EXTERN char_u	*p_isp;		/* 'isprint' */
 EXTERN int	p_js;		/* 'joinspaces' */
 EXTERN char_u	*p_kp;		/* 'keywordprg' */
+#ifdef FEAT_GDB
+EXTERN long	p_asm;		/* 'asm' */
+EXTERN char_u	*p_gvar;	/* 'gdbvariables' */
+EXTERN char_u	*p_gdp;		/* 'gdbprg' */
+#endif
 #ifdef FEAT_VISUAL
 EXTERN char_u	*p_km;		/* 'keymodel' */
 #endif
diff --git a/src/os_unix.c b/src/os_unix.c
index 37cc3a7..d2b74d7 100644
--- a/src/os_unix.c
+++ b/src/os_unix.c
@@ -197,6 +197,9 @@ static RETSIGTYPE sig_alarm __ARGS(SIGPROTOARG);
 /* volatile because it is used in signal handler sig_alarm(). */
 static volatile int sig_alarm_called;
 #endif
+#if defined(FEAT_GDB) && defined(SIGCHLD)
+static RETSIGTYPE gdb_catch_sigchld __ARGS(SIGPROTOARG);
+#endif
 static RETSIGTYPE deathtrap __ARGS(SIGPROTOARG);
 
 static void catch_int_signal __ARGS((void));
@@ -330,6 +333,9 @@ static struct signalinfo
 #ifdef SIGPIPE
     {SIGPIPE,	    "PIPE",	FALSE},
 #endif
+#if defined(FEAT_GDB) && defined(SIGCHLD)
+    {SIGCHLD,	    "CHLD",	FALSE},
+#endif
     {-1,	    "Unknown!", FALSE}
 };
 
@@ -380,6 +386,11 @@ mch_inchar(buf, maxlen, wtime, tb_change_cnt)
 {
     int		len;
 
+#if defined(FEAT_GDB) && defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+    struct timeval  start_tv;
+    gettimeofday(&start_tv, NULL);
+#endif
+
 #ifdef FEAT_NETBEANS_INTG
     /* Process the queued netbeans messages. */
     netbeans_parse_messages();
@@ -394,6 +405,21 @@ mch_inchar(buf, maxlen, wtime, tb_change_cnt)
     {
 	while (WaitForChar(wtime) == 0)		/* no character available */
 	{
+#ifdef FEAT_GDB
+	    if (gdb_event(gdb) && gdb_allowed(gdb))
+	    {
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		if ((wtime = gdb_process_output(gdb, wtime, (void *)&start_tv)) < 0)
+# else
+		/* guess we got interrupted halfway */
+		wtime = wtime / 2;
+
+		if ((wtime = gdb_process_output(gdb, wtime, NULL)) < 0)
+# endif
+		    return 0;	/* launch input-line window */
+		continue;
+	    }
+#endif
 	    if (!do_resize)	/* return if not interrupted by resize */
 		return 0;
 	    handle_resize();
@@ -410,8 +436,25 @@ mch_inchar(buf, maxlen, wtime, tb_change_cnt)
 	 * flush all the swap files to disk.
 	 * Also done when interrupted by SIGWINCH.
 	 */
+#ifdef FEAT_GDB
+	{
+        wtime = p_ut;
+        while (WaitForChar(wtime) == 0)
+        {
+	    if (gdb_event(gdb) && gdb_allowed(gdb))
+	    {
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		if ((wtime = gdb_process_output(gdb, wtime, (void *)&start_tv)) < 0)
+# else
+		if ((wtime = gdb_process_output(gdb, wtime, NULL)) < 0)
+# endif
+		    return 0;	/* launch input-line window */
+		continue;
+            }
+#else
 	if (WaitForChar(p_ut) == 0)
 	{
+#endif
 #ifdef FEAT_AUTOCMD
 	    if (trigger_cursorhold() && maxlen >= 3
 					   && !typebuf_changed(tb_change_cnt))
@@ -423,6 +466,10 @@ mch_inchar(buf, maxlen, wtime, tb_change_cnt)
 	    }
 #endif
 	    before_blocking();
+#ifdef FEAT_GDB
+             break;
+	} /* while (WaitForChar(wtime) == 0) */
+#endif
 	}
     }
 
@@ -442,6 +489,16 @@ mch_inchar(buf, maxlen, wtime, tb_change_cnt)
 	 */
 	if (WaitForChar(-1L) == 0)
 	{
+
+#ifdef FEAT_GDB
+	if (gdb_event(gdb) && gdb_allowed(gdb))
+	{
+	    if (gdb_process_output(gdb, -1L, NULL) < 0)
+		return 0;	/* launch input-line window */
+	    continue;
+	}
+#endif
+
 	    if (do_resize)	    /* interrupted by SIGWINCH signal */
 		handle_resize();
 	    return 0;
@@ -905,6 +962,30 @@ sig_alarm SIGDEFARG(sigarg)
 }
 #endif
 
+#if defined(FEAT_GDB) && defined(SIGCHLD)
+/*
+ * On SIGCHLD, note when gdb process is defunct or does not exist any more
+ */
+    static RETSIGTYPE
+gdb_catch_sigchld SIGDEFARG(sigarg)
+{
+    pid_t wait_pid;
+    pid_t pid;
+
+    if (sigarg == SIGCHLD && (pid = gdb_pid(gdb)) != -1)
+    {
+	wait_pid = waitpid(pid, NULL, WNOHANG);
+
+	if ((wait_pid == (pid_t)-1 && errno == ECHILD)
+		|| wait_pid == pid)
+	    gdb_set_sigchld(gdb, TRUE);
+    }
+
+    signal(SIGCHLD, (RETSIGTYPE (*)())gdb_catch_sigchld);
+    SIGRETURN;
+}
+#endif
+
 #if (defined(HAVE_SETJMP_H) \
 	&& ((defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)) \
 	    || defined(FEAT_LIBCALL))) \
@@ -1326,6 +1407,13 @@ set_signals()
     signal(SIGPWR, (RETSIGTYPE (*)())catch_sigpwr);
 #endif
 
+     /*
+     * Catch SIGCHLD to monitor gdb process state
+     */
+#if defined(FEAT_GDB) && defined(SIGCHLD)
+    signal(SIGCHLD, (RETSIGTYPE (*)())gdb_catch_sigchld);
+#endif
+
     /*
      * Arrange for other signals to gracefully shutdown Vim.
      */
@@ -5099,7 +5187,12 @@ RealWaitForChar(fd, msec, check_for_gpm)
 # endif
 #endif
 #ifndef HAVE_SELECT
+# ifdef FEAT_GDB
 	struct pollfd   fds[6];
+	int		gdb_idx = -1;
+# else
+	struct pollfd   fds[6];
+# endif
 	int		nfd;
 # ifdef FEAT_XCLIPBOARD
 	int		xterm_idx = -1;
@@ -5173,6 +5266,23 @@ RealWaitForChar(fd, msec, check_for_gpm)
 	}
 #endif
 
+# ifdef FEAT_GDB
+	if (msec != 0L && gdb_allowed(gdb))
+	{
+	    /* handle pending SIGCHLD from gdb */
+	    if (gdb_sigchld(gdb))
+	    {
+		gdb_set_event(gdb, TRUE);
+		return 0;
+	    }
+
+	    gdb_idx = nfd;
+	    fds[nfd].fd = gdb_fd(gdb);
+	    fds[nfd].events = POLLIN;
+	    nfd++;
+	}
+# endif
+
 	ret = poll(fds, nfd, towait);
 # ifdef FEAT_MZSCHEME
 	if (ret == 0 && mzquantum_used)
@@ -5180,6 +5290,28 @@ RealWaitForChar(fd, msec, check_for_gpm)
 	    finished = FALSE;
 # endif
 
+# ifdef FEAT_GDB
+	if (msec != 0L && gdb_allowed(gdb))
+	{
+	    if (ret > 0 && fds[gdb_idx].revents & POLLIN)
+	    {
+		ret--;
+		if (!got_int)
+		    gdb_set_event(gdb, TRUE);
+		else
+		    gdb_set_event(gdb, FALSE);
+	    }
+
+	    /* EINTR poll error */
+	    if (ret < 0 && gdb_sigchld(gdb) && !got_int)
+		gdb_set_event(gdb, TRUE);
+
+	    /* an event: gdb's SIGCHLD or gdb data output */
+	    if (gdb_event(gdb))
+		return 0;
+	}
+# endif
+
 # ifdef FEAT_SNIFF
 	if (ret < 0)
 	    sniff_disconnect(1);
@@ -5327,6 +5459,24 @@ select_eintr:
 	}
 # endif
 
+# ifdef FEAT_GDB
+	if (msec != 0L && gdb_allowed(gdb))
+	{
+	    int fd = gdb_fd(gdb);
+
+	    /* handle pending SIGCHLD from gdb */
+	    if (gdb_sigchld(gdb))
+	    {
+		gdb_set_event(gdb, TRUE);
+		return 0;
+            }
+
+	    FD_SET(fd, &rfds);
+	    if (maxfd < fd)
+		maxfd = fd;
+	}
+# endif
+
 # ifdef OLD_VMS
 	/* Old VMS as v6.2 and older have broken select(). It waits more than
 	 * required. Should not be used */
@@ -5363,6 +5513,29 @@ select_eintr:
 	    finished = FALSE;
 # endif
 
+ 
+# ifdef FEAT_GDB
+	if (msec != 0L && gdb_allowed(gdb))
+	{
+	    if (ret > 0 && FD_ISSET(gdb_fd(gdb), &rfds))
+	    {
+		ret--;
+		if (! got_int)
+		    gdb_set_event(gdb, TRUE);
+		else
+		    gdb_set_event(gdb, FALSE);
+	    }
+
+	    /* EINTR select error */
+	    if (ret < 0 && gdb_sigchld(gdb) && ! got_int)
+		gdb_set_event(gdb, TRUE);
+
+	    /* an event: gdb's SIGCHLD or gdb data output */
+	    if (gdb_event(gdb))
+		return 0;
+	}
+# endif
+
 # ifdef FEAT_SNIFF
 	if (ret < 0 )
 	    sniff_disconnect(1);
diff --git a/src/proto.h b/src/proto.h
index 191ecd8..b17bf0a 100644
--- a/src/proto.h
+++ b/src/proto.h
@@ -259,6 +259,10 @@ extern char *vim_SelFile __ARGS((Widget toplevel, char *prompt, char *init_path,
 #  include "if_xcmdsrv.pro"
 # endif
 
+# ifdef FEAT_GDB
+#  include "gdb.pro"
+# endif
+
 /*
  * The perl include files pollute the namespace, therefore proto.h must be
  * included before the perl include files.  But then CV is not defined, which
diff --git a/src/proto/gdb.pro b/src/proto/gdb.pro
new file mode 100644
index 0000000..e4c6052
--- /dev/null
+++ b/src/proto/gdb.pro
@@ -0,0 +1,22 @@
+/* gdb.c */
+gdb_handle_T *gdb_new __ARGS((void));
+void gdb_delete __ARGS((gdb_handle_T **));
+int gdb_isrunning __ARGS((gdb_handle_T *));
+int gdb_fd __ARGS((gdb_handle_T *));
+pid_t gdb_pid __ARGS((gdb_handle_T *));
+int gdb_isbuffer __ARGS((gdb_handle_T *, buf_T *));
+int gdb_allowed __ARGS((gdb_handle_T *));
+int gdb_event __ARGS((gdb_handle_T *));
+int gdb_sigchld __ARGS((gdb_handle_T *));
+void gdb_set_event __ARGS((gdb_handle_T *, int));
+void gdb_set_sigchld __ARGS((gdb_handle_T *, int));
+int gdb_safe_vgetc __ARGS((gdb_handle_T *));
+void gdb_buffer_free __ARGS((gdb_handle_T *, buf_T *));
+void gdb_label __ARGS((gdb_handle_T *, buf_T *, char_u *, size_t));
+void gdb_docmd __ARGS((gdb_handle_T *, char_u *));
+void gdb_setwinput __ARGS((gdb_handle_T *, char_u *));
+int gdb_iswinput __ARGS((gdb_handle_T *));
+void gdb_winput __ARGS((gdb_handle_T *));
+long gdb_process_output __ARGS((gdb_handle_T *, long, void *));
+win_T *gdb_window __ARGS((gdb_handle_T *));
+/* vim: set ft=c : */
diff --git a/src/screen.c b/src/screen.c
index a72ecaf..9214305 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -6414,6 +6414,11 @@ win_redr_status(wp)
 	fillchar = fillchar_status(&attr, wp == curwin);
 
 	get_trans_bufname(wp->w_buffer);
+#ifdef FEAT_GDB
+	/* Replace fname with gdb window label */
+	gdb_label(gdb, wp->w_buffer, NameBuff, MAXPATHL);
+	trans_characters(NameBuff, MAXPATHL);
+#endif
 	p = NameBuff;
 	len = (int)STRLEN(p);
 
diff --git a/src/structs.h b/src/structs.h
index f74d218..e2235de 100644
--- a/src/structs.h
+++ b/src/structs.h
@@ -651,7 +651,7 @@ struct signlist
     linenr_T	lnum;		/* line number which has this sign */
     int		typenr;		/* typenr of sign */
     signlist_T	*next;		/* next signlist entry */
-# ifdef FEAT_NETBEANS_INTG
+# if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GDB)
     signlist_T  *prev;		/* previous entry -- for easy reordering */
 # endif
 };
@@ -663,6 +663,13 @@ struct signlist
 #define SIGN_TEXT	3
 #endif
 
+#ifdef FEAT_GDB
+typedef struct
+{
+    int dummy;
+} gdb_handle_T;
+#endif
+
 /*
  * Argument list: Array of file names.
  * Used for the global argument list and the argument lists local to a window.
diff --git a/src/version.c b/src/version.c
index f063557..0c94f54 100644
--- a/src/version.c
+++ b/src/version.c
@@ -248,6 +248,11 @@ static char *(features[]) =
 #if !defined(USE_SYSTEM) && defined(UNIX)
 	"+fork()",
 #endif
+#ifdef FEAT_GDB
+	"+gdb",
+#else
+	"-gdb",
+#endif
 #ifdef FEAT_GETTEXT
 # ifdef DYNAMIC_GETTEXT
 	"+gettext/dyn",
diff --git a/src/window.c b/src/window.c
index 16e0ee7..7328f65 100644
--- a/src/window.c
+++ b/src/window.c
@@ -6389,6 +6389,10 @@ only_one_window()
 # ifdef FEAT_QUICKFIX
 		    || wp->w_p_pvw
 # endif
+# ifdef FEAT_GDB
+		    /* not counting a gdb window */
+		    || gdb_isbuffer(gdb, wp->w_buffer)
+# endif
 	     ) || wp == curwin)
 # ifdef FEAT_AUTOCMD
 		&& wp != aucmd_win
-- 
1.9.1

